[N] Compiling to library, output file: src\lib\standard.dlb
[S] Scope init: {Pub:main}, StackLength=1
[D] MOD[0]: name=standard path=src\lib\standard.ds library=yes
[I] MOD: name=standard index=0 searchindex=0, scope={Pub:main}
[D] TRK[0]: name=standard module=standard
[I] TRK: name=standard index=0 searchindex=0, scope={Pub:main}
[O] Relocation added: Type=BlkInsideGlo, LocAdr=0000000000000000h
[Y] Store OTYP[0]: name=bool msttype=0 FunIndex=-1 SupTypIndex=-1 IsTypedef=0 IsSystemDef=1 Length=1 DimNr=0 ElemTypIndex=-1 DimIndex=-1 FieldLow=-1 FieldHigh=-1
[D] TYP[0]: name=bool msttype=boolean scope={Pub:main} typedef=no systemdef=yes length=1
[I] TYP: name=standard.bool index=0 searchindex=0, scope={Pub:main}
[O] Relocation added: Type=BlkInsideGlo, LocAdr=0000000000000004h
[Y] Store OTYP[1]: name=char msttype=1 FunIndex=-1 SupTypIndex=-1 IsTypedef=0 IsSystemDef=1 Length=1 DimNr=0 ElemTypIndex=-1 DimIndex=-1 FieldLow=-1 FieldHigh=-1
[D] TYP[1]: name=char msttype=char scope={Pub:main} typedef=no systemdef=yes length=1
[I] TYP: name=standard.char index=1 searchindex=1, scope={Pub:main}
[O] Relocation added: Type=BlkInsideGlo, LocAdr=0000000000000008h
[Y] Store OTYP[2]: name=short msttype=2 FunIndex=-1 SupTypIndex=-1 IsTypedef=0 IsSystemDef=1 Length=2 DimNr=0 ElemTypIndex=-1 DimIndex=-1 FieldLow=-1 FieldHigh=-1
[D] TYP[2]: name=short msttype=short scope={Pub:main} typedef=no systemdef=yes length=2
[I] TYP: name=standard.short index=2 searchindex=2, scope={Pub:main}
[O] Relocation added: Type=BlkInsideGlo, LocAdr=000000000000000Ch
[Y] Store OTYP[3]: name=int msttype=3 FunIndex=-1 SupTypIndex=-1 IsTypedef=0 IsSystemDef=1 Length=4 DimNr=0 ElemTypIndex=-1 DimIndex=-1 FieldLow=-1 FieldHigh=-1
[D] TYP[3]: name=int msttype=integer scope={Pub:main} typedef=no systemdef=yes length=4
[I] TYP: name=standard.int index=3 searchindex=2, scope={Pub:main}
[O] Relocation added: Type=BlkInsideGlo, LocAdr=0000000000000010h
[Y] Store OTYP[4]: name=long msttype=4 FunIndex=-1 SupTypIndex=-1 IsTypedef=0 IsSystemDef=1 Length=8 DimNr=0 ElemTypIndex=-1 DimIndex=-1 FieldLow=-1 FieldHigh=-1
[D] TYP[4]: name=long msttype=long scope={Pub:main} typedef=no systemdef=yes length=8
[I] TYP: name=standard.long index=4 searchindex=3, scope={Pub:main}
[O] Relocation added: Type=BlkInsideGlo, LocAdr=0000000000000014h
[Y] Store OTYP[5]: name=float msttype=5 FunIndex=-1 SupTypIndex=-1 IsTypedef=0 IsSystemDef=1 Length=8 DimNr=0 ElemTypIndex=-1 DimIndex=-1 FieldLow=-1 FieldHigh=-1
[D] TYP[5]: name=float msttype=float scope={Pub:main} typedef=no systemdef=yes length=8
[I] TYP: name=standard.float index=5 searchindex=2, scope={Pub:main}
[O] Relocation added: Type=BlkInsideGlo, LocAdr=0000000000000018h
[Y] Store OTYP[6]: name=string msttype=6 FunIndex=-1 SupTypIndex=-1 IsTypedef=0 IsSystemDef=1 Length=4 DimNr=0 ElemTypIndex=-1 DimIndex=-1 FieldLow=-1 FieldHigh=-1
[D] TYP[6]: name=string msttype=string scope={Pub:main} typedef=no systemdef=yes length=4
[I] TYP: name=standard.string index=6 searchindex=6, scope={Pub:main}
[O] Relocation added: Type=BlkInsideGlo, LocAdr=000000000000001Ch
[Y] Store OTYP[7]: name=char[] msttype=10 FunIndex=-1 SupTypIndex=-1 IsTypedef=0 IsSystemDef=1 Length=4 DimNr=1 ElemTypIndex=1 DimIndex=-1 FieldLow=-1 FieldHigh=-1
[D] TYP[7]: name=char[] msttype=darray scope={Pub:main} typedef=no systemdef=yes length=4 dimnr=1 elemtype=char
[I] TYP: name=standard.char[] index=7 searchindex=2, scope={Pub:main}
[O] Relocation added: Type=BlkInsideGlo, LocAdr=0000000000000020h
[Y] Store OTYP[8]: name=string[] msttype=10 FunIndex=-1 SupTypIndex=-1 IsTypedef=0 IsSystemDef=1 Length=4 DimNr=1 ElemTypIndex=6 DimIndex=-1 FieldLow=-1 FieldHigh=-1
[D] TYP[8]: name=string[] msttype=darray scope={Pub:main} typedef=no systemdef=yes length=4 dimnr=1 elemtype=string
[I] TYP: name=standard.string[] index=8 searchindex=8, scope={Pub:main}
[O] Relocation added: Type=BlkInsideGlo, LocAdr=0000000000000024h
[Y] Store OTYP[9]: name=word msttype=4 FunIndex=-1 SupTypIndex=-1 IsTypedef=0 IsSystemDef=1 Length=8 DimNr=0 ElemTypIndex=-1 DimIndex=-1 FieldLow=-1 FieldHigh=-1
[D] TYP[9]: name=word msttype=long scope={Pub:main} typedef=no systemdef=yes length=8
[I] TYP: name=standard.word index=9 searchindex=9, scope={Pub:main}
[D] VAR[0]: name=__hostsystem__ type=string scope={Pub:main} address=40 const=yes static=no parameter=no ref=no temp=no buffstore=yes length=4
[I] VAR: name=standard.__hostsystem__ index=0 searchindex=0, scope={Pub:main}
[O] Relocation added: Type=BlkInsideGlo, LocAdr=0000000000000028h
[D] VAR[1]: name=__architecture__ type=int scope={Pub:main} address=44 const=yes static=no parameter=no ref=no temp=no buffstore=yes length=4
[I] VAR: name=standard.__architecture__ index=1 searchindex=0, scope={Pub:main}
[D] FUN[0]: name=dsize kind=MasterMth returns=word void=no nested=no msttype=farray
[D] PAR[0]: function=dsize name=$result type=word order=0 const=no ref=yes
[D] PAR[1]: function=dsize name=dimension type=char order=1 const=no ref=no
[I] FUN: name=farray.dsize(char) index=0 searchindex=0, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=farray.dsize($cvint) index=0 searchindex=0, scope={Pub:main}, scope={Pub:main}
[D] FID[0]: name=dsize kind=1 fullname=farray.dsize(char) id=farray_dsize
[D] FUN[1]: name=rsize kind=MasterMth returns=undefined void=yes nested=no msttype=darray
[D] PAR[2]: function=rsize name=size1 type=word order=0 const=no ref=no
[I] FUN: name=darray.rsize(long) index=1 searchindex=0, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=darray.rsize($cvint) index=1 searchindex=0, scope={Pub:main}, scope={Pub:main}
[D] FID[1]: name=rsize kind=1 fullname=darray.rsize(long) id=darray_rsize
[D] FUN[2]: name=rsize kind=MasterMth returns=undefined void=yes nested=no msttype=darray
[D] PAR[3]: function=rsize name=size1 type=word order=0 const=no ref=no
[D] PAR[4]: function=rsize name=size2 type=word order=1 const=no ref=no
[I] FUN: name=darray.rsize(long,long) index=2 searchindex=1, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=darray.rsize($cvint,$cvint) index=2 searchindex=1, scope={Pub:main}, scope={Pub:main}
[D] FID[2]: name=rsize kind=1 fullname=darray.rsize(long,long) id=darray_rsize2
[D] FUN[3]: name=rsize kind=MasterMth returns=undefined void=yes nested=no msttype=darray
[D] PAR[5]: function=rsize name=size1 type=word order=0 const=no ref=no
[D] PAR[6]: function=rsize name=size2 type=word order=1 const=no ref=no
[D] PAR[7]: function=rsize name=size3 type=word order=2 const=no ref=no
[I] FUN: name=darray.rsize(long,long,long) index=3 searchindex=2, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=darray.rsize($cvint,$cvint,$cvint) index=3 searchindex=2, scope={Pub:main}, scope={Pub:main}
[D] FID[3]: name=rsize kind=1 fullname=darray.rsize(long,long,long) id=darray_rsize3
[D] FUN[4]: name=rsize kind=MasterMth returns=undefined void=yes nested=no msttype=darray
[D] PAR[8]: function=rsize name=size1 type=word order=0 const=no ref=no
[D] PAR[9]: function=rsize name=size2 type=word order=1 const=no ref=no
[D] PAR[10]: function=rsize name=size3 type=word order=2 const=no ref=no
[D] PAR[11]: function=rsize name=size4 type=word order=3 const=no ref=no
[I] FUN: name=darray.rsize(long,long,long,long) index=4 searchindex=3, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=darray.rsize($cvint,$cvint,$cvint,$cvint) index=4 searchindex=3, scope={Pub:main}, scope={Pub:main}
[D] FID[4]: name=rsize kind=1 fullname=darray.rsize(long,long,long,long) id=darray_rsize4
[D] FUN[5]: name=rsize kind=MasterMth returns=undefined void=yes nested=no msttype=darray
[D] PAR[12]: function=rsize name=size1 type=word order=0 const=no ref=no
[D] PAR[13]: function=rsize name=size2 type=word order=1 const=no ref=no
[D] PAR[14]: function=rsize name=size3 type=word order=2 const=no ref=no
[D] PAR[15]: function=rsize name=size4 type=word order=3 const=no ref=no
[D] PAR[16]: function=rsize name=size5 type=word order=4 const=no ref=no
[I] FUN: name=darray.rsize(long,long,long,long,long) index=5 searchindex=4, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=darray.rsize($cvint,$cvint,$cvint,$cvint,$cvint) index=5 searchindex=4, scope={Pub:main}, scope={Pub:main}
[D] FID[5]: name=rsize kind=1 fullname=darray.rsize(long,long,long,long,long) id=darray_rsize5
[D] FUN[6]: name=dsize kind=MasterMth returns=word void=no nested=no msttype=darray
[D] PAR[17]: function=dsize name=$result type=word order=0 const=no ref=yes
[D] PAR[18]: function=dsize name=dimension type=char order=1 const=no ref=no
[I] FUN: name=darray.dsize(char) index=6 searchindex=0, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=darray.dsize($cvint) index=6 searchindex=0, scope={Pub:main}, scope={Pub:main}
[D] FID[6]: name=dsize kind=1 fullname=darray.dsize(char) id=darray_dsize
[D] FUN[7]: name=reset kind=MasterMth returns=undefined void=yes nested=no msttype=darray
[I] FUN: name=darray.reset() index=7 searchindex=1, scope={Pub:main}, scope={Pub:main}
[D] FID[7]: name=reset kind=1 fullname=darray.reset() id=darray_reset
[D] FUN[8]: name=upper kind=MasterMth returns=char void=no nested=no msttype=char
[D] PAR[19]: function=upper name=$result type=char order=0 const=no ref=yes
[I] FUN: name=char.upper() index=8 searchindex=0, scope={Pub:main}, scope={Pub:main}
[D] FID[8]: name=upper kind=1 fullname=char.upper() id=char_upper
[D] FUN[9]: name=lower kind=MasterMth returns=char void=no nested=no msttype=char
[D] PAR[20]: function=lower name=$result type=char order=0 const=no ref=yes
[I] FUN: name=char.lower() index=9 searchindex=0, scope={Pub:main}, scope={Pub:main}
[D] FID[9]: name=lower kind=1 fullname=char.lower() id=char_lower
[D] FUN[10]: name=length kind=MasterMth returns=word void=no nested=no msttype=string
[D] PAR[21]: function=length name=$result type=word order=0 const=no ref=yes
[I] FUN: name=string.length() index=10 searchindex=10, scope={Pub:main}, scope={Pub:main}
[D] FID[10]: name=length kind=1 fullname=string.length() id=string_length
[D] FUN[11]: name=sub kind=MasterMth returns=string void=no nested=no msttype=string
[D] PAR[22]: function=sub name=$result type=string order=0 const=no ref=yes
[D] PAR[23]: function=sub name=position type=word order=1 const=no ref=no
[D] PAR[24]: function=sub name=length type=word order=2 const=no ref=no
[I] FUN: name=string.sub(long,long) index=11 searchindex=11, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=string.sub($cvint,$cvint) index=11 searchindex=7, scope={Pub:main}, scope={Pub:main}
[D] FID[11]: name=sub kind=1 fullname=string.sub(long,long) id=string_sub
[D] FUN[12]: name=right kind=MasterMth returns=string void=no nested=no msttype=string
[D] PAR[25]: function=right name=$result type=string order=0 const=no ref=yes
[D] PAR[26]: function=right name=length type=word order=1 const=no ref=no
[I] FUN: name=string.right(long) index=12 searchindex=11, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=string.right($cvint) index=12 searchindex=7, scope={Pub:main}, scope={Pub:main}
[D] FID[12]: name=right kind=1 fullname=string.right(long) id=string_right
[D] FUN[13]: name=left kind=MasterMth returns=string void=no nested=no msttype=string
[D] PAR[27]: function=left name=$result type=string order=0 const=no ref=yes
[D] PAR[28]: function=left name=length type=word order=1 const=no ref=no
[I] FUN: name=string.left(long) index=13 searchindex=10, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=string.left($cvint) index=13 searchindex=7, scope={Pub:main}, scope={Pub:main}
[D] FID[13]: name=left kind=1 fullname=string.left(long) id=string_left
[D] FUN[14]: name=cutr kind=MasterMth returns=string void=no nested=no msttype=string
[D] PAR[29]: function=cutr name=$result type=string order=0 const=no ref=yes
[D] PAR[30]: function=cutr name=length type=word order=1 const=no ref=no
[I] FUN: name=string.cutr(long) index=14 searchindex=10, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=string.cutr($cvint) index=14 searchindex=7, scope={Pub:main}, scope={Pub:main}
[D] FID[14]: name=cutr kind=1 fullname=string.cutr(long) id=string_cutr
[D] FUN[15]: name=cutl kind=MasterMth returns=string void=no nested=no msttype=string
[D] PAR[31]: function=cutl name=$result type=string order=0 const=no ref=yes
[D] PAR[32]: function=cutl name=length type=word order=1 const=no ref=no
[I] FUN: name=string.cutl(long) index=15 searchindex=10, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=string.cutl($cvint) index=15 searchindex=7, scope={Pub:main}, scope={Pub:main}
[D] FID[15]: name=cutl kind=1 fullname=string.cutl(long) id=string_cutl
[D] FUN[16]: name=search kind=MasterMth returns=word void=no nested=no msttype=string
[D] PAR[33]: function=search name=$result type=word order=0 const=no ref=yes
[D] PAR[34]: function=search name=substring type=string order=1 const=yes ref=yes
[D] PAR[35]: function=search name=start type=word order=2 const=no ref=no
[I] FUN: name=string.search(string,long) index=16 searchindex=15, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=string.search($cvstr,$cvint) index=16 searchindex=11, scope={Pub:main}, scope={Pub:main}
[D] FID[16]: name=search kind=1 fullname=string.search(string,long) id=string_search
[D] FUN[17]: name=replace kind=MasterMth returns=string void=no nested=no msttype=string
[D] PAR[36]: function=replace name=$result type=string order=0 const=no ref=yes
[D] PAR[37]: function=replace name=old type=string order=1 const=yes ref=yes
[D] PAR[38]: function=replace name=new type=string order=2 const=yes ref=yes
[I] FUN: name=string.replace(string,string) index=17 searchindex=14, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=string.replace($cvstr,$cvstr) index=17 searchindex=10, scope={Pub:main}, scope={Pub:main}
[D] FID[17]: name=replace kind=1 fullname=string.replace(string,string) id=string_replace
[D] FUN[18]: name=trim kind=MasterMth returns=string void=no nested=no msttype=string
[D] PAR[39]: function=trim name=$result type=string order=0 const=no ref=yes
[I] FUN: name=string.trim() index=18 searchindex=18, scope={Pub:main}, scope={Pub:main}
[D] FID[18]: name=trim kind=1 fullname=string.trim() id=string_trim
[D] FUN[19]: name=upper kind=MasterMth returns=string void=no nested=no msttype=string
[D] PAR[40]: function=upper name=$result type=string order=0 const=no ref=yes
[I] FUN: name=string.upper() index=19 searchindex=19, scope={Pub:main}, scope={Pub:main}
[D] FID[19]: name=upper kind=1 fullname=string.upper() id=string_upper
[D] FUN[20]: name=lower kind=MasterMth returns=string void=no nested=no msttype=string
[D] PAR[41]: function=lower name=$result type=string order=0 const=no ref=yes
[I] FUN: name=string.lower() index=20 searchindex=14, scope={Pub:main}, scope={Pub:main}
[D] FID[20]: name=lower kind=1 fullname=string.lower() id=string_lower
[D] FUN[21]: name=ljust kind=MasterMth returns=string void=no nested=no msttype=string
[D] PAR[42]: function=ljust name=$result type=string order=0 const=no ref=yes
[D] PAR[43]: function=ljust name=width type=int order=1 const=no ref=no
[I] FUN: name=string.ljust(int) index=21 searchindex=14, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=string.ljust($cvint) index=21 searchindex=10, scope={Pub:main}, scope={Pub:main}
[D] FID[21]: name=ljust kind=1 fullname=string.ljust(int) id=string_ljust
[D] FUN[22]: name=rjust kind=MasterMth returns=string void=no nested=no msttype=string
[D] PAR[44]: function=rjust name=$result type=string order=0 const=no ref=yes
[D] PAR[45]: function=rjust name=width type=int order=1 const=no ref=no
[I] FUN: name=string.rjust(int) index=22 searchindex=18, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=string.rjust($cvint) index=22 searchindex=13, scope={Pub:main}, scope={Pub:main}
[D] FID[22]: name=rjust kind=1 fullname=string.rjust(int) id=string_rjust
[D] FUN[23]: name=ljust kind=MasterMth returns=string void=no nested=no msttype=string
[D] PAR[46]: function=ljust name=$result type=string order=0 const=no ref=yes
[D] PAR[47]: function=ljust name=width type=int order=1 const=no ref=no
[D] PAR[48]: function=ljust name=fillchar type=char order=2 const=no ref=no
[I] FUN: name=string.ljust(int,char) index=23 searchindex=15, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=string.ljust($cvint,$cvint) index=23 searchindex=11, scope={Pub:main}, scope={Pub:main}
[D] FID[23]: name=ljust kind=1 fullname=string.ljust(int,char) id=string_ljust2
[D] FUN[24]: name=rjust kind=MasterMth returns=string void=no nested=no msttype=string
[D] PAR[49]: function=rjust name=$result type=string order=0 const=no ref=yes
[D] PAR[50]: function=rjust name=width type=int order=1 const=no ref=no
[D] PAR[51]: function=rjust name=fillchar type=char order=2 const=no ref=no
[I] FUN: name=string.rjust(int,char) index=24 searchindex=20, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=string.rjust($cvint,$cvint) index=24 searchindex=15, scope={Pub:main}, scope={Pub:main}
[D] FID[24]: name=rjust kind=1 fullname=string.rjust(int,char) id=string_rjust2
[D] FUN[25]: name=match kind=MasterMth returns=bool void=no nested=no msttype=string
[D] PAR[52]: function=match name=$result type=bool order=0 const=no ref=yes
[D] PAR[53]: function=match name=regex type=string order=1 const=yes ref=yes
[I] FUN: name=string.match(string) index=25 searchindex=17, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=string.match($cvstr) index=25 searchindex=12, scope={Pub:main}, scope={Pub:main}
[D] FID[25]: name=match kind=1 fullname=string.match(string) id=string_match
[D] FUN[26]: name=like kind=MasterMth returns=bool void=no nested=no msttype=string
[D] PAR[54]: function=like name=$result type=bool order=0 const=no ref=yes
[D] PAR[55]: function=like name=pattern type=string order=1 const=yes ref=yes
[I] FUN: name=string.like(string) index=26 searchindex=14, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=string.like($cvstr) index=26 searchindex=10, scope={Pub:main}, scope={Pub:main}
[D] FID[26]: name=like kind=1 fullname=string.like(string) id=string_like
[D] FUN[27]: name=replicate kind=MasterMth returns=string void=no nested=no msttype=string
[D] PAR[56]: function=replicate name=$result type=string order=0 const=no ref=yes
[D] PAR[57]: function=replicate name=times type=int order=1 const=no ref=no
[I] FUN: name=string.replicate(int) index=27 searchindex=20, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=string.replicate($cvint) index=27 searchindex=15, scope={Pub:main}, scope={Pub:main}
[D] FID[27]: name=replicate kind=1 fullname=string.replicate(int) id=string_replicate
[D] FUN[28]: name=split kind=MasterMth returns=string[] void=no nested=no msttype=string
[D] PAR[58]: function=split name=$result type=string[] order=0 const=no ref=yes
[D] PAR[59]: function=split name=separator type=string order=1 const=yes ref=yes
[I] FUN: name=string.split(string) index=28 searchindex=25, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=string.split($cvstr) index=28 searchindex=20, scope={Pub:main}, scope={Pub:main}
[D] FID[28]: name=split kind=1 fullname=string.split(string) id=string_split
[D] FUN[29]: name=startswith kind=MasterMth returns=bool void=no nested=no msttype=string
[D] PAR[60]: function=startswith name=$result type=bool order=0 const=no ref=yes
[D] PAR[61]: function=startswith name=substring type=string order=1 const=yes ref=yes
[I] FUN: name=string.startswith(string) index=29 searchindex=26, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=string.startswith($cvstr) index=29 searchindex=21, scope={Pub:main}, scope={Pub:main}
[D] FID[29]: name=startswith kind=1 fullname=string.startswith(string) id=string_startswith
[D] FUN[30]: name=endswith kind=MasterMth returns=bool void=no nested=no msttype=string
[D] PAR[62]: function=endswith name=$result type=bool order=0 const=no ref=yes
[D] PAR[63]: function=endswith name=substring type=string order=1 const=yes ref=yes
[I] FUN: name=string.endswith(string) index=30 searchindex=12, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=string.endswith($cvstr) index=30 searchindex=9, scope={Pub:main}, scope={Pub:main}
[D] FID[30]: name=endswith kind=1 fullname=string.endswith(string) id=string_endswith
[D] FUN[31]: name=isbol kind=MasterMth returns=bool void=no nested=no msttype=string
[D] PAR[64]: function=isbol name=$result type=bool order=0 const=no ref=yes
[I] FUN: name=string.isbol() index=31 searchindex=13, scope={Pub:main}, scope={Pub:main}
[D] FID[31]: name=isbol kind=1 fullname=string.isbol() id=string_isbol
[D] FUN[32]: name=ischr kind=MasterMth returns=bool void=no nested=no msttype=string
[D] PAR[65]: function=ischr name=$result type=bool order=0 const=no ref=yes
[I] FUN: name=string.ischr() index=32 searchindex=14, scope={Pub:main}, scope={Pub:main}
[D] FID[32]: name=ischr kind=1 fullname=string.ischr() id=string_ischr
[D] FUN[33]: name=isshr kind=MasterMth returns=bool void=no nested=no msttype=string
[D] PAR[66]: function=isshr name=$result type=bool order=0 const=no ref=yes
[I] FUN: name=string.isshr() index=33 searchindex=15, scope={Pub:main}, scope={Pub:main}
[D] FID[33]: name=isshr kind=1 fullname=string.isshr() id=string_isshr
[D] FUN[34]: name=isint kind=MasterMth returns=bool void=no nested=no msttype=string
[D] PAR[67]: function=isint name=$result type=bool order=0 const=no ref=yes
[I] FUN: name=string.isint() index=34 searchindex=15, scope={Pub:main}, scope={Pub:main}
[D] FID[34]: name=isint kind=1 fullname=string.isint() id=string_isint
[D] FUN[35]: name=islon kind=MasterMth returns=bool void=no nested=no msttype=string
[D] PAR[68]: function=islon name=$result type=bool order=0 const=no ref=yes
[I] FUN: name=string.islon() index=35 searchindex=16, scope={Pub:main}, scope={Pub:main}
[D] FID[35]: name=islon kind=1 fullname=string.islon() id=string_islon
[D] FUN[36]: name=isflo kind=MasterMth returns=bool void=no nested=no msttype=string
[D] PAR[69]: function=isflo name=$result type=bool order=0 const=no ref=yes
[I] FUN: name=string.isflo() index=36 searchindex=15, scope={Pub:main}, scope={Pub:main}
[D] FID[36]: name=isflo kind=1 fullname=string.isflo() id=string_isflo
[D] FUN[37]: name=tochr kind=MasterMth returns=char void=no nested=no msttype=boolean
[D] PAR[70]: function=tochr name=$result type=char order=0 const=no ref=yes
[I] FUN: name=boolean.tochr() index=37 searchindex=0, scope={Pub:main}, scope={Pub:main}
[D] FID[37]: name=tochr kind=1 fullname=boolean.tochr() id=boolean_tochr
[D] FUN[38]: name=toshr kind=MasterMth returns=short void=no nested=no msttype=boolean
[D] PAR[71]: function=toshr name=$result type=short order=0 const=no ref=yes
[I] FUN: name=boolean.toshr() index=38 searchindex=1, scope={Pub:main}, scope={Pub:main}
[D] FID[38]: name=toshr kind=1 fullname=boolean.toshr() id=boolean_toshr
[D] FUN[39]: name=toint kind=MasterMth returns=int void=no nested=no msttype=boolean
[D] PAR[72]: function=toint name=$result type=int order=0 const=no ref=yes
[I] FUN: name=boolean.toint() index=39 searchindex=1, scope={Pub:main}, scope={Pub:main}
[D] FID[39]: name=toint kind=1 fullname=boolean.toint() id=boolean_toint
[D] FUN[40]: name=tolon kind=MasterMth returns=long void=no nested=no msttype=boolean
[D] PAR[73]: function=tolon name=$result type=long order=0 const=no ref=yes
[I] FUN: name=boolean.tolon() index=40 searchindex=2, scope={Pub:main}, scope={Pub:main}
[D] FID[40]: name=tolon kind=1 fullname=boolean.tolon() id=boolean_tolon
[D] FUN[41]: name=toflo kind=MasterMth returns=float void=no nested=no msttype=boolean
[D] PAR[74]: function=toflo name=$result type=float order=0 const=no ref=yes
[I] FUN: name=boolean.toflo() index=41 searchindex=1, scope={Pub:main}, scope={Pub:main}
[D] FID[41]: name=toflo kind=1 fullname=boolean.toflo() id=boolean_toflo
[D] FUN[42]: name=tostr kind=MasterMth returns=string void=no nested=no msttype=boolean
[D] PAR[75]: function=tostr name=$result type=string order=0 const=no ref=yes
[I] FUN: name=boolean.tostr() index=42 searchindex=5, scope={Pub:main}, scope={Pub:main}
[D] FID[42]: name=tostr kind=1 fullname=boolean.tostr() id=boolean_tostr
[D] FUN[43]: name=tobol kind=MasterMth returns=bool void=no nested=no msttype=char
[D] PAR[76]: function=tobol name=$result type=char order=0 const=no ref=yes
[I] FUN: name=char.tobol() index=43 searchindex=7, scope={Pub:main}, scope={Pub:main}
[D] FID[43]: name=tobol kind=1 fullname=char.tobol() id=char_tobol
[D] FUN[44]: name=toshr kind=MasterMth returns=short void=no nested=no msttype=char
[D] PAR[77]: function=toshr name=$result type=short order=0 const=no ref=yes
[I] FUN: name=char.toshr() index=44 searchindex=8, scope={Pub:main}, scope={Pub:main}
[D] FID[44]: name=toshr kind=1 fullname=char.toshr() id=char_toshr
[D] FUN[45]: name=toint kind=MasterMth returns=int void=no nested=no msttype=char
[D] PAR[78]: function=toint name=$result type=int order=0 const=no ref=yes
[I] FUN: name=char.toint() index=45 searchindex=8, scope={Pub:main}, scope={Pub:main}
[D] FID[45]: name=toint kind=1 fullname=char.toint() id=char_toint
[D] FUN[46]: name=tolon kind=MasterMth returns=long void=no nested=no msttype=char
[D] PAR[79]: function=tolon name=$result type=long order=0 const=no ref=yes
[I] FUN: name=char.tolon() index=46 searchindex=9, scope={Pub:main}, scope={Pub:main}
[D] FID[46]: name=tolon kind=1 fullname=char.tolon() id=char_tolon
[D] FUN[47]: name=toflo kind=MasterMth returns=float void=no nested=no msttype=char
[D] PAR[80]: function=toflo name=$result type=float order=0 const=no ref=yes
[I] FUN: name=char.toflo() index=47 searchindex=8, scope={Pub:main}, scope={Pub:main}
[D] FID[47]: name=toflo kind=1 fullname=char.toflo() id=char_toflo
[D] FUN[48]: name=tostr kind=MasterMth returns=string void=no nested=no msttype=char
[D] PAR[81]: function=tostr name=$result type=string order=0 const=no ref=yes
[I] FUN: name=char.tostr() index=48 searchindex=12, scope={Pub:main}, scope={Pub:main}
[D] FID[48]: name=tostr kind=1 fullname=char.tostr() id=char_tostr
[D] FUN[49]: name=tobol kind=MasterMth returns=bool void=no nested=no msttype=short
[D] PAR[82]: function=tobol name=$result type=bool order=0 const=no ref=yes
[I] FUN: name=short.tobol() index=49 searchindex=22, scope={Pub:main}, scope={Pub:main}
[D] FID[49]: name=tobol kind=1 fullname=short.tobol() id=short_tobol
[D] FUN[50]: name=tochr kind=MasterMth returns=char void=no nested=no msttype=short
[D] PAR[83]: function=tochr name=$result type=char order=0 const=no ref=yes
[I] FUN: name=short.tochr() index=50 searchindex=23, scope={Pub:main}, scope={Pub:main}
[D] FID[50]: name=tochr kind=1 fullname=short.tochr() id=short_tochr
[D] FUN[51]: name=toint kind=MasterMth returns=int void=no nested=no msttype=short
[D] PAR[84]: function=toint name=$result type=int order=0 const=no ref=yes
[I] FUN: name=short.toint() index=51 searchindex=24, scope={Pub:main}, scope={Pub:main}
[D] FID[51]: name=toint kind=1 fullname=short.toint() id=short_toint
[D] FUN[52]: name=tolon kind=MasterMth returns=long void=no nested=no msttype=short
[D] PAR[85]: function=tolon name=$result type=long order=0 const=no ref=yes
[I] FUN: name=short.tolon() index=52 searchindex=25, scope={Pub:main}, scope={Pub:main}
[D] FID[52]: name=tolon kind=1 fullname=short.tolon() id=short_tolon
[D] FUN[53]: name=toflo kind=MasterMth returns=float void=no nested=no msttype=short
[D] PAR[86]: function=toflo name=$result type=float order=0 const=no ref=yes
[I] FUN: name=short.toflo() index=53 searchindex=24, scope={Pub:main}, scope={Pub:main}
[D] FID[53]: name=toflo kind=1 fullname=short.toflo() id=short_toflo
[D] FUN[54]: name=tostr kind=MasterMth returns=string void=no nested=no msttype=short
[D] PAR[87]: function=tostr name=$result type=string order=0 const=no ref=yes
[I] FUN: name=short.tostr() index=54 searchindex=27, scope={Pub:main}, scope={Pub:main}
[D] FID[54]: name=tostr kind=1 fullname=short.tostr() id=short_tostr
[D] FUN[55]: name=tobol kind=MasterMth returns=bool void=no nested=no msttype=integer
[D] PAR[88]: function=tobol name=$result type=bool order=0 const=no ref=yes
[I] FUN: name=integer.tobol() index=55 searchindex=22, scope={Pub:main}, scope={Pub:main}
[D] FID[55]: name=tobol kind=1 fullname=integer.tobol() id=integer_tobol
[D] FUN[56]: name=tochr kind=MasterMth returns=char void=no nested=no msttype=integer
[D] PAR[89]: function=tochr name=$result type=char order=0 const=no ref=yes
[I] FUN: name=integer.tochr() index=56 searchindex=23, scope={Pub:main}, scope={Pub:main}
[D] FID[56]: name=tochr kind=1 fullname=integer.tochr() id=integer_tochr
[D] FUN[57]: name=toshr kind=MasterMth returns=short void=no nested=no msttype=integer
[D] PAR[90]: function=toshr name=$result type=short order=0 const=no ref=yes
[I] FUN: name=integer.toshr() index=57 searchindex=24, scope={Pub:main}, scope={Pub:main}
[D] FID[57]: name=toshr kind=1 fullname=integer.toshr() id=integer_toshr
[D] FUN[58]: name=tolon kind=MasterMth returns=long void=no nested=no msttype=integer
[D] PAR[91]: function=tolon name=$result type=long order=0 const=no ref=yes
[I] FUN: name=integer.tolon() index=58 searchindex=24, scope={Pub:main}, scope={Pub:main}
[D] FID[58]: name=tolon kind=1 fullname=integer.tolon() id=integer_tolon
[D] FUN[59]: name=toflo kind=MasterMth returns=float void=no nested=no msttype=integer
[D] PAR[92]: function=toflo name=$result type=float order=0 const=no ref=yes
[I] FUN: name=integer.toflo() index=59 searchindex=24, scope={Pub:main}, scope={Pub:main}
[D] FID[59]: name=toflo kind=1 fullname=integer.toflo() id=integer_toflo
[D] FUN[60]: name=tostr kind=MasterMth returns=string void=no nested=no msttype=integer
[D] PAR[93]: function=tostr name=$result type=string order=0 const=no ref=yes
[I] FUN: name=integer.tostr() index=60 searchindex=27, scope={Pub:main}, scope={Pub:main}
[D] FID[60]: name=tostr kind=1 fullname=integer.tostr() id=integer_tostr
[D] FUN[61]: name=tobol kind=MasterMth returns=bool void=no nested=no msttype=long
[D] PAR[94]: function=tobol name=$result type=bool order=0 const=no ref=yes
[I] FUN: name=long.tobol() index=61 searchindex=28, scope={Pub:main}, scope={Pub:main}
[D] FID[61]: name=tobol kind=1 fullname=long.tobol() id=long_tobol
[D] FUN[62]: name=tochr kind=MasterMth returns=char void=no nested=no msttype=long
[D] PAR[95]: function=tochr name=$result type=char order=0 const=no ref=yes
[I] FUN: name=long.tochr() index=62 searchindex=29, scope={Pub:main}, scope={Pub:main}
[D] FID[62]: name=tochr kind=1 fullname=long.tochr() id=long_tochr
[D] FUN[63]: name=toshr kind=MasterMth returns=short void=no nested=no msttype=long
[D] PAR[96]: function=toshr name=$result type=short order=0 const=no ref=yes
[I] FUN: name=long.toshr() index=63 searchindex=30, scope={Pub:main}, scope={Pub:main}
[D] FID[63]: name=toshr kind=1 fullname=long.toshr() id=long_toshr
[D] FUN[64]: name=toint kind=MasterMth returns=int void=no nested=no msttype=long
[D] PAR[97]: function=toint name=$result type=int order=0 const=no ref=yes
[I] FUN: name=long.toint() index=64 searchindex=30, scope={Pub:main}, scope={Pub:main}
[D] FID[64]: name=toint kind=1 fullname=long.toint() id=long_toint
[D] FUN[65]: name=toflo kind=MasterMth returns=float void=no nested=no msttype=long
[D] PAR[98]: function=toflo name=$result type=float order=0 const=no ref=yes
[I] FUN: name=long.toflo() index=65 searchindex=30, scope={Pub:main}, scope={Pub:main}
[D] FID[65]: name=toflo kind=1 fullname=long.toflo() id=long_toflo
[D] FUN[66]: name=tostr kind=MasterMth returns=string void=no nested=no msttype=long
[D] PAR[99]: function=tostr name=$result type=string order=0 const=no ref=yes
[I] FUN: name=long.tostr() index=66 searchindex=33, scope={Pub:main}, scope={Pub:main}
[D] FID[66]: name=tostr kind=1 fullname=long.tostr() id=long_tostr
[D] FUN[67]: name=tobol kind=MasterMth returns=bool void=no nested=no msttype=float
[D] PAR[100]: function=tobol name=$result type=bool order=0 const=no ref=yes
[I] FUN: name=float.tobol() index=67 searchindex=22, scope={Pub:main}, scope={Pub:main}
[D] FID[67]: name=tobol kind=1 fullname=float.tobol() id=float_tobol
[D] FUN[68]: name=tochr kind=MasterMth returns=char void=no nested=no msttype=float
[D] PAR[101]: function=tochr name=$result type=char order=0 const=no ref=yes
[I] FUN: name=float.tochr() index=68 searchindex=23, scope={Pub:main}, scope={Pub:main}
[D] FID[68]: name=tochr kind=1 fullname=float.tochr() id=float_tochr
[D] FUN[69]: name=toshr kind=MasterMth returns=short void=no nested=no msttype=float
[D] PAR[102]: function=toshr name=$result type=short order=0 const=no ref=yes
[I] FUN: name=float.toshr() index=69 searchindex=24, scope={Pub:main}, scope={Pub:main}
[D] FID[69]: name=toshr kind=1 fullname=float.toshr() id=float_toshr
[D] FUN[70]: name=toint kind=MasterMth returns=int void=no nested=no msttype=float
[D] PAR[103]: function=toint name=$result type=int order=0 const=no ref=yes
[I] FUN: name=float.toint() index=70 searchindex=24, scope={Pub:main}, scope={Pub:main}
[D] FID[70]: name=toint kind=1 fullname=float.toint() id=float_toint
[D] FUN[71]: name=tolon kind=MasterMth returns=long void=no nested=no msttype=float
[D] PAR[104]: function=tolon name=$result type=long order=0 const=no ref=yes
[I] FUN: name=float.tolon() index=71 searchindex=25, scope={Pub:main}, scope={Pub:main}
[D] FID[71]: name=tolon kind=1 fullname=float.tolon() id=float_tolon
[D] FUN[72]: name=tostr kind=MasterMth returns=string void=no nested=no msttype=float
[D] PAR[105]: function=tostr name=$result type=string order=0 const=no ref=yes
[I] FUN: name=float.tostr() index=72 searchindex=27, scope={Pub:main}, scope={Pub:main}
[D] FID[72]: name=tostr kind=1 fullname=float.tostr() id=float_tostr
[D] FUN[73]: name=tobol kind=MasterMth returns=bool void=no nested=no msttype=string
[D] PAR[106]: function=tobol name=$result type=bool order=0 const=no ref=yes
[I] FUN: name=string.tobol() index=73 searchindex=71, scope={Pub:main}, scope={Pub:main}
[D] FID[73]: name=tobol kind=1 fullname=string.tobol() id=string_tobol
[D] FUN[74]: name=tochr kind=MasterMth returns=char void=no nested=no msttype=string
[D] PAR[107]: function=tochr name=$result type=char order=0 const=no ref=yes
[I] FUN: name=string.tochr() index=74 searchindex=72, scope={Pub:main}, scope={Pub:main}
[D] FID[74]: name=tochr kind=1 fullname=string.tochr() id=string_tochr
[D] FUN[75]: name=toshr kind=MasterMth returns=short void=no nested=no msttype=string
[D] PAR[108]: function=toshr name=$result type=short order=0 const=no ref=yes
[I] FUN: name=string.toshr() index=75 searchindex=73, scope={Pub:main}, scope={Pub:main}
[D] FID[75]: name=toshr kind=1 fullname=string.toshr() id=string_toshr
[D] FUN[76]: name=toint kind=MasterMth returns=int void=no nested=no msttype=string
[D] PAR[109]: function=toint name=$result type=int order=0 const=no ref=yes
[I] FUN: name=string.toint() index=76 searchindex=73, scope={Pub:main}, scope={Pub:main}
[D] FID[76]: name=toint kind=1 fullname=string.toint() id=string_toint
[D] FUN[77]: name=tolon kind=MasterMth returns=long void=no nested=no msttype=string
[D] PAR[110]: function=tolon name=$result type=long order=0 const=no ref=yes
[I] FUN: name=string.tolon() index=77 searchindex=74, scope={Pub:main}, scope={Pub:main}
[D] FID[77]: name=tolon kind=1 fullname=string.tolon() id=string_tolon
[D] FUN[78]: name=toflo kind=MasterMth returns=float void=no nested=no msttype=string
[D] PAR[111]: function=toflo name=$result type=float order=0 const=no ref=yes
[I] FUN: name=string.toflo() index=78 searchindex=73, scope={Pub:main}, scope={Pub:main}
[D] FID[78]: name=toflo kind=1 fullname=string.toflo() id=string_toflo
[D] FUN[79]: name=fieldcount kind=MasterMth returns=int void=no nested=no msttype=class
[D] PAR[112]: function=fieldcount name=$result type=string order=0 const=no ref=yes
[I] FUN: name=class.fieldcount() index=79 searchindex=14, scope={Pub:main}, scope={Pub:main}
[D] FID[79]: name=fieldcount kind=1 fullname=class.fieldcount() id=class_fieldcount
[D] FUN[80]: name=fieldnames kind=MasterMth returns=string[] void=no nested=no msttype=class
[D] PAR[113]: function=fieldnames name=$result type=string[] order=0 const=no ref=yes
[I] FUN: name=class.fieldnames() index=80 searchindex=15, scope={Pub:main}, scope={Pub:main}
[D] FID[80]: name=fieldnames kind=1 fullname=class.fieldnames() id=class_fieldnames
[D] FUN[81]: name=fieldtypes kind=MasterMth returns=string[] void=no nested=no msttype=class
[D] PAR[114]: function=fieldtypes name=$result type=string[] order=0 const=no ref=yes
[I] FUN: name=class.fieldtypes() index=81 searchindex=16, scope={Pub:main}, scope={Pub:main}
[D] FID[81]: name=fieldtypes kind=1 fullname=class.fieldtypes() id=class_fieldtypes
[D] FUN[82]: name=tochr kind=MasterMth returns=char void=no nested=no msttype=enum
[D] PAR[115]: function=tochr name=$result type=char order=0 const=no ref=yes
[I] FUN: name=enum.tochr() index=82 searchindex=24, scope={Pub:main}, scope={Pub:main}
[D] FID[82]: name=tochr kind=1 fullname=enum.tochr() id=enum_tochr
[D] FUN[83]: name=toshr kind=MasterMth returns=short void=no nested=no msttype=enum
[D] PAR[116]: function=toshr name=$result type=char order=0 const=no ref=yes
[I] FUN: name=enum.toshr() index=83 searchindex=25, scope={Pub:main}, scope={Pub:main}
[D] FID[83]: name=toshr kind=1 fullname=enum.toshr() id=enum_toshr
[D] FUN[84]: name=toint kind=MasterMth returns=int void=no nested=no msttype=enum
[D] PAR[117]: function=toint name=$result type=int order=0 const=no ref=yes
[I] FUN: name=enum.toint() index=84 searchindex=25, scope={Pub:main}, scope={Pub:main}
[D] FID[84]: name=toint kind=1 fullname=enum.toint() id=enum_toint
[D] FUN[85]: name=tolon kind=MasterMth returns=long void=no nested=no msttype=enum
[D] PAR[118]: function=tolon name=$result type=long order=0 const=no ref=yes
[I] FUN: name=enum.tolon() index=85 searchindex=26, scope={Pub:main}, scope={Pub:main}
[D] FID[85]: name=tolon kind=1 fullname=enum.tolon() id=enum_tolon
[D] FUN[86]: name=toflo kind=MasterMth returns=float void=no nested=no msttype=enum
[D] PAR[119]: function=toflo name=$result type=float order=0 const=no ref=yes
[I] FUN: name=enum.toflo() index=86 searchindex=25, scope={Pub:main}, scope={Pub:main}
[D] FID[86]: name=toflo kind=1 fullname=enum.toflo() id=enum_toflo
[D] FUN[87]: name=tostr kind=MasterMth returns=string void=no nested=no msttype=enum
[D] PAR[120]: function=tostr name=$result type=string order=0 const=no ref=yes
[I] FUN: name=enum.tostr() index=87 searchindex=29, scope={Pub:main}, scope={Pub:main}
[D] FID[87]: name=tostr kind=1 fullname=enum.tostr() id=enum_tostr
[D] FUN[88]: name=fieldcount kind=MasterMth returns=string void=no nested=no msttype=enum
[D] PAR[121]: function=fieldcount name=$result type=string order=0 const=no ref=yes
[I] FUN: name=enum.fieldcount() index=88 searchindex=24, scope={Pub:main}, scope={Pub:main}
[D] FID[88]: name=fieldcount kind=1 fullname=enum.fieldcount() id=enum_fieldcount
[D] FUN[89]: name=fieldnames kind=MasterMth returns=string[] void=no nested=no msttype=enum
[D] PAR[122]: function=fieldnames name=$result type=string[] order=0 const=no ref=yes
[I] FUN: name=enum.fieldnames() index=89 searchindex=25, scope={Pub:main}, scope={Pub:main}
[D] FID[89]: name=fieldnames kind=1 fullname=enum.fieldnames() id=enum_fieldnames
[D] FUN[90]: name=fieldtypes kind=MasterMth returns=string[] void=no nested=no msttype=enum
[D] PAR[123]: function=fieldtypes name=$result type=string[] order=0 const=no ref=yes
[I] FUN: name=enum.fieldtypes() index=90 searchindex=26, scope={Pub:main}, scope={Pub:main}
[D] FID[90]: name=fieldtypes kind=1 fullname=enum.fieldtypes() id=enum_fieldtypes
[D] FUN[91]: name=name kind=MasterMth returns=string void=no nested=no msttype=boolean
[D] PAR[124]: function=name name=$result type=string order=0 const=no ref=yes
[I] FUN: name=boolean.name() index=91 searchindex=0, scope={Pub:main}, scope={Pub:main}
[D] FID[91]: name=name kind=1 fullname=boolean.name() id=boolean_name
[D] FUN[92]: name=name kind=MasterMth returns=string void=no nested=no msttype=char
[D] PAR[125]: function=name name=$result type=string order=0 const=no ref=yes
[I] FUN: name=char.name() index=92 searchindex=8, scope={Pub:main}, scope={Pub:main}
[D] FID[92]: name=name kind=1 fullname=char.name() id=char_name
[D] FUN[93]: name=name kind=MasterMth returns=string void=no nested=no msttype=short
[D] PAR[126]: function=name name=$result type=string order=0 const=no ref=yes
[I] FUN: name=short.name() index=93 searchindex=54, scope={Pub:main}, scope={Pub:main}
[D] FID[93]: name=name kind=1 fullname=short.name() id=short_name
[D] FUN[94]: name=name kind=MasterMth returns=string void=no nested=no msttype=integer
[D] PAR[127]: function=name name=$result type=string order=0 const=no ref=yes
[I] FUN: name=integer.name() index=94 searchindex=42, scope={Pub:main}, scope={Pub:main}
[D] FID[94]: name=name kind=1 fullname=integer.name() id=integer_name
[D] FUN[95]: name=name kind=MasterMth returns=string void=no nested=no msttype=long
[D] PAR[128]: function=name name=$result type=string order=0 const=no ref=yes
[I] FUN: name=long.name() index=95 searchindex=49, scope={Pub:main}, scope={Pub:main}
[D] FID[95]: name=name kind=1 fullname=long.name() id=long_name
[D] FUN[96]: name=name kind=MasterMth returns=string void=no nested=no msttype=float
[D] PAR[129]: function=name name=$result type=string order=0 const=no ref=yes
[I] FUN: name=float.name() index=96 searchindex=36, scope={Pub:main}, scope={Pub:main}
[D] FID[96]: name=name kind=1 fullname=float.name() id=float_name
[D] FUN[97]: name=name kind=MasterMth returns=string void=no nested=no msttype=string
[D] PAR[130]: function=name name=$result type=string order=0 const=no ref=yes
[I] FUN: name=string.name() index=97 searchindex=80, scope={Pub:main}, scope={Pub:main}
[D] FID[97]: name=name kind=1 fullname=string.name() id=string_name
[D] FUN[98]: name=name kind=MasterMth returns=string void=no nested=no msttype=class
[D] PAR[131]: function=name name=$result type=string order=0 const=no ref=yes
[I] FUN: name=class.name() index=98 searchindex=19, scope={Pub:main}, scope={Pub:main}
[D] FID[98]: name=name kind=1 fullname=class.name() id=class_name
[D] FUN[99]: name=name kind=MasterMth returns=string void=no nested=no msttype=enum
[D] PAR[132]: function=name name=$result type=string order=0 const=no ref=yes
[I] FUN: name=enum.name() index=99 searchindex=30, scope={Pub:main}, scope={Pub:main}
[D] FID[99]: name=name kind=1 fullname=enum.name() id=enum_name
[D] FUN[100]: name=name kind=MasterMth returns=string void=no nested=no msttype=farray
[D] PAR[133]: function=name name=$result type=string order=0 const=no ref=yes
[I] FUN: name=farray.name() index=100 searchindex=38, scope={Pub:main}, scope={Pub:main}
[D] FID[100]: name=name kind=1 fullname=farray.name() id=farray_name
[D] FUN[101]: name=name kind=MasterMth returns=string void=no nested=no msttype=darray
[D] PAR[134]: function=name name=$result type=string order=0 const=no ref=yes
[I] FUN: name=darray.name() index=101 searchindex=21, scope={Pub:main}, scope={Pub:main}
[D] FID[101]: name=name kind=1 fullname=darray.name() id=darray_name
[D] FUN[102]: name=dtype kind=MasterMth returns=string void=no nested=no msttype=boolean
[D] PAR[135]: function=dtype name=$result type=string order=0 const=no ref=yes
[I] FUN: name=boolean.dtype() index=102 searchindex=0, scope={Pub:main}, scope={Pub:main}
[D] FID[102]: name=dtype kind=1 fullname=boolean.dtype() id=boolean_dtype
[D] FUN[103]: name=dtype kind=MasterMth returns=string void=no nested=no msttype=char
[D] PAR[136]: function=dtype name=$result type=string order=0 const=no ref=yes
[I] FUN: name=char.dtype() index=103 searchindex=8, scope={Pub:main}, scope={Pub:main}
[D] FID[103]: name=dtype kind=1 fullname=char.dtype() id=char_dtype
[D] FUN[104]: name=dtype kind=MasterMth returns=string void=no nested=no msttype=short
[D] PAR[137]: function=dtype name=$result type=string order=0 const=no ref=yes
[I] FUN: name=short.dtype() index=104 searchindex=63, scope={Pub:main}, scope={Pub:main}
[D] FID[104]: name=dtype kind=1 fullname=short.dtype() id=short_dtype
[D] FUN[105]: name=dtype kind=MasterMth returns=string void=no nested=no msttype=integer
[D] PAR[138]: function=dtype name=$result type=string order=0 const=no ref=yes
[I] FUN: name=integer.dtype() index=105 searchindex=49, scope={Pub:main}, scope={Pub:main}
[D] FID[105]: name=dtype kind=1 fullname=integer.dtype() id=integer_dtype
[D] FUN[106]: name=dtype kind=MasterMth returns=string void=no nested=no msttype=long
[D] PAR[139]: function=dtype name=$result type=string order=0 const=no ref=yes
[I] FUN: name=long.dtype() index=106 searchindex=57, scope={Pub:main}, scope={Pub:main}
[D] FID[106]: name=dtype kind=1 fullname=long.dtype() id=long_dtype
[D] FUN[107]: name=dtype kind=MasterMth returns=string void=no nested=no msttype=float
[D] PAR[140]: function=dtype name=$result type=string order=0 const=no ref=yes
[I] FUN: name=float.dtype() index=107 searchindex=42, scope={Pub:main}, scope={Pub:main}
[D] FID[107]: name=dtype kind=1 fullname=float.dtype() id=float_dtype
[D] FUN[108]: name=dtype kind=MasterMth returns=string void=no nested=no msttype=string
[D] PAR[141]: function=dtype name=$result type=string order=0 const=no ref=yes
[I] FUN: name=string.dtype() index=108 searchindex=76, scope={Pub:main}, scope={Pub:main}
[D] FID[108]: name=dtype kind=1 fullname=string.dtype() id=string_dtype
[D] FUN[109]: name=dtype kind=MasterMth returns=string void=no nested=no msttype=class
[D] PAR[142]: function=dtype name=$result type=string order=0 const=no ref=yes
[I] FUN: name=class.dtype() index=109 searchindex=18, scope={Pub:main}, scope={Pub:main}
[D] FID[109]: name=dtype kind=1 fullname=class.dtype() id=class_dtype
[D] FUN[110]: name=dtype kind=MasterMth returns=string void=no nested=no msttype=enum
[D] PAR[143]: function=dtype name=$result type=string order=0 const=no ref=yes
[I] FUN: name=enum.dtype() index=110 searchindex=31, scope={Pub:main}, scope={Pub:main}
[D] FID[110]: name=dtype kind=1 fullname=enum.dtype() id=enum_dtype
[D] FUN[111]: name=dtype kind=MasterMth returns=string void=no nested=no msttype=farray
[D] PAR[144]: function=dtype name=$result type=string order=0 const=no ref=yes
[I] FUN: name=farray.dtype() index=111 searchindex=43, scope={Pub:main}, scope={Pub:main}
[D] FID[111]: name=dtype kind=1 fullname=farray.dtype() id=farray_dtype
[D] FUN[112]: name=dtype kind=MasterMth returns=string void=no nested=no msttype=darray
[D] PAR[145]: function=dtype name=$result type=string order=0 const=no ref=yes
[I] FUN: name=darray.dtype() index=112 searchindex=24, scope={Pub:main}, scope={Pub:main}
[D] FID[112]: name=dtype kind=1 fullname=darray.dtype() id=darray_dtype
[D] FUN[113]: name=sizeof kind=MasterMth returns=word void=no nested=no msttype=boolean
[D] PAR[146]: function=sizeof name=$result type=word order=0 const=no ref=yes
[I] FUN: name=boolean.sizeof() index=113 searchindex=2, scope={Pub:main}, scope={Pub:main}
[D] FID[113]: name=sizeof kind=1 fullname=boolean.sizeof() id=boolean_sizeof
[D] FUN[114]: name=sizeof kind=MasterMth returns=word void=no nested=no msttype=char
[D] PAR[147]: function=sizeof name=$result type=word order=0 const=no ref=yes
[I] FUN: name=char.sizeof() index=114 searchindex=12, scope={Pub:main}, scope={Pub:main}
[D] FID[114]: name=sizeof kind=1 fullname=char.sizeof() id=char_sizeof
[D] FUN[115]: name=sizeof kind=MasterMth returns=word void=no nested=no msttype=short
[D] PAR[148]: function=sizeof name=$result type=word order=0 const=no ref=yes
[I] FUN: name=short.sizeof() index=115 searchindex=74, scope={Pub:main}, scope={Pub:main}
[D] FID[115]: name=sizeof kind=1 fullname=short.sizeof() id=short_sizeof
[D] FUN[116]: name=sizeof kind=MasterMth returns=word void=no nested=no msttype=integer
[D] PAR[149]: function=sizeof name=$result type=word order=0 const=no ref=yes
[I] FUN: name=integer.sizeof() index=116 searchindex=58, scope={Pub:main}, scope={Pub:main}
[D] FID[116]: name=sizeof kind=1 fullname=integer.sizeof() id=integer_sizeof
[D] FUN[117]: name=sizeof kind=MasterMth returns=word void=no nested=no msttype=long
[D] PAR[150]: function=sizeof name=$result type=word order=0 const=no ref=yes
[I] FUN: name=long.sizeof() index=117 searchindex=67, scope={Pub:main}, scope={Pub:main}
[D] FID[117]: name=sizeof kind=1 fullname=long.sizeof() id=long_sizeof
[D] FUN[118]: name=sizeof kind=MasterMth returns=word void=no nested=no msttype=float
[D] PAR[151]: function=sizeof name=$result type=word order=0 const=no ref=yes
[I] FUN: name=float.sizeof() index=118 searchindex=50, scope={Pub:main}, scope={Pub:main}
[D] FID[118]: name=sizeof kind=1 fullname=float.sizeof() id=float_sizeof
[D] FUN[119]: name=sizeof kind=MasterMth returns=word void=no nested=no msttype=string
[D] PAR[152]: function=sizeof name=$result type=word order=0 const=no ref=yes
[I] FUN: name=string.sizeof() index=119 searchindex=108, scope={Pub:main}, scope={Pub:main}
[D] FID[119]: name=sizeof kind=1 fullname=string.sizeof() id=string_sizeof
[D] FUN[120]: name=sizeof kind=MasterMth returns=word void=no nested=no msttype=enum
[D] PAR[153]: function=sizeof name=$result type=word order=0 const=no ref=yes
[I] FUN: name=enum.sizeof() index=120 searchindex=39, scope={Pub:main}, scope={Pub:main}
[D] FID[120]: name=sizeof kind=1 fullname=enum.sizeof() id=enum_sizeof
[D] FUN[121]: name=sizeof kind=MasterMth returns=word void=no nested=no msttype=farray
[D] PAR[154]: function=sizeof name=$result type=word order=0 const=no ref=yes
[I] FUN: name=farray.sizeof() index=121 searchindex=49, scope={Pub:main}, scope={Pub:main}
[D] FID[121]: name=sizeof kind=1 fullname=farray.sizeof() id=farray_sizeof
[D] FUN[122]: name=sizeof kind=MasterMth returns=word void=no nested=no msttype=darray
[D] PAR[155]: function=sizeof name=$result type=word order=0 const=no ref=yes
[I] FUN: name=darray.sizeof() index=122 searchindex=34, scope={Pub:main}, scope={Pub:main}
[D] FID[122]: name=sizeof kind=1 fullname=darray.sizeof() id=darray_sizeof
[D] FUN[123]: name=tobytes kind=MasterMth returns=char[] void=no nested=no msttype=boolean
[D] PAR[156]: function=tobytes name=$result type=char[] order=0 const=no ref=yes
[I] FUN: name=boolean.tobytes() index=123 searchindex=3, scope={Pub:main}, scope={Pub:main}
[D] FID[123]: name=tobytes kind=1 fullname=boolean.tobytes() id=boolean_tobytes
[D] FUN[124]: name=tobytes kind=MasterMth returns=char[] void=no nested=no msttype=char
[D] PAR[157]: function=tobytes name=$result type=char[] order=0 const=no ref=yes
[I] FUN: name=char.tobytes() index=124 searchindex=15, scope={Pub:main}, scope={Pub:main}
[D] FID[124]: name=tobytes kind=1 fullname=char.tobytes() id=char_tobytes
[D] FUN[125]: name=tobytes kind=MasterMth returns=char[] void=no nested=no msttype=short
[D] PAR[158]: function=tobytes name=$result type=char[] order=0 const=no ref=yes
[I] FUN: name=short.tobytes() index=125 searchindex=84, scope={Pub:main}, scope={Pub:main}
[D] FID[125]: name=tobytes kind=1 fullname=short.tobytes() id=short_tobytes
[D] FUN[126]: name=tobytes kind=MasterMth returns=char[] void=no nested=no msttype=integer
[D] PAR[159]: function=tobytes name=$result type=char[] order=0 const=no ref=yes
[I] FUN: name=integer.tobytes() index=126 searchindex=66, scope={Pub:main}, scope={Pub:main}
[D] FID[126]: name=tobytes kind=1 fullname=integer.tobytes() id=integer_tobytes
[D] FUN[127]: name=tobytes kind=MasterMth returns=char[] void=no nested=no msttype=long
[D] PAR[160]: function=tobytes name=$result type=char[] order=0 const=no ref=yes
[I] FUN: name=long.tobytes() index=127 searchindex=76, scope={Pub:main}, scope={Pub:main}
[D] FID[127]: name=tobytes kind=1 fullname=long.tobytes() id=long_tobytes
[D] FUN[128]: name=tobytes kind=MasterMth returns=char[] void=no nested=no msttype=float
[D] PAR[161]: function=tobytes name=$result type=char[] order=0 const=no ref=yes
[I] FUN: name=float.tobytes() index=128 searchindex=57, scope={Pub:main}, scope={Pub:main}
[D] FID[128]: name=tobytes kind=1 fullname=float.tobytes() id=float_tobytes
[D] FUN[129]: name=tobytes kind=MasterMth returns=char[] void=no nested=no msttype=string
[D] PAR[162]: function=tobytes name=$result type=char[] order=0 const=no ref=yes
[I] FUN: name=string.tobytes() index=129 searchindex=122, scope={Pub:main}, scope={Pub:main}
[D] FID[129]: name=tobytes kind=1 fullname=string.tobytes() id=string_tobytes
[D] FUN[130]: name=tobytes kind=MasterMth returns=char[] void=no nested=no msttype=class
[D] PAR[163]: function=tobytes name=$result type=char[] order=0 const=no ref=yes
[I] FUN: name=class.tobytes() index=130 searchindex=27, scope={Pub:main}, scope={Pub:main}
[D] FID[130]: name=tobytes kind=1 fullname=class.tobytes() id=class_tobytes
[D] FUN[131]: name=tobytes kind=MasterMth returns=char[] void=no nested=no msttype=enum
[D] PAR[164]: function=tobytes name=$result type=char[] order=0 const=no ref=yes
[I] FUN: name=enum.tobytes() index=131 searchindex=44, scope={Pub:main}, scope={Pub:main}
[D] FID[131]: name=tobytes kind=1 fullname=enum.tobytes() id=enum_tobytes
[D] FUN[132]: name=tobytes kind=MasterMth returns=char[] void=no nested=no msttype=farray
[D] PAR[165]: function=tobytes name=$result type=char[] order=0 const=no ref=yes
[I] FUN: name=farray.tobytes() index=132 searchindex=55, scope={Pub:main}, scope={Pub:main}
[D] FID[132]: name=tobytes kind=1 fullname=farray.tobytes() id=farray_tobytes
[D] FUN[133]: name=tobytes kind=MasterMth returns=char[] void=no nested=no msttype=darray
[D] PAR[166]: function=tobytes name=$result type=char[] order=0 const=no ref=yes
[I] FUN: name=darray.tobytes() index=133 searchindex=38, scope={Pub:main}, scope={Pub:main}
[D] FID[133]: name=tobytes kind=1 fullname=darray.tobytes() id=darray_tobytes
[D] FUN[134]: name=frombytes kind=MasterMth returns=bool void=no nested=no msttype=boolean
[D] PAR[167]: function=frombytes name=$result type=bool order=0 const=no ref=yes
[D] PAR[168]: function=frombytes name=bytes type=string[] order=1 const=yes ref=yes
[I] FUN: name=boolean.frombytes(string[]) index=134 searchindex=1, scope={Pub:main}, scope={Pub:main}
[D] FID[134]: name=frombytes kind=1 fullname=boolean.frombytes(string[]) id=boolean_frombytes
[D] FUN[135]: name=frombytes kind=MasterMth returns=char void=no nested=no msttype=char
[D] PAR[169]: function=frombytes name=$result type=char order=0 const=no ref=yes
[D] PAR[170]: function=frombytes name=bytes type=string[] order=1 const=yes ref=yes
[I] FUN: name=char.frombytes(string[]) index=135 searchindex=12, scope={Pub:main}, scope={Pub:main}
[D] FID[135]: name=frombytes kind=1 fullname=char.frombytes(string[]) id=char_frombytes
[D] FUN[136]: name=frombytes kind=MasterMth returns=short void=no nested=no msttype=short
[D] PAR[171]: function=frombytes name=$result type=short order=0 const=no ref=yes
[D] PAR[172]: function=frombytes name=bytes type=string[] order=1 const=yes ref=yes
[I] FUN: name=short.frombytes(string[]) index=136 searchindex=90, scope={Pub:main}, scope={Pub:main}
[D] FID[136]: name=frombytes kind=1 fullname=short.frombytes(string[]) id=short_frombytes
[D] FUN[137]: name=frombytes kind=MasterMth returns=int void=no nested=no msttype=integer
[D] PAR[173]: function=frombytes name=$result type=int order=0 const=no ref=yes
[D] PAR[174]: function=frombytes name=bytes type=string[] order=1 const=yes ref=yes
[I] FUN: name=integer.frombytes(string[]) index=137 searchindex=70, scope={Pub:main}, scope={Pub:main}
[D] FID[137]: name=frombytes kind=1 fullname=integer.frombytes(string[]) id=integer_frombytes
[D] FUN[138]: name=frombytes kind=MasterMth returns=long void=no nested=no msttype=long
[D] PAR[175]: function=frombytes name=$result type=long order=0 const=no ref=yes
[D] PAR[176]: function=frombytes name=bytes type=string[] order=1 const=yes ref=yes
[I] FUN: name=long.frombytes(string[]) index=138 searchindex=81, scope={Pub:main}, scope={Pub:main}
[D] FID[138]: name=frombytes kind=1 fullname=long.frombytes(string[]) id=long_frombytes
[D] FUN[139]: name=frombytes kind=MasterMth returns=float void=no nested=no msttype=float
[D] PAR[177]: function=frombytes name=$result type=float order=0 const=no ref=yes
[D] PAR[178]: function=frombytes name=bytes type=string[] order=1 const=yes ref=yes
[I] FUN: name=float.frombytes(string[]) index=139 searchindex=60, scope={Pub:main}, scope={Pub:main}
[D] FID[139]: name=frombytes kind=1 fullname=float.frombytes(string[]) id=float_frombytes
[D] FUN[140]: name=frombytes kind=MasterMth returns=string void=no nested=no msttype=string
[D] PAR[179]: function=frombytes name=$result type=string order=0 const=no ref=yes
[D] PAR[180]: function=frombytes name=bytes type=string[] order=1 const=yes ref=yes
[I] FUN: name=string.frombytes(string[]) index=140 searchindex=107, scope={Pub:main}, scope={Pub:main}
[D] FID[140]: name=frombytes kind=1 fullname=string.frombytes(string[]) id=string_frombytes
[D] FUN[141]: name=frombytes kind=MasterMth returns=undefined void=no nested=no msttype=class
[D] PAR[181]: function=frombytes name=$result type=undefined order=0 const=no ref=yes
[D] PAR[182]: function=frombytes name=bytes type=string[] order=1 const=yes ref=yes
[I] FUN: name=class.frombytes(string[]) index=141 searchindex=28, scope={Pub:main}, scope={Pub:main}
[D] FID[141]: name=frombytes kind=1 fullname=class.frombytes(string[]) id=class_frombytes
[D] FUN[142]: name=frombytes kind=MasterMth returns=undefined void=no nested=no msttype=enum
[D] PAR[183]: function=frombytes name=$result type=undefined order=0 const=no ref=yes
[D] PAR[184]: function=frombytes name=bytes type=string[] order=1 const=yes ref=yes
[I] FUN: name=enum.frombytes(string[]) index=142 searchindex=46, scope={Pub:main}, scope={Pub:main}
[D] FID[142]: name=frombytes kind=1 fullname=enum.frombytes(string[]) id=enum_frombytes
[D] FUN[143]: name=frombytes kind=MasterMth returns=undefined void=no nested=no msttype=farray
[D] PAR[185]: function=frombytes name=$result type=undefined order=0 const=no ref=yes
[D] PAR[186]: function=frombytes name=bytes type=string[] order=1 const=yes ref=yes
[I] FUN: name=farray.frombytes(string[]) index=143 searchindex=58, scope={Pub:main}, scope={Pub:main}
[D] FID[143]: name=frombytes kind=1 fullname=farray.frombytes(string[]) id=farray_frombytes
[D] FUN[144]: name=frombytes kind=MasterMth returns=undefined void=no nested=no msttype=darray
[D] PAR[187]: function=frombytes name=$result type=undefined order=0 const=no ref=yes
[D] PAR[188]: function=frombytes name=bytes type=string[] order=1 const=yes ref=yes
[I] FUN: name=darray.frombytes(string[]) index=144 searchindex=33, scope={Pub:main}, scope={Pub:main}
[D] FID[144]: name=frombytes kind=1 fullname=darray.frombytes(string[]) id=darray_frombytes
[N] Init address was reset
[A] HEAD: ;---------------------------------------------------------------------------------------------------
[A] HEAD: ; Dungeon Spells 64bit (v0.773) assembler file
[A] HEAD: ; Source file.....: src\lib\standard.ds
[A] HEAD: ; Output file.....: src\lib\standard.dlb
[A] HEAD: ; Compiler output.: Library file
[A] HEAD: ;---------------------------------------------------------------------------------------------------
[A] CODE: ;---------------------------------------------------------------------------------------------------
[A] CODE: ; Initializations
[A] CODE: ;---------------------------------------------------------------------------------------------------
[A] CODE:                                     NOP                                                             ;[0000000000000000h] 0137
[P] Updated parser type list: bool,char,float,int,long,short,string,word
[P] -------------------------------------------------------------------------------------
[L] Read line (src):2:16: "set library=true"
[P] Parsed sentence: [Set] kw(set) id(library) op(=) bo(true)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):5:7: ".public"
[P] Parsed sentence: [Public] kw(.public)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[N] Opened init routine for module standard at address 0000000000000002h
[A] CODE: 
[A] CODE: ($initstandard)                     FUNCTION
[P] -------------------------------------------------------------------------------------
[L] Read line (src):8:30: "const string std_version="0.1""
[P] Parsed sentence: [Const] kw(const) ty(string) id(std_version) op(=) st("0.1")
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;const string std_version="0.1"
[O] Relocation added: Type=BlkInsideGlo, LocAdr=0000000000000034h
[A] DATA:                                     STORE "std_version"                                             ;Address=[0000000000000034h]
[Y] Store OVAR[0]: name=std_version FunIndex=-1 TypIndex=6 Address=56 IsConst=1
[D] VAR[2]: name=std_version type=string scope={Pub:main} address=56 const=yes static=no parameter=no ref=no temp=no buffstore=yes length=4
[I] VAR: name=standard.std_version index=2 searchindex=2, scope={Pub:main}
[A] CODE: 
[A] CODE:                                     ;const string std_version="0.1"
[E] ExprCompiler input: [Const] st("0.1")
[E] Release all temp variables
[O] Relocation added: Type=BlkInsideGlo, LocAdr=000000000000003Ch
[A] DATA:                                     STORE "0.1"                                                     ;Address=[000000000000003Ch]
[E] Tokenizer ouput: {K}Str:60
[E] RPN ouput: {K}Str:60
[E] .......... Processing token {K}Str:60 ..........
[E] Token {K}Str:60 --> Operand stack {{K}Str:60}
[E] Result token: {K}Str:60
[O] Relocation added: Type=GlobVarvAddr, LocAdr=0000000000000005h
[O] Relocation added: Type=GlobVarvAddr, LocAdr=000000000000000Dh
[A] CODE:                                     SCOPY [std_version],[STR(000000000000003Ch)]                    ;[0000000000000002h] 00B1 00 8000000000000038 800000000000003C
[A] DECL: [std_version]                       VAR CONST STRINGBLOCK                                           ;Address=[0000000000000038h] = [STR(000000000000003Ch)] { const string std_version="0.1" }
[P] -------------------------------------------------------------------------------------
[L] Read line (src):11:33: "const float e  =2.718281828459045"
[P] Parsed sentence: [Const] kw(const) ty(float) id(e) op(=) fl(2.718282)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;const float e  =2.718281828459045
[O] Relocation added: Type=BlkInsideGlo, LocAdr=0000000000000040h
[A] DATA:                                     STORE "e"                                                       ;Address=[0000000000000040h]
[Y] Store OVAR[1]: name=e FunIndex=-1 TypIndex=5 Address=68 IsConst=1
[D] VAR[3]: name=e type=float scope={Pub:main} address=68 const=yes static=no parameter=no ref=no temp=no buffstore=yes length=8
[I] VAR: name=standard.e index=3 searchindex=2, scope={Pub:main}
[A] CODE: 
[A] CODE:                                     ;const float e  =2.718281828459045
[E] ExprCompiler input: [Const] fl(2.718282)
[E] Release all temp variables
[E] Tokenizer ouput: {K}2.718282F
[E] RPN ouput: {K}2.718282F
[E] Expression is computed, not compiled
[E] Token {K}2.718282F --> Operand stack {{K}2.718282F}
[E] Result token: {K}2.718282F
[A] CODE: DELETED -->                                     ;const float e  =2.718281828459045
[A] CODE: DELETED --> 
[A] DECL: [e]                                 VAR CONST FLOAT                                                 ;Address=[0000000000000044h] = (F)2.718282 { const float e  =2.718281828459045 }
[P] -------------------------------------------------------------------------------------
[L] Read line (src):12:33: "const float pi =3.141592653589793"
[P] Parsed sentence: [Const] kw(const) ty(float) id(pi) op(=) fl(3.141593)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;const float pi =3.141592653589793
[O] Relocation added: Type=BlkInsideGlo, LocAdr=000000000000004Ch
[A] DATA:                                     STORE "pi"                                                      ;Address=[000000000000004Ch]
[Y] Store OVAR[2]: name=pi FunIndex=-1 TypIndex=5 Address=80 IsConst=1
[D] VAR[4]: name=pi type=float scope={Pub:main} address=80 const=yes static=no parameter=no ref=no temp=no buffstore=yes length=8
[I] VAR: name=standard.pi index=4 searchindex=3, scope={Pub:main}
[A] CODE: 
[A] CODE:                                     ;const float pi =3.141592653589793
[E] ExprCompiler input: [Const] fl(3.141593)
[E] Release all temp variables
[E] Tokenizer ouput: {K}3.141593F
[E] RPN ouput: {K}3.141593F
[E] Expression is computed, not compiled
[E] Token {K}3.141593F --> Operand stack {{K}3.141593F}
[E] Result token: {K}3.141593F
[A] CODE: DELETED -->                                     ;const float pi =3.141592653589793
[A] CODE: DELETED --> 
[A] DECL: [pi]                                VAR CONST FLOAT                                                 ;Address=[0000000000000050h] = (F)3.141593 { const float pi =3.141592653589793 }
[P] -------------------------------------------------------------------------------------
[L] Read line (src):13:33: "const float phi=1.618033988749895"
[P] Parsed sentence: [Const] kw(const) ty(float) id(phi) op(=) fl(1.618034)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;const float phi=1.618033988749895
[O] Relocation added: Type=BlkInsideGlo, LocAdr=0000000000000058h
[A] DATA:                                     STORE "phi"                                                     ;Address=[0000000000000058h]
[Y] Store OVAR[3]: name=phi FunIndex=-1 TypIndex=5 Address=92 IsConst=1
[D] VAR[5]: name=phi type=float scope={Pub:main} address=92 const=yes static=no parameter=no ref=no temp=no buffstore=yes length=8
[I] VAR: name=standard.phi index=5 searchindex=3, scope={Pub:main}
[A] CODE: 
[A] CODE:                                     ;const float phi=1.618033988749895
[E] ExprCompiler input: [Const] fl(1.618034)
[E] Release all temp variables
[E] Tokenizer ouput: {K}1.618034F
[E] RPN ouput: {K}1.618034F
[E] Expression is computed, not compiled
[E] Token {K}1.618034F --> Operand stack {{K}1.618034F}
[E] Result token: {K}1.618034F
[A] CODE: DELETED -->                                     ;const float phi=1.618033988749895
[A] CODE: DELETED --> 
[A] DECL: [phi]                               VAR CONST FLOAT                                                 ;Address=[000000000000005Ch] = (F)1.618034 { const float phi=1.618033988749895 }
[P] -------------------------------------------------------------------------------------
[L] Read line (src):16:42: "const long NSECS_IN_HOUR=3600L*1000000000L"
[P] Parsed sentence: [Const] kw(const) ty(long) id(NSECS_IN_HOUR) op(=) lo(3600L) op(*) lo(1000000000L)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;const long NSECS_IN_HOUR=3600L*1000000000L
[O] Relocation added: Type=BlkInsideGlo, LocAdr=0000000000000064h
[A] DATA:                                     STORE "NSECS_IN_HOUR"                                           ;Address=[0000000000000064h]
[Y] Store OVAR[4]: name=NSECS_IN_HOUR FunIndex=-1 TypIndex=4 Address=104 IsConst=1
[D] VAR[6]: name=NSECS_IN_HOUR type=long scope={Pub:main} address=104 const=yes static=no parameter=no ref=no temp=no buffstore=yes length=8
[I] VAR: name=standard.NSECS_IN_HOUR index=6 searchindex=0, scope={Pub:main}
[A] CODE: 
[A] CODE:                                     ;const long NSECS_IN_HOUR=3600L*1000000000L
[E] ExprCompiler input: [Const] lo(3600L) op(*) lo(1000000000L)
[E] Release all temp variables
[E] Tokenizer ouput: {K}3600L opr* {K}1000000000L
[E] RPN ouput: {K}3600L {K}1000000000L opr*
[E] Expression is computed, not compiled
[E] Token {K}3600L --> Operand stack {{K}3600L}
[E] Token {K}1000000000L --> Operand stack {{K}3600L {K}1000000000L}
[E] Token opr* --> Operand stack {{K}3600000000000L}
[E] Result token: {K}3600000000000L
[A] CODE: DELETED -->                                     ;const long NSECS_IN_HOUR=3600L*1000000000L
[A] CODE: DELETED --> 
[A] DECL: [NSECS_IN_HOUR]                     VAR CONST LONG                                                  ;Address=[0000000000000068h] = (L)3600000000000 { const long NSECS_IN_HOUR=3600L*1000000000L }
[P] -------------------------------------------------------------------------------------
[L] Read line (src):17:42: "const long NSECS_IN_MINUTE=60L*1000000000L"
[P] Parsed sentence: [Const] kw(const) ty(long) id(NSECS_IN_MINUTE) op(=) lo(60L) op(*) lo(1000000000L)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;const long NSECS_IN_MINUTE=60L*1000000000L
[O] Relocation added: Type=BlkInsideGlo, LocAdr=0000000000000070h
[A] DATA:                                     STORE "NSECS_IN_MINUTE"                                         ;Address=[0000000000000070h]
[Y] Store OVAR[5]: name=NSECS_IN_MINUTE FunIndex=-1 TypIndex=4 Address=116 IsConst=1
[D] VAR[7]: name=NSECS_IN_MINUTE type=long scope={Pub:main} address=116 const=yes static=no parameter=no ref=no temp=no buffstore=yes length=8
[I] VAR: name=standard.NSECS_IN_MINUTE index=7 searchindex=1, scope={Pub:main}
[A] CODE: 
[A] CODE:                                     ;const long NSECS_IN_MINUTE=60L*1000000000L
[E] ExprCompiler input: [Const] lo(60L) op(*) lo(1000000000L)
[E] Release all temp variables
[E] Tokenizer ouput: {K}60L opr* {K}1000000000L
[E] RPN ouput: {K}60L {K}1000000000L opr*
[E] Expression is computed, not compiled
[E] Token {K}60L --> Operand stack {{K}60L}
[E] Token {K}1000000000L --> Operand stack {{K}60L {K}1000000000L}
[E] Token opr* --> Operand stack {{K}60000000000L}
[E] Result token: {K}60000000000L
[A] CODE: DELETED -->                                     ;const long NSECS_IN_MINUTE=60L*1000000000L
[A] CODE: DELETED --> 
[A] DECL: [NSECS_IN_MINUTE]                   VAR CONST LONG                                                  ;Address=[0000000000000074h] = (L)60000000000 { const long NSECS_IN_MINUTE=60L*1000000000L }
[P] -------------------------------------------------------------------------------------
[L] Read line (src):18:38: "const long NSECS_IN_SECOND=1000000000L"
[P] Parsed sentence: [Const] kw(const) ty(long) id(NSECS_IN_SECOND) op(=) lo(1000000000L)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;const long NSECS_IN_SECOND=1000000000L
[O] Relocation added: Type=BlkInsideGlo, LocAdr=000000000000007Ch
[A] DATA:                                     STORE "NSECS_IN_SECOND"                                         ;Address=[000000000000007Ch]
[Y] Store OVAR[6]: name=NSECS_IN_SECOND FunIndex=-1 TypIndex=4 Address=128 IsConst=1
[D] VAR[8]: name=NSECS_IN_SECOND type=long scope={Pub:main} address=128 const=yes static=no parameter=no ref=no temp=no buffstore=yes length=8
[I] VAR: name=standard.NSECS_IN_SECOND index=8 searchindex=2, scope={Pub:main}
[A] CODE: 
[A] CODE:                                     ;const long NSECS_IN_SECOND=1000000000L
[E] ExprCompiler input: [Const] lo(1000000000L)
[E] Release all temp variables
[E] Tokenizer ouput: {K}1000000000L
[E] RPN ouput: {K}1000000000L
[E] Expression is computed, not compiled
[E] Token {K}1000000000L --> Operand stack {{K}1000000000L}
[E] Result token: {K}1000000000L
[A] CODE: DELETED -->                                     ;const long NSECS_IN_SECOND=1000000000L
[A] CODE: DELETED --> 
[A] DECL: [NSECS_IN_SECOND]                   VAR CONST LONG                                                  ;Address=[0000000000000080h] = (L)1000000000 { const long NSECS_IN_SECOND=1000000000L }
[P] -------------------------------------------------------------------------------------
[L] Read line (src):19:45: "const long NSECS_IN_DAY=24L*3600L*1000000000L"
[P] Parsed sentence: [Const] kw(const) ty(long) id(NSECS_IN_DAY) op(=) lo(24L) op(*) lo(3600L) op(*) lo(1000000000L)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;const long NSECS_IN_DAY=24L*3600L*1000000000L
[O] Relocation added: Type=BlkInsideGlo, LocAdr=0000000000000088h
[A] DATA:                                     STORE "NSECS_IN_DAY"                                            ;Address=[0000000000000088h]
[Y] Store OVAR[7]: name=NSECS_IN_DAY FunIndex=-1 TypIndex=4 Address=140 IsConst=1
[D] VAR[9]: name=NSECS_IN_DAY type=long scope={Pub:main} address=140 const=yes static=no parameter=no ref=no temp=no buffstore=yes length=8
[I] VAR: name=standard.NSECS_IN_DAY index=9 searchindex=0, scope={Pub:main}
[A] CODE: 
[A] CODE:                                     ;const long NSECS_IN_DAY=24L*3600L*1000000000L
[E] ExprCompiler input: [Const] lo(24L) op(*) lo(3600L) op(*) lo(1000000000L)
[E] Release all temp variables
[E] Tokenizer ouput: {K}24L opr* {K}3600L opr* {K}1000000000L
[E] RPN ouput: {K}24L {K}3600L opr* {K}1000000000L opr*
[E] Expression is computed, not compiled
[E] Token {K}24L --> Operand stack {{K}24L}
[E] Token {K}3600L --> Operand stack {{K}24L {K}3600L}
[E] Token opr* --> Operand stack {{K}86400L}
[E] Token {K}1000000000L --> Operand stack {{K}86400L {K}1000000000L}
[E] Token opr* --> Operand stack {{K}86400000000000L}
[E] Result token: {K}86400000000000L
[A] CODE: DELETED -->                                     ;const long NSECS_IN_DAY=24L*3600L*1000000000L
[A] CODE: DELETED --> 
[A] DECL: [NSECS_IN_DAY]                      VAR CONST LONG                                                  ;Address=[000000000000008Ch] = (L)86400000000000 { const long NSECS_IN_DAY=24L*3600L*1000000000L }
[P] -------------------------------------------------------------------------------------
[L] Read line (src):22:13: "enum hostsys:"
[P] Parsed sentence: [DefEnum] kw(enum) id(hostsys) pu(:)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[O] Relocation added: Type=BlkInsideGlo, LocAdr=0000000000000094h
[A] DATA:                                     STORE "hostsys"                                                 ;Address=[0000000000000094h]
[Y] Store OTYP[10]: name=hostsys msttype=7 FunIndex=-1 SupTypIndex=-1 IsTypedef=0 IsSystemDef=0 Length=4 DimNr=0 ElemTypIndex=-1 DimIndex=-1 FieldLow=-1 FieldHigh=-1
[D] TYP[10]: name=hostsys msttype=enum scope={Pub:main} typedef=no systemdef=no length=4
[I] TYP: name=standard.hostsys index=10 searchindex=4, scope={Pub:main}
[S] Subscope begin: {Pub:hostsys}
[P] Updated parser type list: bool,char,float,hostsys,int,long,short,string,word
[P] -------------------------------------------------------------------------------------
[L] Read line (src):23:7: "  linux"
[P] Parsed sentence: [EnumField] id(linux)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[Y] Store OFLD[0]: name=linux SupTypIndex=10 SubScope=1 TypIndex=3 Offset=0 IsStatic=0 EnumValue=0
[D] FLD[0]: type=int name=linux subscope={Pub:hostsys} offset=0 static=no enumvalue=0
[P] -------------------------------------------------------------------------------------
[L] Read line (src):24:9: "  windows"
[P] Parsed sentence: [EnumField] id(windows)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[Y] Store OFLD[1]: name=windows SupTypIndex=10 SubScope=1 TypIndex=3 Offset=4 IsStatic=0 EnumValue=1
[D] FLD[1]: type=int name=windows subscope={Pub:hostsys} offset=4 static=no enumvalue=1
[P] -------------------------------------------------------------------------------------
[L] Read line (src):25:5: ":enum"
[P] Parsed sentence: [EndEnum] kw(:enum)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000000h, LocBlk=00000018h
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000004h, LocBlk=00000018h
[O] Relocation added: Type=BlkInsideGlo, LocAdr=0000000000000098h
[A] DATA:                                     STORE {"linux"                                                  ;Address=[0000000000000098h]
[A] DATA:                                     STORE  "windows"}
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000000h, LocBlk=0000001Bh
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000004h, LocBlk=0000001Bh
[O] Relocation added: Type=BlkInsideGlo, LocAdr=000000000000009Ch
[A] DATA:                                     STORE {"int"                                                    ;Address=[000000000000009Ch]
[A] DATA:                                     STORE  "int"}
[Y] Update OTYP[10]: MetaStNames=152 MetaStTypes=156 Length=4 FieldLow=0 FieldHigh=1
[S] Subscope end: {Pub:hostsys}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):28:14: "enum filemode:"
[P] Parsed sentence: [DefEnum] kw(enum) id(filemode) pu(:)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[O] Relocation added: Type=BlkInsideGlo, LocAdr=00000000000000A0h
[A] DATA:                                     STORE "filemode"                                                ;Address=[00000000000000A0h]
[Y] Store OTYP[11]: name=filemode msttype=7 FunIndex=-1 SupTypIndex=-1 IsTypedef=0 IsSystemDef=0 Length=4 DimNr=0 ElemTypIndex=-1 DimIndex=-1 FieldLow=-1 FieldHigh=-1
[D] TYP[11]: name=filemode msttype=enum scope={Pub:main} typedef=no systemdef=no length=4
[I] TYP: name=standard.filemode index=11 searchindex=3, scope={Pub:main}
[S] Subscope begin: {Pub:filemode}
[P] Updated parser type list: bool,char,filemode,float,hostsys,int,long,short,string,word
[P] -------------------------------------------------------------------------------------
[L] Read line (src):29:6: "  text"
[P] Parsed sentence: [EnumField] id(text)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[Y] Store OFLD[2]: name=text SupTypIndex=11 SubScope=1 TypIndex=3 Offset=0 IsStatic=0 EnumValue=0
[D] FLD[2]: type=int name=text subscope={Pub:filemode} offset=0 static=no enumvalue=0
[P] -------------------------------------------------------------------------------------
[L] Read line (src):30:8: "  binary"
[P] Parsed sentence: [EnumField] id(binary)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[Y] Store OFLD[3]: name=binary SupTypIndex=11 SubScope=1 TypIndex=3 Offset=4 IsStatic=0 EnumValue=1
[D] FLD[3]: type=int name=binary subscope={Pub:filemode} offset=4 static=no enumvalue=1
[P] -------------------------------------------------------------------------------------
[L] Read line (src):31:5: ":enum"
[P] Parsed sentence: [EndEnum] kw(:enum)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000000h, LocBlk=0000001Fh
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000004h, LocBlk=0000001Fh
[O] Relocation added: Type=BlkInsideGlo, LocAdr=00000000000000A4h
[A] DATA:                                     STORE {"text"                                                   ;Address=[00000000000000A4h]
[A] DATA:                                     STORE  "binary"}
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000000h, LocBlk=00000022h
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000004h, LocBlk=00000022h
[O] Relocation added: Type=BlkInsideGlo, LocAdr=00000000000000A8h
[A] DATA:                                     STORE {"int"                                                    ;Address=[00000000000000A8h]
[A] DATA:                                     STORE  "int"}
[Y] Update OTYP[11]: MetaStNames=164 MetaStTypes=168 Length=4 FieldLow=2 FieldHigh=3
[S] Subscope end: {Pub:filemode}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):34:15: "enum errorcode:"
[P] Parsed sentence: [DefEnum] kw(enum) id(errorcode) pu(:)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[O] Relocation added: Type=BlkInsideGlo, LocAdr=00000000000000ACh
[A] DATA:                                     STORE "errorcode"                                               ;Address=[00000000000000ACh]
[Y] Store OTYP[12]: name=errorcode msttype=7 FunIndex=-1 SupTypIndex=-1 IsTypedef=0 IsSystemDef=0 Length=4 DimNr=0 ElemTypIndex=-1 DimIndex=-1 FieldLow=-1 FieldHigh=-1
[D] TYP[12]: name=errorcode msttype=enum scope={Pub:main} typedef=no systemdef=no length=4
[I] TYP: name=standard.errorcode index=12 searchindex=3, scope={Pub:main}
[S] Subscope begin: {Pub:errorcode}
[P] Updated parser type list: bool,char,errorcode,filemode,float,hostsys,int,long,short,string,word
[P] -------------------------------------------------------------------------------------
[L] Read line (src):35:6: "  ok=0"
[P] Parsed sentence: [EnumField] id(ok) op(=) ch(0R)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[E] ExprComputer input: [EnumField] ch(0R)
[E] Tokenizer ouput: {K}0C
[E] RPN ouput: {K}0C
[E] Token {K}0C --> Operand stack {{K}0C}
[E] Result token: {K}0C
[Y] Store OFLD[4]: name=ok SupTypIndex=12 SubScope=1 TypIndex=3 Offset=0 IsStatic=0 EnumValue=0
[D] FLD[4]: type=int name=ok subscope={Pub:errorcode} offset=0 static=no enumvalue=0
[P] -------------------------------------------------------------------------------------
[L] Read line (src):36:15: "  openreaderror"
[P] Parsed sentence: [EnumField] id(openreaderror)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[Y] Store OFLD[5]: name=openreaderror SupTypIndex=12 SubScope=1 TypIndex=3 Offset=4 IsStatic=0 EnumValue=1
[D] FLD[5]: type=int name=openreaderror subscope={Pub:errorcode} offset=4 static=no enumvalue=1
[P] -------------------------------------------------------------------------------------
[L] Read line (src):37:16: "  openwriteerror"
[P] Parsed sentence: [EnumField] id(openwriteerror)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[Y] Store OFLD[6]: name=openwriteerror SupTypIndex=12 SubScope=1 TypIndex=3 Offset=8 IsStatic=0 EnumValue=2
[D] FLD[6]: type=int name=openwriteerror subscope={Pub:errorcode} offset=8 static=no enumvalue=2
[P] -------------------------------------------------------------------------------------
[L] Read line (src):38:11: "  readerror"
[P] Parsed sentence: [EnumField] id(readerror)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[Y] Store OFLD[7]: name=readerror SupTypIndex=12 SubScope=1 TypIndex=3 Offset=12 IsStatic=0 EnumValue=3
[D] FLD[7]: type=int name=readerror subscope={Pub:errorcode} offset=12 static=no enumvalue=3
[P] -------------------------------------------------------------------------------------
[L] Read line (src):39:12: "  writeerror"
[P] Parsed sentence: [EnumField] id(writeerror)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[Y] Store OFLD[8]: name=writeerror SupTypIndex=12 SubScope=1 TypIndex=3 Offset=16 IsStatic=0 EnumValue=4
[D] FLD[8]: type=int name=writeerror subscope={Pub:errorcode} offset=16 static=no enumvalue=4
[P] -------------------------------------------------------------------------------------
[L] Read line (src):40:14: "  getsizeerror"
[P] Parsed sentence: [EnumField] id(getsizeerror)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[Y] Store OFLD[9]: name=getsizeerror SupTypIndex=12 SubScope=1 TypIndex=3 Offset=20 IsStatic=0 EnumValue=5
[D] FLD[9]: type=int name=getsizeerror subscope={Pub:errorcode} offset=20 static=no enumvalue=5
[P] -------------------------------------------------------------------------------------
[L] Read line (src):41:16: "  readwhenclosed"
[P] Parsed sentence: [EnumField] id(readwhenclosed)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[Y] Store OFLD[10]: name=readwhenclosed SupTypIndex=12 SubScope=1 TypIndex=3 Offset=24 IsStatic=0 EnumValue=6
[D] FLD[10]: type=int name=readwhenclosed subscope={Pub:errorcode} offset=24 static=no enumvalue=6
[P] -------------------------------------------------------------------------------------
[L] Read line (src):42:17: "  writewhenclosed"
[P] Parsed sentence: [EnumField] id(writewhenclosed)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[Y] Store OFLD[11]: name=writewhenclosed SupTypIndex=12 SubScope=1 TypIndex=3 Offset=28 IsStatic=0 EnumValue=7
[D] FLD[11]: type=int name=writewhenclosed subscope={Pub:errorcode} offset=28 static=no enumvalue=7
[P] -------------------------------------------------------------------------------------
[L] Read line (src):43:12: "  eofnotopen"
[P] Parsed sentence: [EnumField] id(eofnotopen)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[Y] Store OFLD[12]: name=eofnotopen SupTypIndex=12 SubScope=1 TypIndex=3 Offset=32 IsStatic=0 EnumValue=8
[D] FLD[12]: type=int name=eofnotopen subscope={Pub:errorcode} offset=32 static=no enumvalue=8
[P] -------------------------------------------------------------------------------------
[L] Read line (src):44:21: "  filealreadyopenself"
[P] Parsed sentence: [EnumField] id(filealreadyopenself)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[Y] Store OFLD[13]: name=filealreadyopenself SupTypIndex=12 SubScope=1 TypIndex=3 Offset=36 IsStatic=0 EnumValue=9
[D] FLD[13]: type=int name=filealreadyopenself subscope={Pub:errorcode} offset=36 static=no enumvalue=9
[P] -------------------------------------------------------------------------------------
[L] Read line (src):45:17: "  filealreadyopen"
[P] Parsed sentence: [EnumField] id(filealreadyopen)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[Y] Store OFLD[14]: name=filealreadyopen SupTypIndex=12 SubScope=1 TypIndex=3 Offset=40 IsStatic=0 EnumValue=10
[D] FLD[14]: type=int name=filealreadyopen subscope={Pub:errorcode} offset=40 static=no enumvalue=10
[P] -------------------------------------------------------------------------------------
[L] Read line (src):46:20: "  closealreadyclosed"
[P] Parsed sentence: [EnumField] id(closealreadyclosed)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[Y] Store OFLD[15]: name=closealreadyclosed SupTypIndex=12 SubScope=1 TypIndex=3 Offset=44 IsStatic=0 EnumValue=11
[D] FLD[15]: type=int name=closealreadyclosed subscope={Pub:errorcode} offset=44 static=no enumvalue=11
[P] -------------------------------------------------------------------------------------
[L] Read line (src):47:21: "  freehandleropenfile"
[P] Parsed sentence: [EnumField] id(freehandleropenfile)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[Y] Store OFLD[16]: name=freehandleropenfile SupTypIndex=12 SubScope=1 TypIndex=3 Offset=48 IsStatic=0 EnumValue=12
[D] FLD[16]: type=int name=freehandleropenfile subscope={Pub:errorcode} offset=48 static=no enumvalue=12
[P] -------------------------------------------------------------------------------------
[L] Read line (src):48:18: "  handlerforbidden"
[P] Parsed sentence: [EnumField] id(handlerforbidden)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[Y] Store OFLD[17]: name=handlerforbidden SupTypIndex=12 SubScope=1 TypIndex=3 Offset=52 IsStatic=0 EnumValue=13
[D] FLD[17]: type=int name=handlerforbidden subscope={Pub:errorcode} offset=52 static=no enumvalue=13
[P] -------------------------------------------------------------------------------------
[L] Read line (src):49:5: ":enum"
[P] Parsed sentence: [EndEnum] kw(:enum)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000000h, LocBlk=00000032h
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000004h, LocBlk=00000032h
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000008h, LocBlk=00000032h
[O] Relocation added: Type=BlkInsideBlk, LocAdr=000000000000000Ch, LocBlk=00000032h
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000010h, LocBlk=00000032h
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000014h, LocBlk=00000032h
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000018h, LocBlk=00000032h
[O] Relocation added: Type=BlkInsideBlk, LocAdr=000000000000001Ch, LocBlk=00000032h
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000020h, LocBlk=00000032h
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000024h, LocBlk=00000032h
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000028h, LocBlk=00000032h
[O] Relocation added: Type=BlkInsideBlk, LocAdr=000000000000002Ch, LocBlk=00000032h
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000030h, LocBlk=00000032h
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000034h, LocBlk=00000032h
[O] Relocation added: Type=BlkInsideGlo, LocAdr=00000000000000B0h
[A] DATA:                                     STORE {"ok"                                                     ;Address=[00000000000000B0h]
[A] DATA:                                     STORE  "openreaderror",
[A] DATA:                                     STORE  "openwriteerror",
[A] DATA:                                     STORE  "readerror",
[A] DATA:                                     STORE  "writeerror",
[A] DATA:                                     STORE  "getsizeerror",
[A] DATA:                                     STORE  "readwhenclosed",
[A] DATA:                                     STORE  "writewhenclosed",
[A] DATA:                                     STORE  "eofnotopen",
[A] DATA:                                     STORE  "filealreadyopenself",
[A] DATA:                                     STORE  "filealreadyopen",
[A] DATA:                                     STORE  "closealreadyclosed",
[A] DATA:                                     STORE  "freehandleropenfile",
[A] DATA:                                     STORE  "handlerforbidden"}
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000000h, LocBlk=00000041h
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000004h, LocBlk=00000041h
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000008h, LocBlk=00000041h
[O] Relocation added: Type=BlkInsideBlk, LocAdr=000000000000000Ch, LocBlk=00000041h
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000010h, LocBlk=00000041h
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000014h, LocBlk=00000041h
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000018h, LocBlk=00000041h
[O] Relocation added: Type=BlkInsideBlk, LocAdr=000000000000001Ch, LocBlk=00000041h
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000020h, LocBlk=00000041h
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000024h, LocBlk=00000041h
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000028h, LocBlk=00000041h
[O] Relocation added: Type=BlkInsideBlk, LocAdr=000000000000002Ch, LocBlk=00000041h
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000030h, LocBlk=00000041h
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000034h, LocBlk=00000041h
[O] Relocation added: Type=BlkInsideGlo, LocAdr=00000000000000B4h
[A] DATA:                                     STORE {"int"                                                    ;Address=[00000000000000B4h]
[A] DATA:                                     STORE  "int",
[A] DATA:                                     STORE  "int",
[A] DATA:                                     STORE  "int",
[A] DATA:                                     STORE  "int",
[A] DATA:                                     STORE  "int",
[A] DATA:                                     STORE  "int",
[A] DATA:                                     STORE  "int",
[A] DATA:                                     STORE  "int",
[A] DATA:                                     STORE  "int",
[A] DATA:                                     STORE  "int",
[A] DATA:                                     STORE  "int",
[A] DATA:                                     STORE  "int",
[A] DATA:                                     STORE  "int"}
[Y] Update OTYP[12]: MetaStNames=176 MetaStTypes=180 Length=4 FieldLow=4 FieldHigh=17
[S] Subscope end: {Pub:errorcode}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):52:11: "class date:"
[P] Parsed sentence: [DefClass] kw(class) id(date) pu(:)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[O] Relocation added: Type=BlkInsideGlo, LocAdr=00000000000000B8h
[A] DATA:                                     STORE "date"                                                    ;Address=[00000000000000B8h]
[Y] Store OTYP[13]: name=date msttype=8 FunIndex=-1 SupTypIndex=-1 IsTypedef=0 IsSystemDef=0 Length=0 DimNr=0 ElemTypIndex=-1 DimIndex=-1 FieldLow=-1 FieldHigh=-1
[D] TYP[13]: name=date msttype=class scope={Pub:main} typedef=no systemdef=no length=0
[I] TYP: name=standard.date index=13 searchindex=3, scope={Pub:main}
[S] Subscope begin: {Pub:date}
[P] Updated parser type list: bool,char,date,errorcode,filemode,float,hostsys,int,long,short,string,word
[P] -------------------------------------------------------------------------------------
[L] Read line (src):53:7: "  .publ"
[P] Parsed sentence: [Publ] kw(.publ)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):54:34: "  date(int year,int month,int day)"
[P] Parsed sentence: [FunDecl] ty(date) pu(() ty(int) id(year) pu(,) ty(int) id(month) pu(,) ty(int) id(day) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;date(int year,int month,int day)
[Y] Store OFUN[0]: name=date Kind=2 SupTypIndex=13 SubScope=1 Address=0 TypIndex=13 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[145]: name=date kind=Member returns=date void=no nested=no subscope={Pub:date}
[Y] Store OPAR[0]: name=$result TypIndex=13 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=0
[D] PAR[189]: function=date name=$result type=date order=0 const=no ref=yes
[Y] Store OPAR[1]: name=self TypIndex=13 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=0
[D] PAR[190]: function=date name=self type=date order=1 const=no ref=yes
[Y] Store OPAR[2]: name=year TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=0
[D] PAR[191]: function=date name=year type=int order=2 const=no ref=no
[Y] Store OPAR[3]: name=month TypIndex=3 IsConst=0 IsReference=0 ParmOrder=3 FunIndex=0
[D] PAR[192]: function=date name=month type=int order=3 const=no ref=no
[Y] Store OPAR[4]: name=day TypIndex=3 IsConst=0 IsReference=0 ParmOrder=4 FunIndex=0
[D] PAR[193]: function=date name=day type=int order=4 const=no ref=no
[I] FUN: name=standard.date.date(int,int,int) index=145 searchindex=107, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.date.date($cvint,$cvint,$cvint) index=145 searchindex=7, scope={Pub:main}, scope={Pub:main}
[D] FID[145]: name=date kind=2 fullname=standard.date.date(int,int,int) id=standard_date_date
[Y] Update OFUN[0]: ParmNr=5 ParmLow=0 ParmHigh=4
[A] DECL: (standard_date_date)                DECLARE {REF UNDEFINED $result,REF UNDEFINED self,INTEGER year,INTEGER month,INTEGER day} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):55:40: "  void value(int year,int month,int day)"
[P] Parsed sentence: [FunDecl] kw(void) id(value) pu(() ty(int) id(year) pu(,) ty(int) id(month) pu(,) ty(int) id(day) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;void value(int year,int month,int day)
[Y] Store OFUN[1]: name=value Kind=2 SupTypIndex=13 SubScope=1 Address=0 TypIndex=-1 IsVoid=1 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[146]: name=value kind=Member returns=undefined void=yes nested=no subscope={Pub:date}
[Y] Store OPAR[5]: name=self TypIndex=13 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=1
[D] PAR[194]: function=value name=self type=date order=0 const=no ref=yes
[Y] Store OPAR[6]: name=year TypIndex=3 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=1
[D] PAR[195]: function=value name=year type=int order=1 const=no ref=no
[Y] Store OPAR[7]: name=month TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=1
[D] PAR[196]: function=value name=month type=int order=2 const=no ref=no
[Y] Store OPAR[8]: name=day TypIndex=3 IsConst=0 IsReference=0 ParmOrder=3 FunIndex=1
[D] PAR[197]: function=value name=day type=int order=3 const=no ref=no
[I] FUN: name=standard.date.value(int,int,int) index=146 searchindex=108, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.date.value($cvint,$cvint,$cvint) index=146 searchindex=8, scope={Pub:main}, scope={Pub:main}
[D] FID[146]: name=value kind=2 fullname=standard.date.value(int,int,int) id=standard_date_value
[Y] Update OFUN[1]: ParmNr=4 ParmLow=5 ParmHigh=8
[A] DECL: (standard_date_value)               DECLARE {REF UNDEFINED self,INTEGER year,INTEGER month,INTEGER day} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):56:19: "  date begofmonth()"
[P] Parsed sentence: [FunDecl] ty(date) id(begofmonth) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;date begofmonth()
[Y] Store OFUN[2]: name=begofmonth Kind=2 SupTypIndex=13 SubScope=1 Address=0 TypIndex=13 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[147]: name=begofmonth kind=Member returns=date void=no nested=no subscope={Pub:date}
[Y] Store OPAR[9]: name=$result TypIndex=13 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=2
[D] PAR[198]: function=begofmonth name=$result type=date order=0 const=no ref=yes
[Y] Store OPAR[10]: name=self TypIndex=13 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=2
[D] PAR[199]: function=begofmonth name=self type=date order=1 const=no ref=yes
[I] FUN: name=standard.date.begofmonth() index=147 searchindex=107, scope={Pub:main}, scope={Pub:main}
[D] FID[147]: name=begofmonth kind=2 fullname=standard.date.begofmonth() id=standard_date_begofmonth
[Y] Update OFUN[2]: ParmNr=1 ParmLow=9 ParmHigh=10
[A] DECL: (standard_date_begofmonth)          DECLARE {REF UNDEFINED $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):57:19: "  date endofmonth()"
[P] Parsed sentence: [FunDecl] ty(date) id(endofmonth) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;date endofmonth()
[Y] Store OFUN[3]: name=endofmonth Kind=2 SupTypIndex=13 SubScope=1 Address=0 TypIndex=13 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[148]: name=endofmonth kind=Member returns=date void=no nested=no subscope={Pub:date}
[Y] Store OPAR[11]: name=$result TypIndex=13 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=3
[D] PAR[200]: function=endofmonth name=$result type=date order=0 const=no ref=yes
[Y] Store OPAR[12]: name=self TypIndex=13 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=3
[D] PAR[201]: function=endofmonth name=self type=date order=1 const=no ref=yes
[I] FUN: name=standard.date.endofmonth() index=148 searchindex=109, scope={Pub:main}, scope={Pub:main}
[D] FID[148]: name=endofmonth kind=2 fullname=standard.date.endofmonth() id=standard_date_endofmonth
[Y] Update OFUN[3]: ParmNr=1 ParmLow=11 ParmHigh=12
[A] DECL: (standard_date_endofmonth)          DECLARE {REF UNDEFINED $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):58:12: "  int year()"
[P] Parsed sentence: [FunDecl] ty(int) id(year) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;int year()
[Y] Store OFUN[4]: name=year Kind=2 SupTypIndex=13 SubScope=1 Address=0 TypIndex=3 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[149]: name=year kind=Member returns=int void=no nested=no subscope={Pub:date}
[Y] Store OPAR[13]: name=$result TypIndex=3 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=4
[D] PAR[202]: function=year name=$result type=int order=0 const=no ref=yes
[Y] Store OPAR[14]: name=self TypIndex=13 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=4
[D] PAR[203]: function=year name=self type=date order=1 const=no ref=yes
[I] FUN: name=standard.date.year() index=149 searchindex=111, scope={Pub:main}, scope={Pub:main}
[D] FID[149]: name=year kind=2 fullname=standard.date.year() id=standard_date_year
[Y] Update OFUN[4]: ParmNr=1 ParmLow=13 ParmHigh=14
[A] DECL: (standard_date_year)                DECLARE {REF INTEGER $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):59:13: "  int month()"
[P] Parsed sentence: [FunDecl] ty(int) id(month) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;int month()
[Y] Store OFUN[5]: name=month Kind=2 SupTypIndex=13 SubScope=1 Address=0 TypIndex=3 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[150]: name=month kind=Member returns=int void=no nested=no subscope={Pub:date}
[Y] Store OPAR[15]: name=$result TypIndex=3 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=5
[D] PAR[204]: function=month name=$result type=int order=0 const=no ref=yes
[Y] Store OPAR[16]: name=self TypIndex=13 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=5
[D] PAR[205]: function=month name=self type=date order=1 const=no ref=yes
[I] FUN: name=standard.date.month() index=150 searchindex=110, scope={Pub:main}, scope={Pub:main}
[D] FID[150]: name=month kind=2 fullname=standard.date.month() id=standard_date_month
[Y] Update OFUN[5]: ParmNr=1 ParmLow=15 ParmHigh=16
[A] DECL: (standard_date_month)               DECLARE {REF INTEGER $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):60:11: "  int day()"
[P] Parsed sentence: [FunDecl] ty(int) id(day) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;int day()
[Y] Store OFUN[6]: name=day Kind=2 SupTypIndex=13 SubScope=1 Address=0 TypIndex=3 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[151]: name=day kind=Member returns=int void=no nested=no subscope={Pub:date}
[Y] Store OPAR[17]: name=$result TypIndex=3 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=6
[D] PAR[206]: function=day name=$result type=int order=0 const=no ref=yes
[Y] Store OPAR[18]: name=self TypIndex=13 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=6
[D] PAR[207]: function=day name=self type=date order=1 const=no ref=yes
[I] FUN: name=standard.date.day() index=151 searchindex=109, scope={Pub:main}, scope={Pub:main}
[D] FID[151]: name=day kind=2 fullname=standard.date.day() id=standard_date_day
[Y] Update OFUN[6]: ParmNr=1 ParmLow=17 ParmHigh=18
[A] DECL: (standard_date_day)                 DECLARE {REF INTEGER $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):61:26: "  date addyears(int years)"
[P] Parsed sentence: [FunDecl] ty(date) id(addyears) pu(() ty(int) id(years) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;date addyears(int years)
[Y] Store OFUN[7]: name=addyears Kind=2 SupTypIndex=13 SubScope=1 Address=0 TypIndex=13 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[152]: name=addyears kind=Member returns=date void=no nested=no subscope={Pub:date}
[Y] Store OPAR[19]: name=$result TypIndex=13 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=7
[D] PAR[208]: function=addyears name=$result type=date order=0 const=no ref=yes
[Y] Store OPAR[20]: name=self TypIndex=13 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=7
[D] PAR[209]: function=addyears name=self type=date order=1 const=no ref=yes
[Y] Store OPAR[21]: name=years TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=7
[D] PAR[210]: function=addyears name=years type=int order=2 const=no ref=no
[I] FUN: name=standard.date.addyears(int) index=152 searchindex=107, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.date.addyears($cvint) index=152 searchindex=7, scope={Pub:main}, scope={Pub:main}
[D] FID[152]: name=addyears kind=2 fullname=standard.date.addyears(int) id=standard_date_addyears
[Y] Update OFUN[7]: ParmNr=3 ParmLow=19 ParmHigh=21
[A] DECL: (standard_date_addyears)            DECLARE {REF UNDEFINED $result,REF UNDEFINED self,INTEGER years} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):62:28: "  date addmonths(int months)"
[P] Parsed sentence: [FunDecl] ty(date) id(addmonths) pu(() ty(int) id(months) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;date addmonths(int months)
[Y] Store OFUN[8]: name=addmonths Kind=2 SupTypIndex=13 SubScope=1 Address=0 TypIndex=13 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[153]: name=addmonths kind=Member returns=date void=no nested=no subscope={Pub:date}
[Y] Store OPAR[22]: name=$result TypIndex=13 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=8
[D] PAR[211]: function=addmonths name=$result type=date order=0 const=no ref=yes
[Y] Store OPAR[23]: name=self TypIndex=13 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=8
[D] PAR[212]: function=addmonths name=self type=date order=1 const=no ref=yes
[Y] Store OPAR[24]: name=months TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=8
[D] PAR[213]: function=addmonths name=months type=int order=2 const=no ref=no
[I] FUN: name=standard.date.addmonths(int) index=153 searchindex=107, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.date.addmonths($cvint) index=153 searchindex=7, scope={Pub:main}, scope={Pub:main}
[D] FID[153]: name=addmonths kind=2 fullname=standard.date.addmonths(int) id=standard_date_addmonths
[Y] Update OFUN[8]: ParmNr=3 ParmLow=22 ParmHigh=24
[A] DECL: (standard_date_addmonths)           DECLARE {REF UNDEFINED $result,REF UNDEFINED self,INTEGER months} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):63:24: "  date adddays(int days)"
[P] Parsed sentence: [FunDecl] ty(date) id(adddays) pu(() ty(int) id(days) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;date adddays(int days)
[Y] Store OFUN[9]: name=adddays Kind=2 SupTypIndex=13 SubScope=1 Address=0 TypIndex=13 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[154]: name=adddays kind=Member returns=date void=no nested=no subscope={Pub:date}
[Y] Store OPAR[25]: name=$result TypIndex=13 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=9
[D] PAR[214]: function=adddays name=$result type=date order=0 const=no ref=yes
[Y] Store OPAR[26]: name=self TypIndex=13 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=9
[D] PAR[215]: function=adddays name=self type=date order=1 const=no ref=yes
[Y] Store OPAR[27]: name=days TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=9
[D] PAR[216]: function=adddays name=days type=int order=2 const=no ref=no
[I] FUN: name=standard.date.adddays(int) index=154 searchindex=107, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.date.adddays($cvint) index=154 searchindex=7, scope={Pub:main}, scope={Pub:main}
[D] FID[154]: name=adddays kind=2 fullname=standard.date.adddays(int) id=standard_date_adddays
[Y] Update OFUN[9]: ParmNr=3 ParmLow=25 ParmHigh=27
[A] DECL: (standard_date_adddays)             DECLARE {REF UNDEFINED $result,REF UNDEFINED self,INTEGER days} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):64:16: "  string tostr()"
[P] Parsed sentence: [FunDecl] ty(string) id(tostr) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;string tostr()
[Y] Store OFUN[10]: name=tostr Kind=2 SupTypIndex=13 SubScope=1 Address=0 TypIndex=6 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[155]: name=tostr kind=Member returns=string void=no nested=no subscope={Pub:date}
[Y] Store OPAR[28]: name=$result TypIndex=6 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=10
[D] PAR[217]: function=tostr name=$result type=string order=0 const=no ref=yes
[Y] Store OPAR[29]: name=self TypIndex=13 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=10
[D] PAR[218]: function=tostr name=self type=date order=1 const=no ref=yes
[I] FUN: name=standard.date.tostr() index=155 searchindex=115, scope={Pub:main}, scope={Pub:main}
[D] FID[155]: name=tostr kind=2 fullname=standard.date.tostr() id=standard_date_tostr
[Y] Update OFUN[10]: ParmNr=1 ParmLow=28 ParmHigh=29
[A] DECL: (standard_date_tostr)               DECLARE {REF STRINGBLOCK $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):65:26: "  string tostr(char delim)"
[P] Parsed sentence: [FunDecl] ty(string) id(tostr) pu(() ty(char) id(delim) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;string tostr(char delim)
[Y] Store OFUN[11]: name=tostr Kind=2 SupTypIndex=13 SubScope=1 Address=0 TypIndex=6 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[156]: name=tostr kind=Member returns=string void=no nested=no subscope={Pub:date}
[Y] Store OPAR[30]: name=$result TypIndex=6 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=11
[D] PAR[219]: function=tostr name=$result type=string order=0 const=no ref=yes
[Y] Store OPAR[31]: name=self TypIndex=13 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=11
[D] PAR[220]: function=tostr name=self type=date order=1 const=no ref=yes
[Y] Store OPAR[32]: name=delim TypIndex=1 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=11
[D] PAR[221]: function=tostr name=delim type=char order=2 const=no ref=no
[I] FUN: name=standard.date.tostr(char) index=156 searchindex=116, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.date.tostr($cvint) index=156 searchindex=11, scope={Pub:main}, scope={Pub:main}
[D] FID[156]: name=tostr kind=2 fullname=standard.date.tostr(char) id=standard_date_tostr2
[Y] Update OFUN[11]: ParmNr=3 ParmLow=30 ParmHigh=32
[A] DECL: (standard_date_tostr2)              DECLARE {REF STRINGBLOCK $result,REF UNDEFINED self,CHAR delim} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):66:7: "  .priv"
[P] Parsed sentence: [Priv] kw(.priv)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[S] Subscope end: {Pub:date}
[S] Subscope begin: {Pri:date}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):67:9: "  int _dt"
[P] Parsed sentence: [VarDecl] ty(int) id(_dt)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;int _dt
[D] FLD[18]: type=int name=_dt subscope={Pri:date} offset=0 static=no enumvalue=0
[P] -------------------------------------------------------------------------------------
[L] Read line (src):68:20: "  allow [+]() to _dt"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(+) pu(]) pu(() pu()) kw(to) id(_dt)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[0]: name=OPFI:[+]()->standard.date._dt
[I] GRA: name=OPFI:[+]()->standard.date._dt index=0 searchindex=0, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):69:20: "  allow [-]() to _dt"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(-) pu(]) pu(() pu()) kw(to) id(_dt)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[1]: name=OPFI:[-]()->standard.date._dt
[I] GRA: name=OPFI:[-]()->standard.date._dt index=1 searchindex=1, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):70:21: "  allow [==]() to _dt"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(==) pu(]) pu(() pu()) kw(to) id(_dt)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[2]: name=OPFI:[==]()->standard.date._dt
[I] GRA: name=OPFI:[==]()->standard.date._dt index=2 searchindex=2, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):71:21: "  allow [!=]() to _dt"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(!=) pu(]) pu(() pu()) kw(to) id(_dt)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[3]: name=OPFI:[!=]()->standard.date._dt
[I] GRA: name=OPFI:[!=]()->standard.date._dt index=3 searchindex=0, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):72:20: "  allow [<]() to _dt"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(<) pu(]) pu(() pu()) kw(to) id(_dt)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[4]: name=OPFI:[<]()->standard.date._dt
[I] GRA: name=OPFI:[<]()->standard.date._dt index=4 searchindex=3, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):73:20: "  allow [>]() to _dt"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(>) pu(]) pu(() pu()) kw(to) id(_dt)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[5]: name=OPFI:[>]()->standard.date._dt
[I] GRA: name=OPFI:[>]()->standard.date._dt index=5 searchindex=5, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):74:21: "  allow [<=]() to _dt"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(<=) pu(]) pu(() pu()) kw(to) id(_dt)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[6]: name=OPFI:[<=]()->standard.date._dt
[I] GRA: name=OPFI:[<=]()->standard.date._dt index=6 searchindex=3, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):75:21: "  allow [>=]() to _dt"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(>=) pu(]) pu(() pu()) kw(to) id(_dt)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[7]: name=OPFI:[>=]()->standard.date._dt
[I] GRA: name=OPFI:[>=]()->standard.date._dt index=7 searchindex=6, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):76:6: ":class"
[P] Parsed sentence: [EndClass] kw(:class)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000000h, LocBlk=00000044h
[O] Relocation added: Type=BlkInsideGlo, LocAdr=00000000000000BCh
[A] DATA:                                     STORE {"_dt"                                                    ;Address=[00000000000000BCh]
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000000h, LocBlk=00000046h
[O] Relocation added: Type=BlkInsideGlo, LocAdr=00000000000000C0h
[A] DATA:                                     STORE {"int"                                                    ;Address=[00000000000000C0h]
[Y] Update OTYP[13]: MetaStNames=188 MetaStTypes=192 Length=4 FieldLow=-1 FieldHigh=-1
[S] Subscope end: {Pri:date}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):79:11: "class time:"
[P] Parsed sentence: [DefClass] kw(class) id(time) pu(:)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[O] Relocation added: Type=BlkInsideGlo, LocAdr=00000000000000C4h
[A] DATA:                                     STORE "time"                                                    ;Address=[00000000000000C4h]
[Y] Store OTYP[14]: name=time msttype=8 FunIndex=-1 SupTypIndex=-1 IsTypedef=0 IsSystemDef=0 Length=0 DimNr=0 ElemTypIndex=-1 DimIndex=-1 FieldLow=-1 FieldHigh=-1
[D] TYP[14]: name=time msttype=class scope={Pub:main} typedef=no systemdef=no length=0
[I] TYP: name=standard.time index=14 searchindex=13, scope={Pub:main}
[S] Subscope begin: {Pub:time}
[P] Updated parser type list: bool,char,date,errorcode,filemode,float,hostsys,int,long,short,string,time,word
[P] -------------------------------------------------------------------------------------
[L] Read line (src):80:7: "  .publ"
[P] Parsed sentence: [Publ] kw(.publ)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):81:38: "  time(int hour,int minute,int second)"
[P] Parsed sentence: [FunDecl] ty(time) pu(() ty(int) id(hour) pu(,) ty(int) id(minute) pu(,) ty(int) id(second) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;time(int hour,int minute,int second)
[Y] Store OFUN[12]: name=time Kind=2 SupTypIndex=14 SubScope=1 Address=0 TypIndex=14 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[157]: name=time kind=Member returns=time void=no nested=no subscope={Pub:time}
[Y] Store OPAR[33]: name=$result TypIndex=14 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=12
[D] PAR[222]: function=time name=$result type=time order=0 const=no ref=yes
[Y] Store OPAR[34]: name=self TypIndex=14 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=12
[D] PAR[223]: function=time name=self type=time order=1 const=no ref=yes
[Y] Store OPAR[35]: name=hour TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=12
[D] PAR[224]: function=time name=hour type=int order=2 const=no ref=no
[Y] Store OPAR[36]: name=minute TypIndex=3 IsConst=0 IsReference=0 ParmOrder=3 FunIndex=12
[D] PAR[225]: function=time name=minute type=int order=3 const=no ref=no
[Y] Store OPAR[37]: name=second TypIndex=3 IsConst=0 IsReference=0 ParmOrder=4 FunIndex=12
[D] PAR[226]: function=time name=second type=int order=4 const=no ref=no
[I] FUN: name=standard.time.time(int,int,int) index=157 searchindex=119, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.time.time($cvint,$cvint,$cvint) index=157 searchindex=13, scope={Pub:main}, scope={Pub:main}
[D] FID[157]: name=time kind=2 fullname=standard.time.time(int,int,int) id=standard_time_time
[Y] Update OFUN[12]: ParmNr=5 ParmLow=33 ParmHigh=37
[A] DECL: (standard_time_time)                DECLARE {REF UNDEFINED $result,REF UNDEFINED self,INTEGER hour,INTEGER minute,INTEGER second} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):82:51: "  time(int hour,int minute,int second,int millisec)"
[P] Parsed sentence: [FunDecl] ty(time) pu(() ty(int) id(hour) pu(,) ty(int) id(minute) pu(,) ty(int) id(second) pu(,) ty(int) id(millisec) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;time(int hour,int minute,int second,int millisec)
[Y] Store OFUN[13]: name=time Kind=2 SupTypIndex=14 SubScope=1 Address=0 TypIndex=14 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[158]: name=time kind=Member returns=time void=no nested=no subscope={Pub:time}
[Y] Store OPAR[38]: name=$result TypIndex=14 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=13
[D] PAR[227]: function=time name=$result type=time order=0 const=no ref=yes
[Y] Store OPAR[39]: name=self TypIndex=14 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=13
[D] PAR[228]: function=time name=self type=time order=1 const=no ref=yes
[Y] Store OPAR[40]: name=hour TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=13
[D] PAR[229]: function=time name=hour type=int order=2 const=no ref=no
[Y] Store OPAR[41]: name=minute TypIndex=3 IsConst=0 IsReference=0 ParmOrder=3 FunIndex=13
[D] PAR[230]: function=time name=minute type=int order=3 const=no ref=no
[Y] Store OPAR[42]: name=second TypIndex=3 IsConst=0 IsReference=0 ParmOrder=4 FunIndex=13
[D] PAR[231]: function=time name=second type=int order=4 const=no ref=no
[Y] Store OPAR[43]: name=millisec TypIndex=3 IsConst=0 IsReference=0 ParmOrder=5 FunIndex=13
[D] PAR[232]: function=time name=millisec type=int order=5 const=no ref=no
[I] FUN: name=standard.time.time(int,int,int,int) index=158 searchindex=120, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.time.time($cvint,$cvint,$cvint,$cvint) index=158 searchindex=14, scope={Pub:main}, scope={Pub:main}
[D] FID[158]: name=time kind=2 fullname=standard.time.time(int,int,int,int) id=standard_time_time2
[Y] Update OFUN[13]: ParmNr=6 ParmLow=38 ParmHigh=43
[A] DECL: (standard_time_time2)               DECLARE {REF UNDEFINED $result,REF UNDEFINED self,INTEGER hour,INTEGER minute,INTEGER second,INTEGER millisec} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):83:64: "  time(int hour,int minute,int second,int millisec,int microsec)"
[P] Parsed sentence: [FunDecl] ty(time) pu(() ty(int) id(hour) pu(,) ty(int) id(minute) pu(,) ty(int) id(second) pu(,) ty(int) id(millisec) pu(,) ty(int) id(microsec) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;time(int hour,int minute,int second,int millisec,int microsec)
[Y] Store OFUN[14]: name=time Kind=2 SupTypIndex=14 SubScope=1 Address=0 TypIndex=14 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[159]: name=time kind=Member returns=time void=no nested=no subscope={Pub:time}
[Y] Store OPAR[44]: name=$result TypIndex=14 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=14
[D] PAR[233]: function=time name=$result type=time order=0 const=no ref=yes
[Y] Store OPAR[45]: name=self TypIndex=14 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=14
[D] PAR[234]: function=time name=self type=time order=1 const=no ref=yes
[Y] Store OPAR[46]: name=hour TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=14
[D] PAR[235]: function=time name=hour type=int order=2 const=no ref=no
[Y] Store OPAR[47]: name=minute TypIndex=3 IsConst=0 IsReference=0 ParmOrder=3 FunIndex=14
[D] PAR[236]: function=time name=minute type=int order=3 const=no ref=no
[Y] Store OPAR[48]: name=second TypIndex=3 IsConst=0 IsReference=0 ParmOrder=4 FunIndex=14
[D] PAR[237]: function=time name=second type=int order=4 const=no ref=no
[Y] Store OPAR[49]: name=millisec TypIndex=3 IsConst=0 IsReference=0 ParmOrder=5 FunIndex=14
[D] PAR[238]: function=time name=millisec type=int order=5 const=no ref=no
[Y] Store OPAR[50]: name=microsec TypIndex=3 IsConst=0 IsReference=0 ParmOrder=6 FunIndex=14
[D] PAR[239]: function=time name=microsec type=int order=6 const=no ref=no
[I] FUN: name=standard.time.time(int,int,int,int,int) index=159 searchindex=121, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.time.time($cvint,$cvint,$cvint,$cvint,$cvint) index=159 searchindex=15, scope={Pub:main}, scope={Pub:main}
[D] FID[159]: name=time kind=2 fullname=standard.time.time(int,int,int,int,int) id=standard_time_time3
[Y] Update OFUN[14]: ParmNr=7 ParmLow=44 ParmHigh=50
[A] DECL: (standard_time_time3)               DECLARE {REF UNDEFINED $result,REF UNDEFINED self,INTEGER hour,INTEGER minute,INTEGER second,INTEGER millisec,INTEGER microsec} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):84:76: "  time(int hour,int minute,int second,int millisec,int microsec,int nanosec)"
[P] Parsed sentence: [FunDecl] ty(time) pu(() ty(int) id(hour) pu(,) ty(int) id(minute) pu(,) ty(int) id(second) pu(,) ty(int) id(millisec) pu(,) ty(int) id(microsec) pu(,) ty(int) id(nanosec) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;time(int hour,int minute,int second,int millisec,int microsec,int nanosec)
[Y] Store OFUN[15]: name=time Kind=2 SupTypIndex=14 SubScope=1 Address=0 TypIndex=14 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[160]: name=time kind=Member returns=time void=no nested=no subscope={Pub:time}
[Y] Store OPAR[51]: name=$result TypIndex=14 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=15
[D] PAR[240]: function=time name=$result type=time order=0 const=no ref=yes
[Y] Store OPAR[52]: name=self TypIndex=14 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=15
[D] PAR[241]: function=time name=self type=time order=1 const=no ref=yes
[Y] Store OPAR[53]: name=hour TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=15
[D] PAR[242]: function=time name=hour type=int order=2 const=no ref=no
[Y] Store OPAR[54]: name=minute TypIndex=3 IsConst=0 IsReference=0 ParmOrder=3 FunIndex=15
[D] PAR[243]: function=time name=minute type=int order=3 const=no ref=no
[Y] Store OPAR[55]: name=second TypIndex=3 IsConst=0 IsReference=0 ParmOrder=4 FunIndex=15
[D] PAR[244]: function=time name=second type=int order=4 const=no ref=no
[Y] Store OPAR[56]: name=millisec TypIndex=3 IsConst=0 IsReference=0 ParmOrder=5 FunIndex=15
[D] PAR[245]: function=time name=millisec type=int order=5 const=no ref=no
[Y] Store OPAR[57]: name=microsec TypIndex=3 IsConst=0 IsReference=0 ParmOrder=6 FunIndex=15
[D] PAR[246]: function=time name=microsec type=int order=6 const=no ref=no
[Y] Store OPAR[58]: name=nanosec TypIndex=3 IsConst=0 IsReference=0 ParmOrder=7 FunIndex=15
[D] PAR[247]: function=time name=nanosec type=int order=7 const=no ref=no
[I] FUN: name=standard.time.time(int,int,int,int,int,int) index=160 searchindex=122, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.time.time($cvint,$cvint,$cvint,$cvint,$cvint,$cvint) index=160 searchindex=16, scope={Pub:main}, scope={Pub:main}
[D] FID[160]: name=time kind=2 fullname=standard.time.time(int,int,int,int,int,int) id=standard_time_time4
[Y] Update OFUN[15]: ParmNr=8 ParmLow=51 ParmHigh=58
[A] DECL: (standard_time_time4)               DECLARE {REF UNDEFINED $result,REF UNDEFINED self,INTEGER hour,INTEGER minute,INTEGER second,INTEGER millisec,INTEGER microsec,INTEGER nanosec} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):85:44: "  void value(int hour,int minute,int second)"
[P] Parsed sentence: [FunDecl] kw(void) id(value) pu(() ty(int) id(hour) pu(,) ty(int) id(minute) pu(,) ty(int) id(second) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;void value(int hour,int minute,int second)
[Y] Store OFUN[16]: name=value Kind=2 SupTypIndex=14 SubScope=1 Address=0 TypIndex=-1 IsVoid=1 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[161]: name=value kind=Member returns=undefined void=yes nested=no subscope={Pub:time}
[Y] Store OPAR[59]: name=self TypIndex=14 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=16
[D] PAR[248]: function=value name=self type=time order=0 const=no ref=yes
[Y] Store OPAR[60]: name=hour TypIndex=3 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=16
[D] PAR[249]: function=value name=hour type=int order=1 const=no ref=no
[Y] Store OPAR[61]: name=minute TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=16
[D] PAR[250]: function=value name=minute type=int order=2 const=no ref=no
[Y] Store OPAR[62]: name=second TypIndex=3 IsConst=0 IsReference=0 ParmOrder=3 FunIndex=16
[D] PAR[251]: function=value name=second type=int order=3 const=no ref=no
[I] FUN: name=standard.time.value(int,int,int) index=161 searchindex=123, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.time.value($cvint,$cvint,$cvint) index=161 searchindex=17, scope={Pub:main}, scope={Pub:main}
[D] FID[161]: name=value kind=2 fullname=standard.time.value(int,int,int) id=standard_time_value
[Y] Update OFUN[16]: ParmNr=4 ParmLow=59 ParmHigh=62
[A] DECL: (standard_time_value)               DECLARE {REF UNDEFINED self,INTEGER hour,INTEGER minute,INTEGER second} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):86:57: "  void value(int hour,int minute,int second,int millisec)"
[P] Parsed sentence: [FunDecl] kw(void) id(value) pu(() ty(int) id(hour) pu(,) ty(int) id(minute) pu(,) ty(int) id(second) pu(,) ty(int) id(millisec) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;void value(int hour,int minute,int second,int millisec)
[Y] Store OFUN[17]: name=value Kind=2 SupTypIndex=14 SubScope=1 Address=0 TypIndex=-1 IsVoid=1 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[162]: name=value kind=Member returns=undefined void=yes nested=no subscope={Pub:time}
[Y] Store OPAR[63]: name=self TypIndex=14 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=17
[D] PAR[252]: function=value name=self type=time order=0 const=no ref=yes
[Y] Store OPAR[64]: name=hour TypIndex=3 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=17
[D] PAR[253]: function=value name=hour type=int order=1 const=no ref=no
[Y] Store OPAR[65]: name=minute TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=17
[D] PAR[254]: function=value name=minute type=int order=2 const=no ref=no
[Y] Store OPAR[66]: name=second TypIndex=3 IsConst=0 IsReference=0 ParmOrder=3 FunIndex=17
[D] PAR[255]: function=value name=second type=int order=3 const=no ref=no
[Y] Store OPAR[67]: name=millisec TypIndex=3 IsConst=0 IsReference=0 ParmOrder=4 FunIndex=17
[D] PAR[256]: function=value name=millisec type=int order=4 const=no ref=no
[I] FUN: name=standard.time.value(int,int,int,int) index=162 searchindex=124, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.time.value($cvint,$cvint,$cvint,$cvint) index=162 searchindex=18, scope={Pub:main}, scope={Pub:main}
[D] FID[162]: name=value kind=2 fullname=standard.time.value(int,int,int,int) id=standard_time_value2
[Y] Update OFUN[17]: ParmNr=5 ParmLow=63 ParmHigh=67
[A] DECL: (standard_time_value2)              DECLARE {REF UNDEFINED self,INTEGER hour,INTEGER minute,INTEGER second,INTEGER millisec} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):87:70: "  void value(int hour,int minute,int second,int millisec,int microsec)"
[P] Parsed sentence: [FunDecl] kw(void) id(value) pu(() ty(int) id(hour) pu(,) ty(int) id(minute) pu(,) ty(int) id(second) pu(,) ty(int) id(millisec) pu(,) ty(int) id(microsec) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;void value(int hour,int minute,int second,int millisec,int microsec)
[Y] Store OFUN[18]: name=value Kind=2 SupTypIndex=14 SubScope=1 Address=0 TypIndex=-1 IsVoid=1 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[163]: name=value kind=Member returns=undefined void=yes nested=no subscope={Pub:time}
[Y] Store OPAR[68]: name=self TypIndex=14 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=18
[D] PAR[257]: function=value name=self type=time order=0 const=no ref=yes
[Y] Store OPAR[69]: name=hour TypIndex=3 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=18
[D] PAR[258]: function=value name=hour type=int order=1 const=no ref=no
[Y] Store OPAR[70]: name=minute TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=18
[D] PAR[259]: function=value name=minute type=int order=2 const=no ref=no
[Y] Store OPAR[71]: name=second TypIndex=3 IsConst=0 IsReference=0 ParmOrder=3 FunIndex=18
[D] PAR[260]: function=value name=second type=int order=3 const=no ref=no
[Y] Store OPAR[72]: name=millisec TypIndex=3 IsConst=0 IsReference=0 ParmOrder=4 FunIndex=18
[D] PAR[261]: function=value name=millisec type=int order=4 const=no ref=no
[Y] Store OPAR[73]: name=microsec TypIndex=3 IsConst=0 IsReference=0 ParmOrder=5 FunIndex=18
[D] PAR[262]: function=value name=microsec type=int order=5 const=no ref=no
[I] FUN: name=standard.time.value(int,int,int,int,int) index=163 searchindex=125, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.time.value($cvint,$cvint,$cvint,$cvint,$cvint) index=163 searchindex=19, scope={Pub:main}, scope={Pub:main}
[D] FID[163]: name=value kind=2 fullname=standard.time.value(int,int,int,int,int) id=standard_time_value3
[Y] Update OFUN[18]: ParmNr=6 ParmLow=68 ParmHigh=73
[A] DECL: (standard_time_value3)              DECLARE {REF UNDEFINED self,INTEGER hour,INTEGER minute,INTEGER second,INTEGER millisec,INTEGER microsec} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):88:82: "  void value(int hour,int minute,int second,int millisec,int microsec,int nanosec)"
[P] Parsed sentence: [FunDecl] kw(void) id(value) pu(() ty(int) id(hour) pu(,) ty(int) id(minute) pu(,) ty(int) id(second) pu(,) ty(int) id(millisec) pu(,) ty(int) id(microsec) pu(,) ty(int) id(nanosec) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;void value(int hour,int minute,int second,int millisec,int microsec,int nanosec)
[Y] Store OFUN[19]: name=value Kind=2 SupTypIndex=14 SubScope=1 Address=0 TypIndex=-1 IsVoid=1 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[164]: name=value kind=Member returns=undefined void=yes nested=no subscope={Pub:time}
[Y] Store OPAR[74]: name=self TypIndex=14 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=19
[D] PAR[263]: function=value name=self type=time order=0 const=no ref=yes
[Y] Store OPAR[75]: name=hour TypIndex=3 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=19
[D] PAR[264]: function=value name=hour type=int order=1 const=no ref=no
[Y] Store OPAR[76]: name=minute TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=19
[D] PAR[265]: function=value name=minute type=int order=2 const=no ref=no
[Y] Store OPAR[77]: name=second TypIndex=3 IsConst=0 IsReference=0 ParmOrder=3 FunIndex=19
[D] PAR[266]: function=value name=second type=int order=3 const=no ref=no
[Y] Store OPAR[78]: name=millisec TypIndex=3 IsConst=0 IsReference=0 ParmOrder=4 FunIndex=19
[D] PAR[267]: function=value name=millisec type=int order=4 const=no ref=no
[Y] Store OPAR[79]: name=microsec TypIndex=3 IsConst=0 IsReference=0 ParmOrder=5 FunIndex=19
[D] PAR[268]: function=value name=microsec type=int order=5 const=no ref=no
[Y] Store OPAR[80]: name=nanosec TypIndex=3 IsConst=0 IsReference=0 ParmOrder=6 FunIndex=19
[D] PAR[269]: function=value name=nanosec type=int order=6 const=no ref=no
[I] FUN: name=standard.time.value(int,int,int,int,int,int) index=164 searchindex=126, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.time.value($cvint,$cvint,$cvint,$cvint,$cvint,$cvint) index=164 searchindex=20, scope={Pub:main}, scope={Pub:main}
[D] FID[164]: name=value kind=2 fullname=standard.time.value(int,int,int,int,int,int) id=standard_time_value4
[Y] Update OFUN[19]: ParmNr=7 ParmLow=74 ParmHigh=80
[A] DECL: (standard_time_value4)              DECLARE {REF UNDEFINED self,INTEGER hour,INTEGER minute,INTEGER second,INTEGER millisec,INTEGER microsec,INTEGER nanosec} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):89:12: "  int hour()"
[P] Parsed sentence: [FunDecl] ty(int) id(hour) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;int hour()
[Y] Store OFUN[20]: name=hour Kind=2 SupTypIndex=14 SubScope=1 Address=0 TypIndex=3 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[165]: name=hour kind=Member returns=int void=no nested=no subscope={Pub:time}
[Y] Store OPAR[81]: name=$result TypIndex=3 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=20
[D] PAR[270]: function=hour name=$result type=int order=0 const=no ref=yes
[Y] Store OPAR[82]: name=self TypIndex=14 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=20
[D] PAR[271]: function=hour name=self type=time order=1 const=no ref=yes
[I] FUN: name=standard.time.hour() index=165 searchindex=119, scope={Pub:main}, scope={Pub:main}
[D] FID[165]: name=hour kind=2 fullname=standard.time.hour() id=standard_time_hour
[Y] Update OFUN[20]: ParmNr=1 ParmLow=81 ParmHigh=82
[A] DECL: (standard_time_hour)                DECLARE {REF INTEGER $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):90:14: "  int minute()"
[P] Parsed sentence: [FunDecl] ty(int) id(minute) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;int minute()
[Y] Store OFUN[21]: name=minute Kind=2 SupTypIndex=14 SubScope=1 Address=0 TypIndex=3 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[166]: name=minute kind=Member returns=int void=no nested=no subscope={Pub:time}
[Y] Store OPAR[83]: name=$result TypIndex=3 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=21
[D] PAR[272]: function=minute name=$result type=int order=0 const=no ref=yes
[Y] Store OPAR[84]: name=self TypIndex=14 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=21
[D] PAR[273]: function=minute name=self type=time order=1 const=no ref=yes
[I] FUN: name=standard.time.minute() index=166 searchindex=120, scope={Pub:main}, scope={Pub:main}
[D] FID[166]: name=minute kind=2 fullname=standard.time.minute() id=standard_time_minute
[Y] Update OFUN[21]: ParmNr=1 ParmLow=83 ParmHigh=84
[A] DECL: (standard_time_minute)              DECLARE {REF INTEGER $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):91:14: "  int second()"
[P] Parsed sentence: [FunDecl] ty(int) id(second) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;int second()
[Y] Store OFUN[22]: name=second Kind=2 SupTypIndex=14 SubScope=1 Address=0 TypIndex=3 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[167]: name=second kind=Member returns=int void=no nested=no subscope={Pub:time}
[Y] Store OPAR[85]: name=$result TypIndex=3 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=22
[D] PAR[274]: function=second name=$result type=int order=0 const=no ref=yes
[Y] Store OPAR[86]: name=self TypIndex=14 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=22
[D] PAR[275]: function=second name=self type=time order=1 const=no ref=yes
[I] FUN: name=standard.time.second() index=167 searchindex=121, scope={Pub:main}, scope={Pub:main}
[D] FID[167]: name=second kind=2 fullname=standard.time.second() id=standard_time_second
[Y] Update OFUN[22]: ParmNr=1 ParmLow=85 ParmHigh=86
[A] DECL: (standard_time_second)              DECLARE {REF INTEGER $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):92:16: "  int millisec()"
[P] Parsed sentence: [FunDecl] ty(int) id(millisec) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;int millisec()
[Y] Store OFUN[23]: name=millisec Kind=2 SupTypIndex=14 SubScope=1 Address=0 TypIndex=3 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[168]: name=millisec kind=Member returns=int void=no nested=no subscope={Pub:time}
[Y] Store OPAR[87]: name=$result TypIndex=3 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=23
[D] PAR[276]: function=millisec name=$result type=int order=0 const=no ref=yes
[Y] Store OPAR[88]: name=self TypIndex=14 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=23
[D] PAR[277]: function=millisec name=self type=time order=1 const=no ref=yes
[I] FUN: name=standard.time.millisec() index=168 searchindex=120, scope={Pub:main}, scope={Pub:main}
[D] FID[168]: name=millisec kind=2 fullname=standard.time.millisec() id=standard_time_millisec
[Y] Update OFUN[23]: ParmNr=1 ParmLow=87 ParmHigh=88
[A] DECL: (standard_time_millisec)            DECLARE {REF INTEGER $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):93:16: "  int microsec()"
[P] Parsed sentence: [FunDecl] ty(int) id(microsec) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;int microsec()
[Y] Store OFUN[24]: name=microsec Kind=2 SupTypIndex=14 SubScope=1 Address=0 TypIndex=3 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[169]: name=microsec kind=Member returns=int void=no nested=no subscope={Pub:time}
[Y] Store OPAR[89]: name=$result TypIndex=3 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=24
[D] PAR[278]: function=microsec name=$result type=int order=0 const=no ref=yes
[Y] Store OPAR[90]: name=self TypIndex=14 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=24
[D] PAR[279]: function=microsec name=self type=time order=1 const=no ref=yes
[I] FUN: name=standard.time.microsec() index=169 searchindex=120, scope={Pub:main}, scope={Pub:main}
[D] FID[169]: name=microsec kind=2 fullname=standard.time.microsec() id=standard_time_microsec
[Y] Update OFUN[24]: ParmNr=1 ParmLow=89 ParmHigh=90
[A] DECL: (standard_time_microsec)            DECLARE {REF INTEGER $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):94:15: "  int nanosec()"
[P] Parsed sentence: [FunDecl] ty(int) id(nanosec) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;int nanosec()
[Y] Store OFUN[25]: name=nanosec Kind=2 SupTypIndex=14 SubScope=1 Address=0 TypIndex=3 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[170]: name=nanosec kind=Member returns=int void=no nested=no subscope={Pub:time}
[Y] Store OPAR[91]: name=$result TypIndex=3 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=25
[D] PAR[280]: function=nanosec name=$result type=int order=0 const=no ref=yes
[Y] Store OPAR[92]: name=self TypIndex=14 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=25
[D] PAR[281]: function=nanosec name=self type=time order=1 const=no ref=yes
[I] FUN: name=standard.time.nanosec() index=170 searchindex=123, scope={Pub:main}, scope={Pub:main}
[D] FID[170]: name=nanosec kind=2 fullname=standard.time.nanosec() id=standard_time_nanosec
[Y] Update OFUN[25]: ParmNr=1 ParmLow=91 ParmHigh=92
[A] DECL: (standard_time_nanosec)             DECLARE {REF INTEGER $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):95:26: "  time addhours(int hours)"
[P] Parsed sentence: [FunDecl] ty(time) id(addhours) pu(() ty(int) id(hours) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;time addhours(int hours)
[Y] Store OFUN[26]: name=addhours Kind=2 SupTypIndex=14 SubScope=1 Address=0 TypIndex=14 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[171]: name=addhours kind=Member returns=time void=no nested=no subscope={Pub:time}
[Y] Store OPAR[93]: name=$result TypIndex=14 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=26
[D] PAR[282]: function=addhours name=$result type=time order=0 const=no ref=yes
[Y] Store OPAR[94]: name=self TypIndex=14 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=26
[D] PAR[283]: function=addhours name=self type=time order=1 const=no ref=yes
[Y] Store OPAR[95]: name=hours TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=26
[D] PAR[284]: function=addhours name=hours type=int order=2 const=no ref=no
[I] FUN: name=standard.time.addhours(int) index=171 searchindex=119, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.time.addhours($cvint) index=171 searchindex=13, scope={Pub:main}, scope={Pub:main}
[D] FID[171]: name=addhours kind=2 fullname=standard.time.addhours(int) id=standard_time_addhours
[Y] Update OFUN[26]: ParmNr=3 ParmLow=93 ParmHigh=95
[A] DECL: (standard_time_addhours)            DECLARE {REF UNDEFINED $result,REF UNDEFINED self,INTEGER hours} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):96:30: "  time addminutes(int minutes)"
[P] Parsed sentence: [FunDecl] ty(time) id(addminutes) pu(() ty(int) id(minutes) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;time addminutes(int minutes)
[Y] Store OFUN[27]: name=addminutes Kind=2 SupTypIndex=14 SubScope=1 Address=0 TypIndex=14 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[172]: name=addminutes kind=Member returns=time void=no nested=no subscope={Pub:time}
[Y] Store OPAR[96]: name=$result TypIndex=14 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=27
[D] PAR[285]: function=addminutes name=$result type=time order=0 const=no ref=yes
[Y] Store OPAR[97]: name=self TypIndex=14 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=27
[D] PAR[286]: function=addminutes name=self type=time order=1 const=no ref=yes
[Y] Store OPAR[98]: name=minutes TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=27
[D] PAR[287]: function=addminutes name=minutes type=int order=2 const=no ref=no
[I] FUN: name=standard.time.addminutes(int) index=172 searchindex=120, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.time.addminutes($cvint) index=172 searchindex=14, scope={Pub:main}, scope={Pub:main}
[D] FID[172]: name=addminutes kind=2 fullname=standard.time.addminutes(int) id=standard_time_addminutes
[Y] Update OFUN[27]: ParmNr=3 ParmLow=96 ParmHigh=98
[A] DECL: (standard_time_addminutes)          DECLARE {REF UNDEFINED $result,REF UNDEFINED self,INTEGER minutes} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):97:30: "  time addseconds(int seconds)"
[P] Parsed sentence: [FunDecl] ty(time) id(addseconds) pu(() ty(int) id(seconds) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;time addseconds(int seconds)
[Y] Store OFUN[28]: name=addseconds Kind=2 SupTypIndex=14 SubScope=1 Address=0 TypIndex=14 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[173]: name=addseconds kind=Member returns=time void=no nested=no subscope={Pub:time}
[Y] Store OPAR[99]: name=$result TypIndex=14 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=28
[D] PAR[288]: function=addseconds name=$result type=time order=0 const=no ref=yes
[Y] Store OPAR[100]: name=self TypIndex=14 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=28
[D] PAR[289]: function=addseconds name=self type=time order=1 const=no ref=yes
[Y] Store OPAR[101]: name=seconds TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=28
[D] PAR[290]: function=addseconds name=seconds type=int order=2 const=no ref=no
[I] FUN: name=standard.time.addseconds(int) index=173 searchindex=121, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.time.addseconds($cvint) index=173 searchindex=15, scope={Pub:main}, scope={Pub:main}
[D] FID[173]: name=addseconds kind=2 fullname=standard.time.addseconds(int) id=standard_time_addseconds
[Y] Update OFUN[28]: ParmNr=3 ParmLow=99 ParmHigh=101
[A] DECL: (standard_time_addseconds)          DECLARE {REF UNDEFINED $result,REF UNDEFINED self,INTEGER seconds} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):98:35: "  time addmillisecs(long millisecs)"
[P] Parsed sentence: [FunDecl] ty(time) id(addmillisecs) pu(() ty(long) id(millisecs) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;time addmillisecs(long millisecs)
[Y] Store OFUN[29]: name=addmillisecs Kind=2 SupTypIndex=14 SubScope=1 Address=0 TypIndex=14 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[174]: name=addmillisecs kind=Member returns=time void=no nested=no subscope={Pub:time}
[Y] Store OPAR[102]: name=$result TypIndex=14 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=29
[D] PAR[291]: function=addmillisecs name=$result type=time order=0 const=no ref=yes
[Y] Store OPAR[103]: name=self TypIndex=14 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=29
[D] PAR[292]: function=addmillisecs name=self type=time order=1 const=no ref=yes
[Y] Store OPAR[104]: name=millisecs TypIndex=4 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=29
[D] PAR[293]: function=addmillisecs name=millisecs type=long order=2 const=no ref=no
[I] FUN: name=standard.time.addmillisecs(long) index=174 searchindex=120, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.time.addmillisecs($cvint) index=174 searchindex=14, scope={Pub:main}, scope={Pub:main}
[D] FID[174]: name=addmillisecs kind=2 fullname=standard.time.addmillisecs(long) id=standard_time_addmillisecs
[Y] Update OFUN[29]: ParmNr=3 ParmLow=102 ParmHigh=104
[A] DECL: (standard_time_addmillisecs)        DECLARE {REF UNDEFINED $result,REF UNDEFINED self,LONG millisecs} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):99:35: "  time addmicrosecs(long microsecs)"
[P] Parsed sentence: [FunDecl] ty(time) id(addmicrosecs) pu(() ty(long) id(microsecs) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;time addmicrosecs(long microsecs)
[Y] Store OFUN[30]: name=addmicrosecs Kind=2 SupTypIndex=14 SubScope=1 Address=0 TypIndex=14 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[175]: name=addmicrosecs kind=Member returns=time void=no nested=no subscope={Pub:time}
[Y] Store OPAR[105]: name=$result TypIndex=14 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=30
[D] PAR[294]: function=addmicrosecs name=$result type=time order=0 const=no ref=yes
[Y] Store OPAR[106]: name=self TypIndex=14 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=30
[D] PAR[295]: function=addmicrosecs name=self type=time order=1 const=no ref=yes
[Y] Store OPAR[107]: name=microsecs TypIndex=4 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=30
[D] PAR[296]: function=addmicrosecs name=microsecs type=long order=2 const=no ref=no
[I] FUN: name=standard.time.addmicrosecs(long) index=175 searchindex=120, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.time.addmicrosecs($cvint) index=175 searchindex=14, scope={Pub:main}, scope={Pub:main}
[D] FID[175]: name=addmicrosecs kind=2 fullname=standard.time.addmicrosecs(long) id=standard_time_addmicrosecs
[Y] Update OFUN[30]: ParmNr=3 ParmLow=105 ParmHigh=107
[A] DECL: (standard_time_addmicrosecs)        DECLARE {REF UNDEFINED $result,REF UNDEFINED self,LONG microsecs} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):100:33: "  time addnanosecs(long nanosecs)"
[P] Parsed sentence: [FunDecl] ty(time) id(addnanosecs) pu(() ty(long) id(nanosecs) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;time addnanosecs(long nanosecs)
[Y] Store OFUN[31]: name=addnanosecs Kind=2 SupTypIndex=14 SubScope=1 Address=0 TypIndex=14 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[176]: name=addnanosecs kind=Member returns=time void=no nested=no subscope={Pub:time}
[Y] Store OPAR[108]: name=$result TypIndex=14 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=31
[D] PAR[297]: function=addnanosecs name=$result type=time order=0 const=no ref=yes
[Y] Store OPAR[109]: name=self TypIndex=14 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=31
[D] PAR[298]: function=addnanosecs name=self type=time order=1 const=no ref=yes
[Y] Store OPAR[110]: name=nanosecs TypIndex=4 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=31
[D] PAR[299]: function=addnanosecs name=nanosecs type=long order=2 const=no ref=no
[I] FUN: name=standard.time.addnanosecs(long) index=176 searchindex=123, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.time.addnanosecs($cvint) index=176 searchindex=17, scope={Pub:main}, scope={Pub:main}
[D] FID[176]: name=addnanosecs kind=2 fullname=standard.time.addnanosecs(long) id=standard_time_addnanosecs
[Y] Update OFUN[31]: ParmNr=3 ParmLow=108 ParmHigh=110
[A] DECL: (standard_time_addnanosecs)         DECLARE {REF UNDEFINED $result,REF UNDEFINED self,LONG nanosecs} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):101:16: "  string tostr()"
[P] Parsed sentence: [FunDecl] ty(string) id(tostr) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;string tostr()
[Y] Store OFUN[32]: name=tostr Kind=2 SupTypIndex=14 SubScope=1 Address=0 TypIndex=6 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[177]: name=tostr kind=Member returns=string void=no nested=no subscope={Pub:time}
[Y] Store OPAR[111]: name=$result TypIndex=6 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=32
[D] PAR[300]: function=tostr name=$result type=string order=0 const=no ref=yes
[Y] Store OPAR[112]: name=self TypIndex=14 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=32
[D] PAR[301]: function=tostr name=self type=time order=1 const=no ref=yes
[I] FUN: name=standard.time.tostr() index=177 searchindex=135, scope={Pub:main}, scope={Pub:main}
[D] FID[177]: name=tostr kind=2 fullname=standard.time.tostr() id=standard_time_tostr
[Y] Update OFUN[32]: ParmNr=1 ParmLow=111 ParmHigh=112
[A] DECL: (standard_time_tostr)               DECLARE {REF STRINGBLOCK $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):102:26: "  string tostr(char delim)"
[P] Parsed sentence: [FunDecl] ty(string) id(tostr) pu(() ty(char) id(delim) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;string tostr(char delim)
[Y] Store OFUN[33]: name=tostr Kind=2 SupTypIndex=14 SubScope=1 Address=0 TypIndex=6 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[178]: name=tostr kind=Member returns=string void=no nested=no subscope={Pub:time}
[Y] Store OPAR[113]: name=$result TypIndex=6 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=33
[D] PAR[302]: function=tostr name=$result type=string order=0 const=no ref=yes
[Y] Store OPAR[114]: name=self TypIndex=14 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=33
[D] PAR[303]: function=tostr name=self type=time order=1 const=no ref=yes
[Y] Store OPAR[115]: name=delim TypIndex=1 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=33
[D] PAR[304]: function=tostr name=delim type=char order=2 const=no ref=no
[I] FUN: name=standard.time.tostr(char) index=178 searchindex=136, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.time.tostr($cvint) index=178 searchindex=23, scope={Pub:main}, scope={Pub:main}
[D] FID[178]: name=tostr kind=2 fullname=standard.time.tostr(char) id=standard_time_tostr2
[Y] Update OFUN[33]: ParmNr=3 ParmLow=113 ParmHigh=115
[A] DECL: (standard_time_tostr2)              DECLARE {REF STRINGBLOCK $result,REF UNDEFINED self,CHAR delim} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):103:7: "  .priv"
[P] Parsed sentence: [Priv] kw(.priv)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[S] Subscope end: {Pub:time}
[S] Subscope begin: {Pri:time}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):104:10: "  long _tm"
[P] Parsed sentence: [VarDecl] ty(long) id(_tm)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;long _tm
[D] FLD[19]: type=long name=_tm subscope={Pri:time} offset=0 static=no enumvalue=0
[P] -------------------------------------------------------------------------------------
[L] Read line (src):105:20: "  allow [+]() to _tm"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(+) pu(]) pu(() pu()) kw(to) id(_tm)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[8]: name=OPFI:[+]()->standard.time._tm
[I] GRA: name=OPFI:[+]()->standard.time._tm index=8 searchindex=2, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):106:20: "  allow [-]() to _tm"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(-) pu(]) pu(() pu()) kw(to) id(_tm)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[9]: name=OPFI:[-]()->standard.time._tm
[I] GRA: name=OPFI:[-]()->standard.time._tm index=9 searchindex=4, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):107:21: "  allow [==]() to _tm"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(==) pu(]) pu(() pu()) kw(to) id(_tm)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[10]: name=OPFI:[==]()->standard.time._tm
[I] GRA: name=OPFI:[==]()->standard.time._tm index=10 searchindex=8, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):108:21: "  allow [!=]() to _tm"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(!=) pu(]) pu(() pu()) kw(to) id(_tm)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[11]: name=OPFI:[!=]()->standard.time._tm
[I] GRA: name=OPFI:[!=]()->standard.time._tm index=11 searchindex=1, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):109:20: "  allow [<]() to _tm"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(<) pu(]) pu(() pu()) kw(to) id(_tm)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[12]: name=OPFI:[<]()->standard.time._tm
[I] GRA: name=OPFI:[<]()->standard.time._tm index=12 searchindex=8, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):110:20: "  allow [>]() to _tm"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(>) pu(]) pu(() pu()) kw(to) id(_tm)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[13]: name=OPFI:[>]()->standard.time._tm
[I] GRA: name=OPFI:[>]()->standard.time._tm index=13 searchindex=13, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):111:21: "  allow [<=]() to _tm"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(<=) pu(]) pu(() pu()) kw(to) id(_tm)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[14]: name=OPFI:[<=]()->standard.time._tm
[I] GRA: name=OPFI:[<=]()->standard.time._tm index=14 searchindex=7, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):112:21: "  allow [>=]() to _tm"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(>=) pu(]) pu(() pu()) kw(to) id(_tm)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[15]: name=OPFI:[>=]()->standard.time._tm
[I] GRA: name=OPFI:[>=]()->standard.time._tm index=15 searchindex=13, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):113:6: ":class"
[P] Parsed sentence: [EndClass] kw(:class)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000000h, LocBlk=00000049h
[O] Relocation added: Type=BlkInsideGlo, LocAdr=00000000000000C8h
[A] DATA:                                     STORE {"_tm"                                                    ;Address=[00000000000000C8h]
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000000h, LocBlk=0000004Bh
[O] Relocation added: Type=BlkInsideGlo, LocAdr=00000000000000CCh
[A] DATA:                                     STORE {"long"                                                   ;Address=[00000000000000CCh]
[Y] Update OTYP[14]: MetaStNames=200 MetaStTypes=204 Length=8 FieldLow=-1 FieldHigh=-1
[S] Subscope end: {Pri:time}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):116:15: "class datetime:"
[P] Parsed sentence: [DefClass] kw(class) id(datetime) pu(:)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[O] Relocation added: Type=BlkInsideGlo, LocAdr=00000000000000D0h
[A] DATA:                                     STORE "datetime"                                                ;Address=[00000000000000D0h]
[Y] Store OTYP[15]: name=datetime msttype=8 FunIndex=-1 SupTypIndex=-1 IsTypedef=0 IsSystemDef=0 Length=0 DimNr=0 ElemTypIndex=-1 DimIndex=-1 FieldLow=-1 FieldHigh=-1
[D] TYP[15]: name=datetime msttype=class scope={Pub:main} typedef=no systemdef=no length=0
[I] TYP: name=standard.datetime index=15 searchindex=4, scope={Pub:main}
[S] Subscope begin: {Pub:datetime}
[P] Updated parser type list: bool,char,date,datetime,errorcode,filemode,float,hostsys,int,long,short,string,time,word
[P] -------------------------------------------------------------------------------------
[L] Read line (src):117:7: "  .publ"
[P] Parsed sentence: [Publ] kw(.publ)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):118:38: "  datetime(int year,int month,int day)"
[P] Parsed sentence: [FunDecl] ty(datetime) pu(() ty(int) id(year) pu(,) ty(int) id(month) pu(,) ty(int) id(day) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;datetime(int year,int month,int day)
[Y] Store OFUN[34]: name=datetime Kind=2 SupTypIndex=15 SubScope=1 Address=0 TypIndex=15 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[179]: name=datetime kind=Member returns=datetime void=no nested=no subscope={Pub:datetime}
[Y] Store OPAR[116]: name=$result TypIndex=15 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=34
[D] PAR[305]: function=datetime name=$result type=datetime order=0 const=no ref=yes
[Y] Store OPAR[117]: name=self TypIndex=15 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=34
[D] PAR[306]: function=datetime name=self type=datetime order=1 const=no ref=yes
[Y] Store OPAR[118]: name=year TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=34
[D] PAR[307]: function=datetime name=year type=int order=2 const=no ref=no
[Y] Store OPAR[119]: name=month TypIndex=3 IsConst=0 IsReference=0 ParmOrder=3 FunIndex=34
[D] PAR[308]: function=datetime name=month type=int order=3 const=no ref=no
[Y] Store OPAR[120]: name=day TypIndex=3 IsConst=0 IsReference=0 ParmOrder=4 FunIndex=34
[D] PAR[309]: function=datetime name=day type=int order=4 const=no ref=no
[I] FUN: name=standard.datetime.datetime(int,int,int) index=179 searchindex=119, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.datetime.datetime($cvint,$cvint,$cvint) index=179 searchindex=13, scope={Pub:main}, scope={Pub:main}
[D] FID[179]: name=datetime kind=2 fullname=standard.datetime.datetime(int,int,int) id=standard_datetime_datetime
[Y] Update OFUN[34]: ParmNr=5 ParmLow=116 ParmHigh=120
[A] DECL: (standard_datetime_datetime)        DECLARE {REF UNDEFINED $result,REF UNDEFINED self,INTEGER year,INTEGER month,INTEGER day} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):119:69: "  datetime(int year,int month,int day,int hour,int minute,int second)"
[P] Parsed sentence: [FunDecl] ty(datetime) pu(() ty(int) id(year) pu(,) ty(int) id(month) pu(,) ty(int) id(day) pu(,) ty(int) id(hour) pu(,) ty(int) id(minute) pu(,) ty(int) id(second) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;datetime(int year,int month,int day,int hour,int minute,int second)
[Y] Store OFUN[35]: name=datetime Kind=2 SupTypIndex=15 SubScope=1 Address=0 TypIndex=15 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[180]: name=datetime kind=Member returns=datetime void=no nested=no subscope={Pub:datetime}
[Y] Store OPAR[121]: name=$result TypIndex=15 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=35
[D] PAR[310]: function=datetime name=$result type=datetime order=0 const=no ref=yes
[Y] Store OPAR[122]: name=self TypIndex=15 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=35
[D] PAR[311]: function=datetime name=self type=datetime order=1 const=no ref=yes
[Y] Store OPAR[123]: name=year TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=35
[D] PAR[312]: function=datetime name=year type=int order=2 const=no ref=no
[Y] Store OPAR[124]: name=month TypIndex=3 IsConst=0 IsReference=0 ParmOrder=3 FunIndex=35
[D] PAR[313]: function=datetime name=month type=int order=3 const=no ref=no
[Y] Store OPAR[125]: name=day TypIndex=3 IsConst=0 IsReference=0 ParmOrder=4 FunIndex=35
[D] PAR[314]: function=datetime name=day type=int order=4 const=no ref=no
[Y] Store OPAR[126]: name=hour TypIndex=3 IsConst=0 IsReference=0 ParmOrder=5 FunIndex=35
[D] PAR[315]: function=datetime name=hour type=int order=5 const=no ref=no
[Y] Store OPAR[127]: name=minute TypIndex=3 IsConst=0 IsReference=0 ParmOrder=6 FunIndex=35
[D] PAR[316]: function=datetime name=minute type=int order=6 const=no ref=no
[Y] Store OPAR[128]: name=second TypIndex=3 IsConst=0 IsReference=0 ParmOrder=7 FunIndex=35
[D] PAR[317]: function=datetime name=second type=int order=7 const=no ref=no
[I] FUN: name=standard.datetime.datetime(int,int,int,int,int,int) index=180 searchindex=120, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.datetime.datetime($cvint,$cvint,$cvint,$cvint,$cvint,$cvint) index=180 searchindex=14, scope={Pub:main}, scope={Pub:main}
[D] FID[180]: name=datetime kind=2 fullname=standard.datetime.datetime(int,int,int,int,int,int) id=standard_datetime_datetime2
[Y] Update OFUN[35]: ParmNr=8 ParmLow=121 ParmHigh=128
[A] DECL: (standard_datetime_datetime2)       DECLARE {REF UNDEFINED $result,REF UNDEFINED self,INTEGER year,INTEGER month,INTEGER day,INTEGER hour,INTEGER minute,INTEGER second} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):120:82: "  datetime(int year,int month,int day,int hour,int minute,int second,int millisec)"
[P] Parsed sentence: [FunDecl] ty(datetime) pu(() ty(int) id(year) pu(,) ty(int) id(month) pu(,) ty(int) id(day) pu(,) ty(int) id(hour) pu(,) ty(int) id(minute) pu(,) ty(int) id(second) pu(,) ty(int) id(millisec) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;datetime(int year,int month,int day,int hour,int minute,int second,int millisec)
[Y] Store OFUN[36]: name=datetime Kind=2 SupTypIndex=15 SubScope=1 Address=0 TypIndex=15 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[181]: name=datetime kind=Member returns=datetime void=no nested=no subscope={Pub:datetime}
[Y] Store OPAR[129]: name=$result TypIndex=15 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=36
[D] PAR[318]: function=datetime name=$result type=datetime order=0 const=no ref=yes
[Y] Store OPAR[130]: name=self TypIndex=15 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=36
[D] PAR[319]: function=datetime name=self type=datetime order=1 const=no ref=yes
[Y] Store OPAR[131]: name=year TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=36
[D] PAR[320]: function=datetime name=year type=int order=2 const=no ref=no
[Y] Store OPAR[132]: name=month TypIndex=3 IsConst=0 IsReference=0 ParmOrder=3 FunIndex=36
[D] PAR[321]: function=datetime name=month type=int order=3 const=no ref=no
[Y] Store OPAR[133]: name=day TypIndex=3 IsConst=0 IsReference=0 ParmOrder=4 FunIndex=36
[D] PAR[322]: function=datetime name=day type=int order=4 const=no ref=no
[Y] Store OPAR[134]: name=hour TypIndex=3 IsConst=0 IsReference=0 ParmOrder=5 FunIndex=36
[D] PAR[323]: function=datetime name=hour type=int order=5 const=no ref=no
[Y] Store OPAR[135]: name=minute TypIndex=3 IsConst=0 IsReference=0 ParmOrder=6 FunIndex=36
[D] PAR[324]: function=datetime name=minute type=int order=6 const=no ref=no
[Y] Store OPAR[136]: name=second TypIndex=3 IsConst=0 IsReference=0 ParmOrder=7 FunIndex=36
[D] PAR[325]: function=datetime name=second type=int order=7 const=no ref=no
[Y] Store OPAR[137]: name=millisec TypIndex=3 IsConst=0 IsReference=0 ParmOrder=8 FunIndex=36
[D] PAR[326]: function=datetime name=millisec type=int order=8 const=no ref=no
[I] FUN: name=standard.datetime.datetime(int,int,int,int,int,int,int) index=181 searchindex=121, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.datetime.datetime($cvint,$cvint,$cvint,$cvint,$cvint,$cvint,$cvint) index=181 searchindex=15, scope={Pub:main}, scope={Pub:main}
[D] FID[181]: name=datetime kind=2 fullname=standard.datetime.datetime(int,int,int,int,int,int,int) id=standard_datetime_datetime3
[Y] Update OFUN[36]: ParmNr=9 ParmLow=129 ParmHigh=137
[A] DECL: (standard_datetime_datetime3)       DECLARE {REF UNDEFINED $result,REF UNDEFINED self,INTEGER year,INTEGER month,INTEGER day,INTEGER hour,INTEGER minute,INTEGER second,INTEGER millisec} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):121:95: "  datetime(int year,int month,int day,int hour,int minute,int second,int millisec,int microsec)"
[P] Parsed sentence: [FunDecl] ty(datetime) pu(() ty(int) id(year) pu(,) ty(int) id(month) pu(,) ty(int) id(day) pu(,) ty(int) id(hour) pu(,) ty(int) id(minute) pu(,) ty(int) id(second) pu(,) ty(int) id(millisec) pu(,) ty(int) id(microsec) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;datetime(int year,int month,int day,int hour,int minute,int second,int millisec,int microsec)
[Y] Store OFUN[37]: name=datetime Kind=2 SupTypIndex=15 SubScope=1 Address=0 TypIndex=15 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[182]: name=datetime kind=Member returns=datetime void=no nested=no subscope={Pub:datetime}
[Y] Store OPAR[138]: name=$result TypIndex=15 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=37
[D] PAR[327]: function=datetime name=$result type=datetime order=0 const=no ref=yes
[Y] Store OPAR[139]: name=self TypIndex=15 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=37
[D] PAR[328]: function=datetime name=self type=datetime order=1 const=no ref=yes
[Y] Store OPAR[140]: name=year TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=37
[D] PAR[329]: function=datetime name=year type=int order=2 const=no ref=no
[Y] Store OPAR[141]: name=month TypIndex=3 IsConst=0 IsReference=0 ParmOrder=3 FunIndex=37
[D] PAR[330]: function=datetime name=month type=int order=3 const=no ref=no
[Y] Store OPAR[142]: name=day TypIndex=3 IsConst=0 IsReference=0 ParmOrder=4 FunIndex=37
[D] PAR[331]: function=datetime name=day type=int order=4 const=no ref=no
[Y] Store OPAR[143]: name=hour TypIndex=3 IsConst=0 IsReference=0 ParmOrder=5 FunIndex=37
[D] PAR[332]: function=datetime name=hour type=int order=5 const=no ref=no
[Y] Store OPAR[144]: name=minute TypIndex=3 IsConst=0 IsReference=0 ParmOrder=6 FunIndex=37
[D] PAR[333]: function=datetime name=minute type=int order=6 const=no ref=no
[Y] Store OPAR[145]: name=second TypIndex=3 IsConst=0 IsReference=0 ParmOrder=7 FunIndex=37
[D] PAR[334]: function=datetime name=second type=int order=7 const=no ref=no
[Y] Store OPAR[146]: name=millisec TypIndex=3 IsConst=0 IsReference=0 ParmOrder=8 FunIndex=37
[D] PAR[335]: function=datetime name=millisec type=int order=8 const=no ref=no
[Y] Store OPAR[147]: name=microsec TypIndex=3 IsConst=0 IsReference=0 ParmOrder=9 FunIndex=37
[D] PAR[336]: function=datetime name=microsec type=int order=9 const=no ref=no
[I] FUN: name=standard.datetime.datetime(int,int,int,int,int,int,int,int) index=182 searchindex=122, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.datetime.datetime($cvint,$cvint,$cvint,$cvint,$cvint,$cvint,$cvint,$cvint) index=182 searchindex=16, scope={Pub:main}, scope={Pub:main}
[D] FID[182]: name=datetime kind=2 fullname=standard.datetime.datetime(int,int,int,int,int,int,int,int) id=standard_datetime_datetime4
[Y] Update OFUN[37]: ParmNr=10 ParmLow=138 ParmHigh=147
[A] DECL: (standard_datetime_datetime4)       DECLARE {REF UNDEFINED $result,REF UNDEFINED self,INTEGER year,INTEGER month,INTEGER day,INTEGER hour,INTEGER minute,INTEGER second,INTEGER millisec,INTEGER microsec} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):122:107: "  datetime(int year,int month,int day,int hour,int minute,int second,int millisec,int microsec,int nanosec)"
[P] Parsed sentence: [FunDecl] ty(datetime) pu(() ty(int) id(year) pu(,) ty(int) id(month) pu(,) ty(int) id(day) pu(,) ty(int) id(hour) pu(,) ty(int) id(minute) pu(,) ty(int) id(second) pu(,) ty(int) id(millisec) pu(,) ty(int) id(microsec) pu(,) ty(int) id(nanosec) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;datetime(int year,int month,int day,int hour,int minute,int second,int millisec,int microsec,int nanosec)
[Y] Store OFUN[38]: name=datetime Kind=2 SupTypIndex=15 SubScope=1 Address=0 TypIndex=15 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[183]: name=datetime kind=Member returns=datetime void=no nested=no subscope={Pub:datetime}
[Y] Store OPAR[148]: name=$result TypIndex=15 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=38
[D] PAR[337]: function=datetime name=$result type=datetime order=0 const=no ref=yes
[Y] Store OPAR[149]: name=self TypIndex=15 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=38
[D] PAR[338]: function=datetime name=self type=datetime order=1 const=no ref=yes
[Y] Store OPAR[150]: name=year TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=38
[D] PAR[339]: function=datetime name=year type=int order=2 const=no ref=no
[Y] Store OPAR[151]: name=month TypIndex=3 IsConst=0 IsReference=0 ParmOrder=3 FunIndex=38
[D] PAR[340]: function=datetime name=month type=int order=3 const=no ref=no
[Y] Store OPAR[152]: name=day TypIndex=3 IsConst=0 IsReference=0 ParmOrder=4 FunIndex=38
[D] PAR[341]: function=datetime name=day type=int order=4 const=no ref=no
[Y] Store OPAR[153]: name=hour TypIndex=3 IsConst=0 IsReference=0 ParmOrder=5 FunIndex=38
[D] PAR[342]: function=datetime name=hour type=int order=5 const=no ref=no
[Y] Store OPAR[154]: name=minute TypIndex=3 IsConst=0 IsReference=0 ParmOrder=6 FunIndex=38
[D] PAR[343]: function=datetime name=minute type=int order=6 const=no ref=no
[Y] Store OPAR[155]: name=second TypIndex=3 IsConst=0 IsReference=0 ParmOrder=7 FunIndex=38
[D] PAR[344]: function=datetime name=second type=int order=7 const=no ref=no
[Y] Store OPAR[156]: name=millisec TypIndex=3 IsConst=0 IsReference=0 ParmOrder=8 FunIndex=38
[D] PAR[345]: function=datetime name=millisec type=int order=8 const=no ref=no
[Y] Store OPAR[157]: name=microsec TypIndex=3 IsConst=0 IsReference=0 ParmOrder=9 FunIndex=38
[D] PAR[346]: function=datetime name=microsec type=int order=9 const=no ref=no
[Y] Store OPAR[158]: name=nanosec TypIndex=3 IsConst=0 IsReference=0 ParmOrder=10 FunIndex=38
[D] PAR[347]: function=datetime name=nanosec type=int order=10 const=no ref=no
[I] FUN: name=standard.datetime.datetime(int,int,int,int,int,int,int,int,int) index=183 searchindex=123, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.datetime.datetime($cvint,$cvint,$cvint,$cvint,$cvint,$cvint,$cvint,$cvint,$cvint) index=183 searchindex=17, scope={Pub:main}, scope={Pub:main}
[D] FID[183]: name=datetime kind=2 fullname=standard.datetime.datetime(int,int,int,int,int,int,int,int,int) id=standard_datetime_datetime5
[Y] Update OFUN[38]: ParmNr=11 ParmLow=148 ParmHigh=158
[A] DECL: (standard_datetime_datetime5)       DECLARE {REF UNDEFINED $result,REF UNDEFINED self,INTEGER year,INTEGER month,INTEGER day,INTEGER hour,INTEGER minute,INTEGER second,INTEGER millisec,INTEGER microsec,INTEGER nanosec} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):123:40: "  void value(int year,int month,int day)"
[P] Parsed sentence: [FunDecl] kw(void) id(value) pu(() ty(int) id(year) pu(,) ty(int) id(month) pu(,) ty(int) id(day) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;void value(int year,int month,int day)
[Y] Store OFUN[39]: name=value Kind=2 SupTypIndex=15 SubScope=1 Address=0 TypIndex=-1 IsVoid=1 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[184]: name=value kind=Member returns=undefined void=yes nested=no subscope={Pub:datetime}
[Y] Store OPAR[159]: name=self TypIndex=15 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=39
[D] PAR[348]: function=value name=self type=datetime order=0 const=no ref=yes
[Y] Store OPAR[160]: name=year TypIndex=3 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=39
[D] PAR[349]: function=value name=year type=int order=1 const=no ref=no
[Y] Store OPAR[161]: name=month TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=39
[D] PAR[350]: function=value name=month type=int order=2 const=no ref=no
[Y] Store OPAR[162]: name=day TypIndex=3 IsConst=0 IsReference=0 ParmOrder=3 FunIndex=39
[D] PAR[351]: function=value name=day type=int order=3 const=no ref=no
[I] FUN: name=standard.datetime.value(int,int,int) index=184 searchindex=124, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.datetime.value($cvint,$cvint,$cvint) index=184 searchindex=18, scope={Pub:main}, scope={Pub:main}
[D] FID[184]: name=value kind=2 fullname=standard.datetime.value(int,int,int) id=standard_datetime_value
[Y] Update OFUN[39]: ParmNr=4 ParmLow=159 ParmHigh=162
[A] DECL: (standard_datetime_value)           DECLARE {REF UNDEFINED self,INTEGER year,INTEGER month,INTEGER day} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):124:71: "  void value(int year,int month,int day,int hour,int minute,int second)"
[P] Parsed sentence: [FunDecl] kw(void) id(value) pu(() ty(int) id(year) pu(,) ty(int) id(month) pu(,) ty(int) id(day) pu(,) ty(int) id(hour) pu(,) ty(int) id(minute) pu(,) ty(int) id(second) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;void value(int year,int month,int day,int hour,int minute,int second)
[Y] Store OFUN[40]: name=value Kind=2 SupTypIndex=15 SubScope=1 Address=0 TypIndex=-1 IsVoid=1 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[185]: name=value kind=Member returns=undefined void=yes nested=no subscope={Pub:datetime}
[Y] Store OPAR[163]: name=self TypIndex=15 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=40
[D] PAR[352]: function=value name=self type=datetime order=0 const=no ref=yes
[Y] Store OPAR[164]: name=year TypIndex=3 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=40
[D] PAR[353]: function=value name=year type=int order=1 const=no ref=no
[Y] Store OPAR[165]: name=month TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=40
[D] PAR[354]: function=value name=month type=int order=2 const=no ref=no
[Y] Store OPAR[166]: name=day TypIndex=3 IsConst=0 IsReference=0 ParmOrder=3 FunIndex=40
[D] PAR[355]: function=value name=day type=int order=3 const=no ref=no
[Y] Store OPAR[167]: name=hour TypIndex=3 IsConst=0 IsReference=0 ParmOrder=4 FunIndex=40
[D] PAR[356]: function=value name=hour type=int order=4 const=no ref=no
[Y] Store OPAR[168]: name=minute TypIndex=3 IsConst=0 IsReference=0 ParmOrder=5 FunIndex=40
[D] PAR[357]: function=value name=minute type=int order=5 const=no ref=no
[Y] Store OPAR[169]: name=second TypIndex=3 IsConst=0 IsReference=0 ParmOrder=6 FunIndex=40
[D] PAR[358]: function=value name=second type=int order=6 const=no ref=no
[I] FUN: name=standard.datetime.value(int,int,int,int,int,int) index=185 searchindex=125, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.datetime.value($cvint,$cvint,$cvint,$cvint,$cvint,$cvint) index=185 searchindex=19, scope={Pub:main}, scope={Pub:main}
[D] FID[185]: name=value kind=2 fullname=standard.datetime.value(int,int,int,int,int,int) id=standard_datetime_value2
[Y] Update OFUN[40]: ParmNr=7 ParmLow=163 ParmHigh=169
[A] DECL: (standard_datetime_value2)          DECLARE {REF UNDEFINED self,INTEGER year,INTEGER month,INTEGER day,INTEGER hour,INTEGER minute,INTEGER second} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):125:84: "  void value(int year,int month,int day,int hour,int minute,int second,int millisec)"
[P] Parsed sentence: [FunDecl] kw(void) id(value) pu(() ty(int) id(year) pu(,) ty(int) id(month) pu(,) ty(int) id(day) pu(,) ty(int) id(hour) pu(,) ty(int) id(minute) pu(,) ty(int) id(second) pu(,) ty(int) id(millisec) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;void value(int year,int month,int day,int hour,int minute,int second,int millisec)
[Y] Store OFUN[41]: name=value Kind=2 SupTypIndex=15 SubScope=1 Address=0 TypIndex=-1 IsVoid=1 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[186]: name=value kind=Member returns=undefined void=yes nested=no subscope={Pub:datetime}
[Y] Store OPAR[170]: name=self TypIndex=15 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=41
[D] PAR[359]: function=value name=self type=datetime order=0 const=no ref=yes
[Y] Store OPAR[171]: name=year TypIndex=3 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=41
[D] PAR[360]: function=value name=year type=int order=1 const=no ref=no
[Y] Store OPAR[172]: name=month TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=41
[D] PAR[361]: function=value name=month type=int order=2 const=no ref=no
[Y] Store OPAR[173]: name=day TypIndex=3 IsConst=0 IsReference=0 ParmOrder=3 FunIndex=41
[D] PAR[362]: function=value name=day type=int order=3 const=no ref=no
[Y] Store OPAR[174]: name=hour TypIndex=3 IsConst=0 IsReference=0 ParmOrder=4 FunIndex=41
[D] PAR[363]: function=value name=hour type=int order=4 const=no ref=no
[Y] Store OPAR[175]: name=minute TypIndex=3 IsConst=0 IsReference=0 ParmOrder=5 FunIndex=41
[D] PAR[364]: function=value name=minute type=int order=5 const=no ref=no
[Y] Store OPAR[176]: name=second TypIndex=3 IsConst=0 IsReference=0 ParmOrder=6 FunIndex=41
[D] PAR[365]: function=value name=second type=int order=6 const=no ref=no
[Y] Store OPAR[177]: name=millisec TypIndex=3 IsConst=0 IsReference=0 ParmOrder=7 FunIndex=41
[D] PAR[366]: function=value name=millisec type=int order=7 const=no ref=no
[I] FUN: name=standard.datetime.value(int,int,int,int,int,int,int) index=186 searchindex=126, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.datetime.value($cvint,$cvint,$cvint,$cvint,$cvint,$cvint,$cvint) index=186 searchindex=20, scope={Pub:main}, scope={Pub:main}
[D] FID[186]: name=value kind=2 fullname=standard.datetime.value(int,int,int,int,int,int,int) id=standard_datetime_value3
[Y] Update OFUN[41]: ParmNr=8 ParmLow=170 ParmHigh=177
[A] DECL: (standard_datetime_value3)          DECLARE {REF UNDEFINED self,INTEGER year,INTEGER month,INTEGER day,INTEGER hour,INTEGER minute,INTEGER second,INTEGER millisec} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):126:97: "  void value(int year,int month,int day,int hour,int minute,int second,int millisec,int microsec)"
[P] Parsed sentence: [FunDecl] kw(void) id(value) pu(() ty(int) id(year) pu(,) ty(int) id(month) pu(,) ty(int) id(day) pu(,) ty(int) id(hour) pu(,) ty(int) id(minute) pu(,) ty(int) id(second) pu(,) ty(int) id(millisec) pu(,) ty(int) id(microsec) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;void value(int year,int month,int day,int hour,int minute,int second,int millisec,int microsec)
[Y] Store OFUN[42]: name=value Kind=2 SupTypIndex=15 SubScope=1 Address=0 TypIndex=-1 IsVoid=1 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[187]: name=value kind=Member returns=undefined void=yes nested=no subscope={Pub:datetime}
[Y] Store OPAR[178]: name=self TypIndex=15 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=42
[D] PAR[367]: function=value name=self type=datetime order=0 const=no ref=yes
[Y] Store OPAR[179]: name=year TypIndex=3 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=42
[D] PAR[368]: function=value name=year type=int order=1 const=no ref=no
[Y] Store OPAR[180]: name=month TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=42
[D] PAR[369]: function=value name=month type=int order=2 const=no ref=no
[Y] Store OPAR[181]: name=day TypIndex=3 IsConst=0 IsReference=0 ParmOrder=3 FunIndex=42
[D] PAR[370]: function=value name=day type=int order=3 const=no ref=no
[Y] Store OPAR[182]: name=hour TypIndex=3 IsConst=0 IsReference=0 ParmOrder=4 FunIndex=42
[D] PAR[371]: function=value name=hour type=int order=4 const=no ref=no
[Y] Store OPAR[183]: name=minute TypIndex=3 IsConst=0 IsReference=0 ParmOrder=5 FunIndex=42
[D] PAR[372]: function=value name=minute type=int order=5 const=no ref=no
[Y] Store OPAR[184]: name=second TypIndex=3 IsConst=0 IsReference=0 ParmOrder=6 FunIndex=42
[D] PAR[373]: function=value name=second type=int order=6 const=no ref=no
[Y] Store OPAR[185]: name=millisec TypIndex=3 IsConst=0 IsReference=0 ParmOrder=7 FunIndex=42
[D] PAR[374]: function=value name=millisec type=int order=7 const=no ref=no
[Y] Store OPAR[186]: name=microsec TypIndex=3 IsConst=0 IsReference=0 ParmOrder=8 FunIndex=42
[D] PAR[375]: function=value name=microsec type=int order=8 const=no ref=no
[I] FUN: name=standard.datetime.value(int,int,int,int,int,int,int,int) index=187 searchindex=127, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.datetime.value($cvint,$cvint,$cvint,$cvint,$cvint,$cvint,$cvint,$cvint) index=187 searchindex=21, scope={Pub:main}, scope={Pub:main}
[D] FID[187]: name=value kind=2 fullname=standard.datetime.value(int,int,int,int,int,int,int,int) id=standard_datetime_value4
[Y] Update OFUN[42]: ParmNr=9 ParmLow=178 ParmHigh=186
[A] DECL: (standard_datetime_value4)          DECLARE {REF UNDEFINED self,INTEGER year,INTEGER month,INTEGER day,INTEGER hour,INTEGER minute,INTEGER second,INTEGER millisec,INTEGER microsec} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):127:109: "  void value(int year,int month,int day,int hour,int minute,int second,int millisec,int microsec,int nanosec)"
[P] Parsed sentence: [FunDecl] kw(void) id(value) pu(() ty(int) id(year) pu(,) ty(int) id(month) pu(,) ty(int) id(day) pu(,) ty(int) id(hour) pu(,) ty(int) id(minute) pu(,) ty(int) id(second) pu(,) ty(int) id(millisec) pu(,) ty(int) id(microsec) pu(,) ty(int) id(nanosec) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;void value(int year,int month,int day,int hour,int minute,int second,int millisec,int microsec,int nanosec)
[Y] Store OFUN[43]: name=value Kind=2 SupTypIndex=15 SubScope=1 Address=0 TypIndex=-1 IsVoid=1 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[188]: name=value kind=Member returns=undefined void=yes nested=no subscope={Pub:datetime}
[Y] Store OPAR[187]: name=self TypIndex=15 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=43
[D] PAR[376]: function=value name=self type=datetime order=0 const=no ref=yes
[Y] Store OPAR[188]: name=year TypIndex=3 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=43
[D] PAR[377]: function=value name=year type=int order=1 const=no ref=no
[Y] Store OPAR[189]: name=month TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=43
[D] PAR[378]: function=value name=month type=int order=2 const=no ref=no
[Y] Store OPAR[190]: name=day TypIndex=3 IsConst=0 IsReference=0 ParmOrder=3 FunIndex=43
[D] PAR[379]: function=value name=day type=int order=3 const=no ref=no
[Y] Store OPAR[191]: name=hour TypIndex=3 IsConst=0 IsReference=0 ParmOrder=4 FunIndex=43
[D] PAR[380]: function=value name=hour type=int order=4 const=no ref=no
[Y] Store OPAR[192]: name=minute TypIndex=3 IsConst=0 IsReference=0 ParmOrder=5 FunIndex=43
[D] PAR[381]: function=value name=minute type=int order=5 const=no ref=no
[Y] Store OPAR[193]: name=second TypIndex=3 IsConst=0 IsReference=0 ParmOrder=6 FunIndex=43
[D] PAR[382]: function=value name=second type=int order=6 const=no ref=no
[Y] Store OPAR[194]: name=millisec TypIndex=3 IsConst=0 IsReference=0 ParmOrder=7 FunIndex=43
[D] PAR[383]: function=value name=millisec type=int order=7 const=no ref=no
[Y] Store OPAR[195]: name=microsec TypIndex=3 IsConst=0 IsReference=0 ParmOrder=8 FunIndex=43
[D] PAR[384]: function=value name=microsec type=int order=8 const=no ref=no
[Y] Store OPAR[196]: name=nanosec TypIndex=3 IsConst=0 IsReference=0 ParmOrder=9 FunIndex=43
[D] PAR[385]: function=value name=nanosec type=int order=9 const=no ref=no
[I] FUN: name=standard.datetime.value(int,int,int,int,int,int,int,int,int) index=188 searchindex=128, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.datetime.value($cvint,$cvint,$cvint,$cvint,$cvint,$cvint,$cvint,$cvint,$cvint) index=188 searchindex=22, scope={Pub:main}, scope={Pub:main}
[D] FID[188]: name=value kind=2 fullname=standard.datetime.value(int,int,int,int,int,int,int,int,int) id=standard_datetime_value5
[Y] Update OFUN[43]: ParmNr=10 ParmLow=187 ParmHigh=196
[A] DECL: (standard_datetime_value5)          DECLARE {REF UNDEFINED self,INTEGER year,INTEGER month,INTEGER day,INTEGER hour,INTEGER minute,INTEGER second,INTEGER millisec,INTEGER microsec,INTEGER nanosec} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):128:12: "  int year()"
[P] Parsed sentence: [FunDecl] ty(int) id(year) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;int year()
[Y] Store OFUN[44]: name=year Kind=2 SupTypIndex=15 SubScope=1 Address=0 TypIndex=3 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[189]: name=year kind=Member returns=int void=no nested=no subscope={Pub:datetime}
[Y] Store OPAR[197]: name=$result TypIndex=3 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=44
[D] PAR[386]: function=year name=$result type=int order=0 const=no ref=yes
[Y] Store OPAR[198]: name=self TypIndex=15 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=44
[D] PAR[387]: function=year name=self type=datetime order=1 const=no ref=yes
[I] FUN: name=standard.datetime.year() index=189 searchindex=129, scope={Pub:main}, scope={Pub:main}
[D] FID[189]: name=year kind=2 fullname=standard.datetime.year() id=standard_datetime_year
[Y] Update OFUN[44]: ParmNr=1 ParmLow=197 ParmHigh=198
[A] DECL: (standard_datetime_year)            DECLARE {REF INTEGER $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):129:13: "  int month()"
[P] Parsed sentence: [FunDecl] ty(int) id(month) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;int month()
[Y] Store OFUN[45]: name=month Kind=2 SupTypIndex=15 SubScope=1 Address=0 TypIndex=3 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[190]: name=month kind=Member returns=int void=no nested=no subscope={Pub:datetime}
[Y] Store OPAR[199]: name=$result TypIndex=3 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=45
[D] PAR[388]: function=month name=$result type=int order=0 const=no ref=yes
[Y] Store OPAR[200]: name=self TypIndex=15 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=45
[D] PAR[389]: function=month name=self type=datetime order=1 const=no ref=yes
[I] FUN: name=standard.datetime.month() index=190 searchindex=124, scope={Pub:main}, scope={Pub:main}
[D] FID[190]: name=month kind=2 fullname=standard.datetime.month() id=standard_datetime_month
[Y] Update OFUN[45]: ParmNr=1 ParmLow=199 ParmHigh=200
[A] DECL: (standard_datetime_month)           DECLARE {REF INTEGER $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):130:11: "  int day()"
[P] Parsed sentence: [FunDecl] ty(int) id(day) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;int day()
[Y] Store OFUN[46]: name=day Kind=2 SupTypIndex=15 SubScope=1 Address=0 TypIndex=3 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[191]: name=day kind=Member returns=int void=no nested=no subscope={Pub:datetime}
[Y] Store OPAR[201]: name=$result TypIndex=3 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=46
[D] PAR[390]: function=day name=$result type=int order=0 const=no ref=yes
[Y] Store OPAR[202]: name=self TypIndex=15 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=46
[D] PAR[391]: function=day name=self type=datetime order=1 const=no ref=yes
[I] FUN: name=standard.datetime.day() index=191 searchindex=124, scope={Pub:main}, scope={Pub:main}
[D] FID[191]: name=day kind=2 fullname=standard.datetime.day() id=standard_datetime_day
[Y] Update OFUN[46]: ParmNr=1 ParmLow=201 ParmHigh=202
[A] DECL: (standard_datetime_day)             DECLARE {REF INTEGER $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):131:12: "  int hour()"
[P] Parsed sentence: [FunDecl] ty(int) id(hour) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;int hour()
[Y] Store OFUN[47]: name=hour Kind=2 SupTypIndex=15 SubScope=1 Address=0 TypIndex=3 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[192]: name=hour kind=Member returns=int void=no nested=no subscope={Pub:datetime}
[Y] Store OPAR[203]: name=$result TypIndex=3 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=47
[D] PAR[392]: function=hour name=$result type=int order=0 const=no ref=yes
[Y] Store OPAR[204]: name=self TypIndex=15 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=47
[D] PAR[393]: function=hour name=self type=datetime order=1 const=no ref=yes
[I] FUN: name=standard.datetime.hour() index=192 searchindex=125, scope={Pub:main}, scope={Pub:main}
[D] FID[192]: name=hour kind=2 fullname=standard.datetime.hour() id=standard_datetime_hour
[Y] Update OFUN[47]: ParmNr=1 ParmLow=203 ParmHigh=204
[A] DECL: (standard_datetime_hour)            DECLARE {REF INTEGER $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):132:14: "  int minute()"
[P] Parsed sentence: [FunDecl] ty(int) id(minute) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;int minute()
[Y] Store OFUN[48]: name=minute Kind=2 SupTypIndex=15 SubScope=1 Address=0 TypIndex=3 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[193]: name=minute kind=Member returns=int void=no nested=no subscope={Pub:datetime}
[Y] Store OPAR[205]: name=$result TypIndex=3 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=48
[D] PAR[394]: function=minute name=$result type=int order=0 const=no ref=yes
[Y] Store OPAR[206]: name=self TypIndex=15 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=48
[D] PAR[395]: function=minute name=self type=datetime order=1 const=no ref=yes
[I] FUN: name=standard.datetime.minute() index=193 searchindex=126, scope={Pub:main}, scope={Pub:main}
[D] FID[193]: name=minute kind=2 fullname=standard.datetime.minute() id=standard_datetime_minute
[Y] Update OFUN[48]: ParmNr=1 ParmLow=205 ParmHigh=206
[A] DECL: (standard_datetime_minute)          DECLARE {REF INTEGER $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):133:14: "  int second()"
[P] Parsed sentence: [FunDecl] ty(int) id(second) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;int second()
[Y] Store OFUN[49]: name=second Kind=2 SupTypIndex=15 SubScope=1 Address=0 TypIndex=3 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[194]: name=second kind=Member returns=int void=no nested=no subscope={Pub:datetime}
[Y] Store OPAR[207]: name=$result TypIndex=3 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=49
[D] PAR[396]: function=second name=$result type=int order=0 const=no ref=yes
[Y] Store OPAR[208]: name=self TypIndex=15 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=49
[D] PAR[397]: function=second name=self type=datetime order=1 const=no ref=yes
[I] FUN: name=standard.datetime.second() index=194 searchindex=128, scope={Pub:main}, scope={Pub:main}
[D] FID[194]: name=second kind=2 fullname=standard.datetime.second() id=standard_datetime_second
[Y] Update OFUN[49]: ParmNr=1 ParmLow=207 ParmHigh=208
[A] DECL: (standard_datetime_second)          DECLARE {REF INTEGER $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):134:16: "  int millisec()"
[P] Parsed sentence: [FunDecl] ty(int) id(millisec) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;int millisec()
[Y] Store OFUN[50]: name=millisec Kind=2 SupTypIndex=15 SubScope=1 Address=0 TypIndex=3 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[195]: name=millisec kind=Member returns=int void=no nested=no subscope={Pub:datetime}
[Y] Store OPAR[209]: name=$result TypIndex=3 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=50
[D] PAR[398]: function=millisec name=$result type=int order=0 const=no ref=yes
[Y] Store OPAR[210]: name=self TypIndex=15 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=50
[D] PAR[399]: function=millisec name=self type=datetime order=1 const=no ref=yes
[I] FUN: name=standard.datetime.millisec() index=195 searchindex=126, scope={Pub:main}, scope={Pub:main}
[D] FID[195]: name=millisec kind=2 fullname=standard.datetime.millisec() id=standard_datetime_millisec
[Y] Update OFUN[50]: ParmNr=1 ParmLow=209 ParmHigh=210
[A] DECL: (standard_datetime_millisec)        DECLARE {REF INTEGER $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):135:16: "  int microsec()"
[P] Parsed sentence: [FunDecl] ty(int) id(microsec) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;int microsec()
[Y] Store OFUN[51]: name=microsec Kind=2 SupTypIndex=15 SubScope=1 Address=0 TypIndex=3 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[196]: name=microsec kind=Member returns=int void=no nested=no subscope={Pub:datetime}
[Y] Store OPAR[211]: name=$result TypIndex=3 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=51
[D] PAR[400]: function=microsec name=$result type=int order=0 const=no ref=yes
[Y] Store OPAR[212]: name=self TypIndex=15 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=51
[D] PAR[401]: function=microsec name=self type=datetime order=1 const=no ref=yes
[I] FUN: name=standard.datetime.microsec() index=196 searchindex=126, scope={Pub:main}, scope={Pub:main}
[D] FID[196]: name=microsec kind=2 fullname=standard.datetime.microsec() id=standard_datetime_microsec
[Y] Update OFUN[51]: ParmNr=1 ParmLow=211 ParmHigh=212
[A] DECL: (standard_datetime_microsec)        DECLARE {REF INTEGER $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):136:15: "  int nanosec()"
[P] Parsed sentence: [FunDecl] ty(int) id(nanosec) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;int nanosec()
[Y] Store OFUN[52]: name=nanosec Kind=2 SupTypIndex=15 SubScope=1 Address=0 TypIndex=3 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[197]: name=nanosec kind=Member returns=int void=no nested=no subscope={Pub:datetime}
[Y] Store OPAR[213]: name=$result TypIndex=3 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=52
[D] PAR[402]: function=nanosec name=$result type=int order=0 const=no ref=yes
[Y] Store OPAR[214]: name=self TypIndex=15 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=52
[D] PAR[403]: function=nanosec name=self type=datetime order=1 const=no ref=yes
[I] FUN: name=standard.datetime.nanosec() index=197 searchindex=130, scope={Pub:main}, scope={Pub:main}
[D] FID[197]: name=nanosec kind=2 fullname=standard.datetime.nanosec() id=standard_datetime_nanosec
[Y] Update OFUN[52]: ParmNr=1 ParmLow=213 ParmHigh=214
[A] DECL: (standard_datetime_nanosec)         DECLARE {REF INTEGER $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):137:23: "  datetime begofmonth()"
[P] Parsed sentence: [FunDecl] ty(datetime) id(begofmonth) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;datetime begofmonth()
[Y] Store OFUN[53]: name=begofmonth Kind=2 SupTypIndex=15 SubScope=1 Address=0 TypIndex=15 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[198]: name=begofmonth kind=Member returns=datetime void=no nested=no subscope={Pub:datetime}
[Y] Store OPAR[215]: name=$result TypIndex=15 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=53
[D] PAR[404]: function=begofmonth name=$result type=datetime order=0 const=no ref=yes
[Y] Store OPAR[216]: name=self TypIndex=15 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=53
[D] PAR[405]: function=begofmonth name=self type=datetime order=1 const=no ref=yes
[I] FUN: name=standard.datetime.begofmonth() index=198 searchindex=119, scope={Pub:main}, scope={Pub:main}
[D] FID[198]: name=begofmonth kind=2 fullname=standard.datetime.begofmonth() id=standard_datetime_begofmonth
[Y] Update OFUN[53]: ParmNr=1 ParmLow=215 ParmHigh=216
[A] DECL: (standard_datetime_begofmonth)      DECLARE {REF UNDEFINED $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):138:23: "  datetime endofmonth()"
[P] Parsed sentence: [FunDecl] ty(datetime) id(endofmonth) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;datetime endofmonth()
[Y] Store OFUN[54]: name=endofmonth Kind=2 SupTypIndex=15 SubScope=1 Address=0 TypIndex=15 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[199]: name=endofmonth kind=Member returns=datetime void=no nested=no subscope={Pub:datetime}
[Y] Store OPAR[217]: name=$result TypIndex=15 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=54
[D] PAR[406]: function=endofmonth name=$result type=datetime order=0 const=no ref=yes
[Y] Store OPAR[218]: name=self TypIndex=15 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=54
[D] PAR[407]: function=endofmonth name=self type=datetime order=1 const=no ref=yes
[I] FUN: name=standard.datetime.endofmonth() index=199 searchindex=126, scope={Pub:main}, scope={Pub:main}
[D] FID[199]: name=endofmonth kind=2 fullname=standard.datetime.endofmonth() id=standard_datetime_endofmonth
[Y] Update OFUN[54]: ParmNr=1 ParmLow=217 ParmHigh=218
[A] DECL: (standard_datetime_endofmonth)      DECLARE {REF UNDEFINED $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):139:30: "  datetime addyears(int years)"
[P] Parsed sentence: [FunDecl] ty(datetime) id(addyears) pu(() ty(int) id(years) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;datetime addyears(int years)
[Y] Store OFUN[55]: name=addyears Kind=2 SupTypIndex=15 SubScope=1 Address=0 TypIndex=15 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[200]: name=addyears kind=Member returns=datetime void=no nested=no subscope={Pub:datetime}
[Y] Store OPAR[219]: name=$result TypIndex=15 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=55
[D] PAR[408]: function=addyears name=$result type=datetime order=0 const=no ref=yes
[Y] Store OPAR[220]: name=self TypIndex=15 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=55
[D] PAR[409]: function=addyears name=self type=datetime order=1 const=no ref=yes
[Y] Store OPAR[221]: name=years TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=55
[D] PAR[410]: function=addyears name=years type=int order=2 const=no ref=no
[I] FUN: name=standard.datetime.addyears(int) index=200 searchindex=119, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.datetime.addyears($cvint) index=200 searchindex=13, scope={Pub:main}, scope={Pub:main}
[D] FID[200]: name=addyears kind=2 fullname=standard.datetime.addyears(int) id=standard_datetime_addyears
[Y] Update OFUN[55]: ParmNr=3 ParmLow=219 ParmHigh=221
[A] DECL: (standard_datetime_addyears)        DECLARE {REF UNDEFINED $result,REF UNDEFINED self,INTEGER years} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):140:32: "  datetime addmonths(int months)"
[P] Parsed sentence: [FunDecl] ty(datetime) id(addmonths) pu(() ty(int) id(months) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;datetime addmonths(int months)
[Y] Store OFUN[56]: name=addmonths Kind=2 SupTypIndex=15 SubScope=1 Address=0 TypIndex=15 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[201]: name=addmonths kind=Member returns=datetime void=no nested=no subscope={Pub:datetime}
[Y] Store OPAR[222]: name=$result TypIndex=15 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=56
[D] PAR[411]: function=addmonths name=$result type=datetime order=0 const=no ref=yes
[Y] Store OPAR[223]: name=self TypIndex=15 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=56
[D] PAR[412]: function=addmonths name=self type=datetime order=1 const=no ref=yes
[Y] Store OPAR[224]: name=months TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=56
[D] PAR[413]: function=addmonths name=months type=int order=2 const=no ref=no
[I] FUN: name=standard.datetime.addmonths(int) index=201 searchindex=119, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.datetime.addmonths($cvint) index=201 searchindex=13, scope={Pub:main}, scope={Pub:main}
[D] FID[201]: name=addmonths kind=2 fullname=standard.datetime.addmonths(int) id=standard_datetime_addmonths
[Y] Update OFUN[56]: ParmNr=3 ParmLow=222 ParmHigh=224
[A] DECL: (standard_datetime_addmonths)       DECLARE {REF UNDEFINED $result,REF UNDEFINED self,INTEGER months} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):141:28: "  datetime adddays(int days)"
[P] Parsed sentence: [FunDecl] ty(datetime) id(adddays) pu(() ty(int) id(days) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;datetime adddays(int days)
[Y] Store OFUN[57]: name=adddays Kind=2 SupTypIndex=15 SubScope=1 Address=0 TypIndex=15 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[202]: name=adddays kind=Member returns=datetime void=no nested=no subscope={Pub:datetime}
[Y] Store OPAR[225]: name=$result TypIndex=15 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=57
[D] PAR[414]: function=adddays name=$result type=datetime order=0 const=no ref=yes
[Y] Store OPAR[226]: name=self TypIndex=15 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=57
[D] PAR[415]: function=adddays name=self type=datetime order=1 const=no ref=yes
[Y] Store OPAR[227]: name=days TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=57
[D] PAR[416]: function=adddays name=days type=int order=2 const=no ref=no
[I] FUN: name=standard.datetime.adddays(int) index=202 searchindex=119, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.datetime.adddays($cvint) index=202 searchindex=13, scope={Pub:main}, scope={Pub:main}
[D] FID[202]: name=adddays kind=2 fullname=standard.datetime.adddays(int) id=standard_datetime_adddays
[Y] Update OFUN[57]: ParmNr=3 ParmLow=225 ParmHigh=227
[A] DECL: (standard_datetime_adddays)         DECLARE {REF UNDEFINED $result,REF UNDEFINED self,INTEGER days} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):142:30: "  datetime addhours(int hours)"
[P] Parsed sentence: [FunDecl] ty(datetime) id(addhours) pu(() ty(int) id(hours) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;datetime addhours(int hours)
[Y] Store OFUN[58]: name=addhours Kind=2 SupTypIndex=15 SubScope=1 Address=0 TypIndex=15 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[203]: name=addhours kind=Member returns=datetime void=no nested=no subscope={Pub:datetime}
[Y] Store OPAR[228]: name=$result TypIndex=15 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=58
[D] PAR[417]: function=addhours name=$result type=datetime order=0 const=no ref=yes
[Y] Store OPAR[229]: name=self TypIndex=15 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=58
[D] PAR[418]: function=addhours name=self type=datetime order=1 const=no ref=yes
[Y] Store OPAR[230]: name=hours TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=58
[D] PAR[419]: function=addhours name=hours type=int order=2 const=no ref=no
[I] FUN: name=standard.datetime.addhours(int) index=203 searchindex=120, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.datetime.addhours($cvint) index=203 searchindex=14, scope={Pub:main}, scope={Pub:main}
[D] FID[203]: name=addhours kind=2 fullname=standard.datetime.addhours(int) id=standard_datetime_addhours
[Y] Update OFUN[58]: ParmNr=3 ParmLow=228 ParmHigh=230
[A] DECL: (standard_datetime_addhours)        DECLARE {REF UNDEFINED $result,REF UNDEFINED self,INTEGER hours} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):143:34: "  datetime addminutes(int minutes)"
[P] Parsed sentence: [FunDecl] ty(datetime) id(addminutes) pu(() ty(int) id(minutes) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;datetime addminutes(int minutes)
[Y] Store OFUN[59]: name=addminutes Kind=2 SupTypIndex=15 SubScope=1 Address=0 TypIndex=15 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[204]: name=addminutes kind=Member returns=datetime void=no nested=no subscope={Pub:datetime}
[Y] Store OPAR[231]: name=$result TypIndex=15 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=59
[D] PAR[420]: function=addminutes name=$result type=datetime order=0 const=no ref=yes
[Y] Store OPAR[232]: name=self TypIndex=15 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=59
[D] PAR[421]: function=addminutes name=self type=datetime order=1 const=no ref=yes
[Y] Store OPAR[233]: name=minutes TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=59
[D] PAR[422]: function=addminutes name=minutes type=int order=2 const=no ref=no
[I] FUN: name=standard.datetime.addminutes(int) index=204 searchindex=121, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.datetime.addminutes($cvint) index=204 searchindex=15, scope={Pub:main}, scope={Pub:main}
[D] FID[204]: name=addminutes kind=2 fullname=standard.datetime.addminutes(int) id=standard_datetime_addminutes
[Y] Update OFUN[59]: ParmNr=3 ParmLow=231 ParmHigh=233
[A] DECL: (standard_datetime_addminutes)      DECLARE {REF UNDEFINED $result,REF UNDEFINED self,INTEGER minutes} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):144:34: "  datetime addseconds(int seconds)"
[P] Parsed sentence: [FunDecl] ty(datetime) id(addseconds) pu(() ty(int) id(seconds) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;datetime addseconds(int seconds)
[Y] Store OFUN[60]: name=addseconds Kind=2 SupTypIndex=15 SubScope=1 Address=0 TypIndex=15 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[205]: name=addseconds kind=Member returns=datetime void=no nested=no subscope={Pub:datetime}
[Y] Store OPAR[234]: name=$result TypIndex=15 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=60
[D] PAR[423]: function=addseconds name=$result type=datetime order=0 const=no ref=yes
[Y] Store OPAR[235]: name=self TypIndex=15 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=60
[D] PAR[424]: function=addseconds name=self type=datetime order=1 const=no ref=yes
[Y] Store OPAR[236]: name=seconds TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=60
[D] PAR[425]: function=addseconds name=seconds type=int order=2 const=no ref=no
[I] FUN: name=standard.datetime.addseconds(int) index=205 searchindex=123, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.datetime.addseconds($cvint) index=205 searchindex=17, scope={Pub:main}, scope={Pub:main}
[D] FID[205]: name=addseconds kind=2 fullname=standard.datetime.addseconds(int) id=standard_datetime_addseconds
[Y] Update OFUN[60]: ParmNr=3 ParmLow=234 ParmHigh=236
[A] DECL: (standard_datetime_addseconds)      DECLARE {REF UNDEFINED $result,REF UNDEFINED self,INTEGER seconds} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):145:39: "  datetime addmillisecs(long millisecs)"
[P] Parsed sentence: [FunDecl] ty(datetime) id(addmillisecs) pu(() ty(long) id(millisecs) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;datetime addmillisecs(long millisecs)
[Y] Store OFUN[61]: name=addmillisecs Kind=2 SupTypIndex=15 SubScope=1 Address=0 TypIndex=15 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[206]: name=addmillisecs kind=Member returns=datetime void=no nested=no subscope={Pub:datetime}
[Y] Store OPAR[237]: name=$result TypIndex=15 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=61
[D] PAR[426]: function=addmillisecs name=$result type=datetime order=0 const=no ref=yes
[Y] Store OPAR[238]: name=self TypIndex=15 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=61
[D] PAR[427]: function=addmillisecs name=self type=datetime order=1 const=no ref=yes
[Y] Store OPAR[239]: name=millisecs TypIndex=4 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=61
[D] PAR[428]: function=addmillisecs name=millisecs type=long order=2 const=no ref=no
[I] FUN: name=standard.datetime.addmillisecs(long) index=206 searchindex=121, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.datetime.addmillisecs($cvint) index=206 searchindex=15, scope={Pub:main}, scope={Pub:main}
[D] FID[206]: name=addmillisecs kind=2 fullname=standard.datetime.addmillisecs(long) id=standard_datetime_addmillisecs
[Y] Update OFUN[61]: ParmNr=3 ParmLow=237 ParmHigh=239
[A] DECL: (standard_datetime_addmillisecs)    DECLARE {REF UNDEFINED $result,REF UNDEFINED self,LONG millisecs} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):146:39: "  datetime addmicrosecs(long microsecs)"
[P] Parsed sentence: [FunDecl] ty(datetime) id(addmicrosecs) pu(() ty(long) id(microsecs) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;datetime addmicrosecs(long microsecs)
[Y] Store OFUN[62]: name=addmicrosecs Kind=2 SupTypIndex=15 SubScope=1 Address=0 TypIndex=15 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[207]: name=addmicrosecs kind=Member returns=datetime void=no nested=no subscope={Pub:datetime}
[Y] Store OPAR[240]: name=$result TypIndex=15 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=62
[D] PAR[429]: function=addmicrosecs name=$result type=datetime order=0 const=no ref=yes
[Y] Store OPAR[241]: name=self TypIndex=15 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=62
[D] PAR[430]: function=addmicrosecs name=self type=datetime order=1 const=no ref=yes
[Y] Store OPAR[242]: name=microsecs TypIndex=4 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=62
[D] PAR[431]: function=addmicrosecs name=microsecs type=long order=2 const=no ref=no
[I] FUN: name=standard.datetime.addmicrosecs(long) index=207 searchindex=121, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.datetime.addmicrosecs($cvint) index=207 searchindex=15, scope={Pub:main}, scope={Pub:main}
[D] FID[207]: name=addmicrosecs kind=2 fullname=standard.datetime.addmicrosecs(long) id=standard_datetime_addmicrosecs
[Y] Update OFUN[62]: ParmNr=3 ParmLow=240 ParmHigh=242
[A] DECL: (standard_datetime_addmicrosecs)    DECLARE {REF UNDEFINED $result,REF UNDEFINED self,LONG microsecs} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):147:37: "  datetime addnanosecs(long nanosecs)"
[P] Parsed sentence: [FunDecl] ty(datetime) id(addnanosecs) pu(() ty(long) id(nanosecs) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;datetime addnanosecs(long nanosecs)
[Y] Store OFUN[63]: name=addnanosecs Kind=2 SupTypIndex=15 SubScope=1 Address=0 TypIndex=15 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[208]: name=addnanosecs kind=Member returns=datetime void=no nested=no subscope={Pub:datetime}
[Y] Store OPAR[243]: name=$result TypIndex=15 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=63
[D] PAR[432]: function=addnanosecs name=$result type=datetime order=0 const=no ref=yes
[Y] Store OPAR[244]: name=self TypIndex=15 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=63
[D] PAR[433]: function=addnanosecs name=self type=datetime order=1 const=no ref=yes
[Y] Store OPAR[245]: name=nanosecs TypIndex=4 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=63
[D] PAR[434]: function=addnanosecs name=nanosecs type=long order=2 const=no ref=no
[I] FUN: name=standard.datetime.addnanosecs(long) index=208 searchindex=125, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.datetime.addnanosecs($cvint) index=208 searchindex=19, scope={Pub:main}, scope={Pub:main}
[D] FID[208]: name=addnanosecs kind=2 fullname=standard.datetime.addnanosecs(long) id=standard_datetime_addnanosecs
[Y] Update OFUN[63]: ParmNr=3 ParmLow=243 ParmHigh=245
[A] DECL: (standard_datetime_addnanosecs)     DECLARE {REF UNDEFINED $result,REF UNDEFINED self,LONG nanosecs} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):148:15: "  date todate()"
[P] Parsed sentence: [FunDecl] ty(date) id(todate) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;date todate()
[Y] Store OFUN[64]: name=todate Kind=2 SupTypIndex=15 SubScope=1 Address=0 TypIndex=13 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[209]: name=todate kind=Member returns=date void=no nested=no subscope={Pub:datetime}
[Y] Store OPAR[246]: name=$result TypIndex=13 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=64
[D] PAR[435]: function=todate name=$result type=date order=0 const=no ref=yes
[Y] Store OPAR[247]: name=self TypIndex=15 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=64
[D] PAR[436]: function=todate name=self type=datetime order=1 const=no ref=yes
[I] FUN: name=standard.datetime.todate() index=209 searchindex=143, scope={Pub:main}, scope={Pub:main}
[D] FID[209]: name=todate kind=2 fullname=standard.datetime.todate() id=standard_datetime_todate
[Y] Update OFUN[64]: ParmNr=1 ParmLow=246 ParmHigh=247
[A] DECL: (standard_datetime_todate)          DECLARE {REF UNDEFINED $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):149:15: "  time totime()"
[P] Parsed sentence: [FunDecl] ty(time) id(totime) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;time totime()
[Y] Store OFUN[65]: name=totime Kind=2 SupTypIndex=15 SubScope=1 Address=0 TypIndex=14 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[210]: name=totime kind=Member returns=time void=no nested=no subscope={Pub:datetime}
[Y] Store OPAR[248]: name=$result TypIndex=14 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=65
[D] PAR[437]: function=totime name=$result type=time order=0 const=no ref=yes
[Y] Store OPAR[249]: name=self TypIndex=15 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=65
[D] PAR[438]: function=totime name=self type=datetime order=1 const=no ref=yes
[I] FUN: name=standard.datetime.totime() index=210 searchindex=144, scope={Pub:main}, scope={Pub:main}
[D] FID[210]: name=totime kind=2 fullname=standard.datetime.totime() id=standard_datetime_totime
[Y] Update OFUN[65]: ParmNr=1 ParmLow=248 ParmHigh=249
[A] DECL: (standard_datetime_totime)          DECLARE {REF UNDEFINED $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):150:16: "  string tostr()"
[P] Parsed sentence: [FunDecl] ty(string) id(tostr) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;string tostr()
[Y] Store OFUN[66]: name=tostr Kind=2 SupTypIndex=15 SubScope=1 Address=0 TypIndex=6 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[211]: name=tostr kind=Member returns=string void=no nested=no subscope={Pub:datetime}
[Y] Store OPAR[250]: name=$result TypIndex=6 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=66
[D] PAR[439]: function=tostr name=$result type=string order=0 const=no ref=yes
[Y] Store OPAR[251]: name=self TypIndex=15 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=66
[D] PAR[440]: function=tostr name=self type=datetime order=1 const=no ref=yes
[I] FUN: name=standard.datetime.tostr() index=211 searchindex=144, scope={Pub:main}, scope={Pub:main}
[D] FID[211]: name=tostr kind=2 fullname=standard.datetime.tostr() id=standard_datetime_tostr
[Y] Update OFUN[66]: ParmNr=1 ParmLow=250 ParmHigh=251
[A] DECL: (standard_datetime_tostr)           DECLARE {REF STRINGBLOCK $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):151:39: "  string tostr(char delim1,char delim2)"
[P] Parsed sentence: [FunDecl] ty(string) id(tostr) pu(() ty(char) id(delim1) pu(,) ty(char) id(delim2) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;string tostr(char delim1,char delim2)
[Y] Store OFUN[67]: name=tostr Kind=2 SupTypIndex=15 SubScope=1 Address=0 TypIndex=6 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[212]: name=tostr kind=Member returns=string void=no nested=no subscope={Pub:datetime}
[Y] Store OPAR[252]: name=$result TypIndex=6 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=67
[D] PAR[441]: function=tostr name=$result type=string order=0 const=no ref=yes
[Y] Store OPAR[253]: name=self TypIndex=15 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=67
[D] PAR[442]: function=tostr name=self type=datetime order=1 const=no ref=yes
[Y] Store OPAR[254]: name=delim1 TypIndex=1 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=67
[D] PAR[443]: function=tostr name=delim1 type=char order=2 const=no ref=no
[Y] Store OPAR[255]: name=delim2 TypIndex=1 IsConst=0 IsReference=0 ParmOrder=3 FunIndex=67
[D] PAR[444]: function=tostr name=delim2 type=char order=3 const=no ref=no
[I] FUN: name=standard.datetime.tostr(char,char) index=212 searchindex=145, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.datetime.tostr($cvint,$cvint) index=212 searchindex=27, scope={Pub:main}, scope={Pub:main}
[D] FID[212]: name=tostr kind=2 fullname=standard.datetime.tostr(char,char) id=standard_datetime_tostr2
[Y] Update OFUN[67]: ParmNr=4 ParmLow=252 ParmHigh=255
[A] DECL: (standard_datetime_tostr2)          DECLARE {REF STRINGBLOCK $result,REF UNDEFINED self,CHAR delim1,CHAR delim2} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):152:7: "  .priv"
[P] Parsed sentence: [Priv] kw(.priv)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[S] Subscope end: {Pub:datetime}
[S] Subscope begin: {Pri:datetime}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):153:9: "  int _dt"
[P] Parsed sentence: [VarDecl] ty(int) id(_dt)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;int _dt
[D] FLD[20]: type=int name=_dt subscope={Pri:datetime} offset=0 static=no enumvalue=0
[P] -------------------------------------------------------------------------------------
[L] Read line (src):154:10: "  long _tm"
[P] Parsed sentence: [VarDecl] ty(long) id(_tm)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;long _tm
[D] FLD[21]: type=long name=_tm subscope={Pri:datetime} offset=4 static=no enumvalue=0
[P] -------------------------------------------------------------------------------------
[L] Read line (src):155:20: "  allow [+]() to _dt"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(+) pu(]) pu(() pu()) kw(to) id(_dt)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[16]: name=OPFI:[+]()->standard.datetime._dt
[I] GRA: name=OPFI:[+]()->standard.datetime._dt index=16 searchindex=3, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):156:20: "  allow [+]() to _tm"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(+) pu(]) pu(() pu()) kw(to) id(_tm)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[17]: name=OPFI:[+]()->standard.datetime._tm
[I] GRA: name=OPFI:[+]()->standard.datetime._tm index=17 searchindex=4, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):157:20: "  allow [-]() to _dt"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(-) pu(]) pu(() pu()) kw(to) id(_dt)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[18]: name=OPFI:[-]()->standard.datetime._dt
[I] GRA: name=OPFI:[-]()->standard.datetime._dt index=18 searchindex=7, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):158:20: "  allow [-]() to _tm"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(-) pu(]) pu(() pu()) kw(to) id(_tm)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[19]: name=OPFI:[-]()->standard.datetime._tm
[I] GRA: name=OPFI:[-]()->standard.datetime._tm index=19 searchindex=8, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):159:21: "  allow [==]() to _dt"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(==) pu(]) pu(() pu()) kw(to) id(_dt)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[20]: name=OPFI:[==]()->standard.datetime._dt
[I] GRA: name=OPFI:[==]()->standard.datetime._dt index=20 searchindex=15, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):160:21: "  allow [!=]() to _dt"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(!=) pu(]) pu(() pu()) kw(to) id(_dt)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[21]: name=OPFI:[!=]()->standard.datetime._dt
[I] GRA: name=OPFI:[!=]()->standard.datetime._dt index=21 searchindex=1, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):161:20: "  allow [<]() to _dt"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(<) pu(]) pu(() pu()) kw(to) id(_dt)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[22]: name=OPFI:[<]()->standard.datetime._dt
[I] GRA: name=OPFI:[<]()->standard.datetime._dt index=22 searchindex=14, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):162:20: "  allow [>]() to _dt"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(>) pu(]) pu(() pu()) kw(to) id(_dt)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[23]: name=OPFI:[>]()->standard.datetime._dt
[I] GRA: name=OPFI:[>]()->standard.datetime._dt index=23 searchindex=22, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):163:21: "  allow [<=]() to _dt"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(<=) pu(]) pu(() pu()) kw(to) id(_dt)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[24]: name=OPFI:[<=]()->standard.datetime._dt
[I] GRA: name=OPFI:[<=]()->standard.datetime._dt index=24 searchindex=12, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):164:21: "  allow [>=]() to _dt"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(>=) pu(]) pu(() pu()) kw(to) id(_dt)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[25]: name=OPFI:[>=]()->standard.datetime._dt
[I] GRA: name=OPFI:[>=]()->standard.datetime._dt index=25 searchindex=21, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):165:21: "  allow [==]() to _tm"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(==) pu(]) pu(() pu()) kw(to) id(_tm)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[26]: name=OPFI:[==]()->standard.datetime._tm
[I] GRA: name=OPFI:[==]()->standard.datetime._tm index=26 searchindex=19, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):166:21: "  allow [!=]() to _tm"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(!=) pu(]) pu(() pu()) kw(to) id(_tm)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[27]: name=OPFI:[!=]()->standard.datetime._tm
[I] GRA: name=OPFI:[!=]()->standard.datetime._tm index=27 searchindex=2, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):167:20: "  allow [<]() to _tm"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(<) pu(]) pu(() pu()) kw(to) id(_tm)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[28]: name=OPFI:[<]()->standard.datetime._tm
[I] GRA: name=OPFI:[<]()->standard.datetime._tm index=28 searchindex=17, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):168:20: "  allow [>]() to _tm"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(>) pu(]) pu(() pu()) kw(to) id(_tm)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[29]: name=OPFI:[>]()->standard.datetime._tm
[I] GRA: name=OPFI:[>]()->standard.datetime._tm index=29 searchindex=28, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):169:21: "  allow [<=]() to _tm"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(<=) pu(]) pu(() pu()) kw(to) id(_tm)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[30]: name=OPFI:[<=]()->standard.datetime._tm
[I] GRA: name=OPFI:[<=]()->standard.datetime._tm index=30 searchindex=14, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):170:21: "  allow [>=]() to _tm"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(>=) pu(]) pu(() pu()) kw(to) id(_tm)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[31]: name=OPFI:[>=]()->standard.datetime._tm
[I] GRA: name=OPFI:[>=]()->standard.datetime._tm index=31 searchindex=26, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):171:6: ":class"
[P] Parsed sentence: [EndClass] kw(:class)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000000h, LocBlk=0000004Fh
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000004h, LocBlk=0000004Fh
[O] Relocation added: Type=BlkInsideGlo, LocAdr=00000000000000D4h
[A] DATA:                                     STORE {"_dt"                                                    ;Address=[00000000000000D4h]
[A] DATA:                                     STORE  "_tm"}
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000000h, LocBlk=00000052h
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000004h, LocBlk=00000052h
[O] Relocation added: Type=BlkInsideGlo, LocAdr=00000000000000D8h
[A] DATA:                                     STORE {"int"                                                    ;Address=[00000000000000D8h]
[A] DATA:                                     STORE  "long"}
[Y] Update OTYP[15]: MetaStNames=212 MetaStTypes=216 Length=12 FieldLow=-1 FieldHigh=-1
[S] Subscope end: {Pri:datetime}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):174:15: "class timespan:"
[P] Parsed sentence: [DefClass] kw(class) id(timespan) pu(:)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[O] Relocation added: Type=BlkInsideGlo, LocAdr=00000000000000DCh
[A] DATA:                                     STORE "timespan"                                                ;Address=[00000000000000DCh]
[Y] Store OTYP[16]: name=timespan msttype=8 FunIndex=-1 SupTypIndex=-1 IsTypedef=0 IsSystemDef=0 Length=0 DimNr=0 ElemTypIndex=-1 DimIndex=-1 FieldLow=-1 FieldHigh=-1
[D] TYP[16]: name=timespan msttype=class scope={Pub:main} typedef=no systemdef=no length=0
[I] TYP: name=standard.timespan index=16 searchindex=15, scope={Pub:main}
[S] Subscope begin: {Pub:timespan}
[P] Updated parser type list: bool,char,date,datetime,errorcode,filemode,float,hostsys,int,long,short,string,time,timespan,word
[P] -------------------------------------------------------------------------------------
[L] Read line (src):175:7: "  .publ"
[P] Parsed sentence: [Publ] kw(.publ)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):176:20: "  timespan(int days)"
[P] Parsed sentence: [FunDecl] ty(timespan) pu(() ty(int) id(days) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;timespan(int days)
[Y] Store OFUN[68]: name=timespan Kind=2 SupTypIndex=16 SubScope=1 Address=0 TypIndex=16 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[213]: name=timespan kind=Member returns=timespan void=no nested=no subscope={Pub:timespan}
[Y] Store OPAR[256]: name=$result TypIndex=16 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=68
[D] PAR[445]: function=timespan name=$result type=timespan order=0 const=no ref=yes
[Y] Store OPAR[257]: name=self TypIndex=16 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=68
[D] PAR[446]: function=timespan name=self type=timespan order=1 const=no ref=yes
[Y] Store OPAR[258]: name=days TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=68
[D] PAR[447]: function=timespan name=days type=int order=2 const=no ref=no
[I] FUN: name=standard.timespan.timespan(int) index=213 searchindex=175, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.timespan.timespan($cvint) index=213 searchindex=48, scope={Pub:main}, scope={Pub:main}
[D] FID[213]: name=timespan kind=2 fullname=standard.timespan.timespan(int) id=standard_timespan_timespan
[Y] Update OFUN[68]: ParmNr=3 ParmLow=256 ParmHigh=258
[A] DECL: (standard_timespan_timespan)        DECLARE {REF UNDEFINED $result,REF UNDEFINED self,INTEGER days} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):177:54: "  timespan(int days,int hours,int minutes,int seconds)"
[P] Parsed sentence: [FunDecl] ty(timespan) pu(() ty(int) id(days) pu(,) ty(int) id(hours) pu(,) ty(int) id(minutes) pu(,) ty(int) id(seconds) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;timespan(int days,int hours,int minutes,int seconds)
[Y] Store OFUN[69]: name=timespan Kind=2 SupTypIndex=16 SubScope=1 Address=0 TypIndex=16 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[214]: name=timespan kind=Member returns=timespan void=no nested=no subscope={Pub:timespan}
[Y] Store OPAR[259]: name=$result TypIndex=16 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=69
[D] PAR[448]: function=timespan name=$result type=timespan order=0 const=no ref=yes
[Y] Store OPAR[260]: name=self TypIndex=16 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=69
[D] PAR[449]: function=timespan name=self type=timespan order=1 const=no ref=yes
[Y] Store OPAR[261]: name=days TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=69
[D] PAR[450]: function=timespan name=days type=int order=2 const=no ref=no
[Y] Store OPAR[262]: name=hours TypIndex=3 IsConst=0 IsReference=0 ParmOrder=3 FunIndex=69
[D] PAR[451]: function=timespan name=hours type=int order=3 const=no ref=no
[Y] Store OPAR[263]: name=minutes TypIndex=3 IsConst=0 IsReference=0 ParmOrder=4 FunIndex=69
[D] PAR[452]: function=timespan name=minutes type=int order=4 const=no ref=no
[Y] Store OPAR[264]: name=seconds TypIndex=3 IsConst=0 IsReference=0 ParmOrder=5 FunIndex=69
[D] PAR[453]: function=timespan name=seconds type=int order=5 const=no ref=no
[I] FUN: name=standard.timespan.timespan(int,int,int,int) index=214 searchindex=176, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.timespan.timespan($cvint,$cvint,$cvint,$cvint) index=214 searchindex=49, scope={Pub:main}, scope={Pub:main}
[D] FID[214]: name=timespan kind=2 fullname=standard.timespan.timespan(int,int,int,int) id=standard_timespan_timespan2
[Y] Update OFUN[69]: ParmNr=6 ParmLow=259 ParmHigh=264
[A] DECL: (standard_timespan_timespan2)       DECLARE {REF UNDEFINED $result,REF UNDEFINED self,INTEGER days,INTEGER hours,INTEGER minutes,INTEGER seconds} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):178:68: "  timespan(int days,int hours,int minutes,int seconds,int millisecs)"
[P] Parsed sentence: [FunDecl] ty(timespan) pu(() ty(int) id(days) pu(,) ty(int) id(hours) pu(,) ty(int) id(minutes) pu(,) ty(int) id(seconds) pu(,) ty(int) id(millisecs) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;timespan(int days,int hours,int minutes,int seconds,int millisecs)
[Y] Store OFUN[70]: name=timespan Kind=2 SupTypIndex=16 SubScope=1 Address=0 TypIndex=16 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[215]: name=timespan kind=Member returns=timespan void=no nested=no subscope={Pub:timespan}
[Y] Store OPAR[265]: name=$result TypIndex=16 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=70
[D] PAR[454]: function=timespan name=$result type=timespan order=0 const=no ref=yes
[Y] Store OPAR[266]: name=self TypIndex=16 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=70
[D] PAR[455]: function=timespan name=self type=timespan order=1 const=no ref=yes
[Y] Store OPAR[267]: name=days TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=70
[D] PAR[456]: function=timespan name=days type=int order=2 const=no ref=no
[Y] Store OPAR[268]: name=hours TypIndex=3 IsConst=0 IsReference=0 ParmOrder=3 FunIndex=70
[D] PAR[457]: function=timespan name=hours type=int order=3 const=no ref=no
[Y] Store OPAR[269]: name=minutes TypIndex=3 IsConst=0 IsReference=0 ParmOrder=4 FunIndex=70
[D] PAR[458]: function=timespan name=minutes type=int order=4 const=no ref=no
[Y] Store OPAR[270]: name=seconds TypIndex=3 IsConst=0 IsReference=0 ParmOrder=5 FunIndex=70
[D] PAR[459]: function=timespan name=seconds type=int order=5 const=no ref=no
[Y] Store OPAR[271]: name=millisecs TypIndex=3 IsConst=0 IsReference=0 ParmOrder=6 FunIndex=70
[D] PAR[460]: function=timespan name=millisecs type=int order=6 const=no ref=no
[I] FUN: name=standard.timespan.timespan(int,int,int,int,int) index=215 searchindex=177, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.timespan.timespan($cvint,$cvint,$cvint,$cvint,$cvint) index=215 searchindex=50, scope={Pub:main}, scope={Pub:main}
[D] FID[215]: name=timespan kind=2 fullname=standard.timespan.timespan(int,int,int,int,int) id=standard_timespan_timespan3
[Y] Update OFUN[70]: ParmNr=7 ParmLow=265 ParmHigh=271
[A] DECL: (standard_timespan_timespan3)       DECLARE {REF UNDEFINED $result,REF UNDEFINED self,INTEGER days,INTEGER hours,INTEGER minutes,INTEGER seconds,INTEGER millisecs} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):179:82: "  timespan(int days,int hours,int minutes,int seconds,int millisecs,int microsecs)"
[P] Parsed sentence: [FunDecl] ty(timespan) pu(() ty(int) id(days) pu(,) ty(int) id(hours) pu(,) ty(int) id(minutes) pu(,) ty(int) id(seconds) pu(,) ty(int) id(millisecs) pu(,) ty(int) id(microsecs) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;timespan(int days,int hours,int minutes,int seconds,int millisecs,int microsecs)
[Y] Store OFUN[71]: name=timespan Kind=2 SupTypIndex=16 SubScope=1 Address=0 TypIndex=16 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[216]: name=timespan kind=Member returns=timespan void=no nested=no subscope={Pub:timespan}
[Y] Store OPAR[272]: name=$result TypIndex=16 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=71
[D] PAR[461]: function=timespan name=$result type=timespan order=0 const=no ref=yes
[Y] Store OPAR[273]: name=self TypIndex=16 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=71
[D] PAR[462]: function=timespan name=self type=timespan order=1 const=no ref=yes
[Y] Store OPAR[274]: name=days TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=71
[D] PAR[463]: function=timespan name=days type=int order=2 const=no ref=no
[Y] Store OPAR[275]: name=hours TypIndex=3 IsConst=0 IsReference=0 ParmOrder=3 FunIndex=71
[D] PAR[464]: function=timespan name=hours type=int order=3 const=no ref=no
[Y] Store OPAR[276]: name=minutes TypIndex=3 IsConst=0 IsReference=0 ParmOrder=4 FunIndex=71
[D] PAR[465]: function=timespan name=minutes type=int order=4 const=no ref=no
[Y] Store OPAR[277]: name=seconds TypIndex=3 IsConst=0 IsReference=0 ParmOrder=5 FunIndex=71
[D] PAR[466]: function=timespan name=seconds type=int order=5 const=no ref=no
[Y] Store OPAR[278]: name=millisecs TypIndex=3 IsConst=0 IsReference=0 ParmOrder=6 FunIndex=71
[D] PAR[467]: function=timespan name=millisecs type=int order=6 const=no ref=no
[Y] Store OPAR[279]: name=microsecs TypIndex=3 IsConst=0 IsReference=0 ParmOrder=7 FunIndex=71
[D] PAR[468]: function=timespan name=microsecs type=int order=7 const=no ref=no
[I] FUN: name=standard.timespan.timespan(int,int,int,int,int,int) index=216 searchindex=178, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.timespan.timespan($cvint,$cvint,$cvint,$cvint,$cvint,$cvint) index=216 searchindex=51, scope={Pub:main}, scope={Pub:main}
[D] FID[216]: name=timespan kind=2 fullname=standard.timespan.timespan(int,int,int,int,int,int) id=standard_timespan_timespan4
[Y] Update OFUN[71]: ParmNr=8 ParmLow=272 ParmHigh=279
[A] DECL: (standard_timespan_timespan4)       DECLARE {REF UNDEFINED $result,REF UNDEFINED self,INTEGER days,INTEGER hours,INTEGER minutes,INTEGER seconds,INTEGER millisecs,INTEGER microsecs} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):180:95: "  timespan(int days,int hours,int minutes,int seconds,int millisecs,int microsecs,int nanosecs)"
[P] Parsed sentence: [FunDecl] ty(timespan) pu(() ty(int) id(days) pu(,) ty(int) id(hours) pu(,) ty(int) id(minutes) pu(,) ty(int) id(seconds) pu(,) ty(int) id(millisecs) pu(,) ty(int) id(microsecs) pu(,) ty(int) id(nanosecs) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;timespan(int days,int hours,int minutes,int seconds,int millisecs,int microsecs,int nanosecs)
[Y] Store OFUN[72]: name=timespan Kind=2 SupTypIndex=16 SubScope=1 Address=0 TypIndex=16 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[217]: name=timespan kind=Member returns=timespan void=no nested=no subscope={Pub:timespan}
[Y] Store OPAR[280]: name=$result TypIndex=16 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=72
[D] PAR[469]: function=timespan name=$result type=timespan order=0 const=no ref=yes
[Y] Store OPAR[281]: name=self TypIndex=16 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=72
[D] PAR[470]: function=timespan name=self type=timespan order=1 const=no ref=yes
[Y] Store OPAR[282]: name=days TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=72
[D] PAR[471]: function=timespan name=days type=int order=2 const=no ref=no
[Y] Store OPAR[283]: name=hours TypIndex=3 IsConst=0 IsReference=0 ParmOrder=3 FunIndex=72
[D] PAR[472]: function=timespan name=hours type=int order=3 const=no ref=no
[Y] Store OPAR[284]: name=minutes TypIndex=3 IsConst=0 IsReference=0 ParmOrder=4 FunIndex=72
[D] PAR[473]: function=timespan name=minutes type=int order=4 const=no ref=no
[Y] Store OPAR[285]: name=seconds TypIndex=3 IsConst=0 IsReference=0 ParmOrder=5 FunIndex=72
[D] PAR[474]: function=timespan name=seconds type=int order=5 const=no ref=no
[Y] Store OPAR[286]: name=millisecs TypIndex=3 IsConst=0 IsReference=0 ParmOrder=6 FunIndex=72
[D] PAR[475]: function=timespan name=millisecs type=int order=6 const=no ref=no
[Y] Store OPAR[287]: name=microsecs TypIndex=3 IsConst=0 IsReference=0 ParmOrder=7 FunIndex=72
[D] PAR[476]: function=timespan name=microsecs type=int order=7 const=no ref=no
[Y] Store OPAR[288]: name=nanosecs TypIndex=3 IsConst=0 IsReference=0 ParmOrder=8 FunIndex=72
[D] PAR[477]: function=timespan name=nanosecs type=int order=8 const=no ref=no
[I] FUN: name=standard.timespan.timespan(int,int,int,int,int,int,int) index=217 searchindex=179, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.timespan.timespan($cvint,$cvint,$cvint,$cvint,$cvint,$cvint,$cvint) index=217 searchindex=52, scope={Pub:main}, scope={Pub:main}
[D] FID[217]: name=timespan kind=2 fullname=standard.timespan.timespan(int,int,int,int,int,int,int) id=standard_timespan_timespan5
[Y] Update OFUN[72]: ParmNr=9 ParmLow=280 ParmHigh=288
[A] DECL: (standard_timespan_timespan5)       DECLARE {REF UNDEFINED $result,REF UNDEFINED self,INTEGER days,INTEGER hours,INTEGER minutes,INTEGER seconds,INTEGER millisecs,INTEGER microsecs,INTEGER nanosecs} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):181:22: "  void value(int days)"
[P] Parsed sentence: [FunDecl] kw(void) id(value) pu(() ty(int) id(days) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;void value(int days)
[Y] Store OFUN[73]: name=value Kind=2 SupTypIndex=16 SubScope=1 Address=0 TypIndex=-1 IsVoid=1 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[218]: name=value kind=Member returns=undefined void=yes nested=no subscope={Pub:timespan}
[Y] Store OPAR[289]: name=self TypIndex=16 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=73
[D] PAR[478]: function=value name=self type=timespan order=0 const=no ref=yes
[Y] Store OPAR[290]: name=days TypIndex=3 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=73
[D] PAR[479]: function=value name=days type=int order=1 const=no ref=no
[I] FUN: name=standard.timespan.value(int) index=218 searchindex=180, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.timespan.value($cvint) index=218 searchindex=53, scope={Pub:main}, scope={Pub:main}
[D] FID[218]: name=value kind=2 fullname=standard.timespan.value(int) id=standard_timespan_value
[Y] Update OFUN[73]: ParmNr=2 ParmLow=289 ParmHigh=290
[A] DECL: (standard_timespan_value)           DECLARE {REF UNDEFINED self,INTEGER days} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):182:56: "  void value(int days,int hours,int minutes,int seconds)"
[P] Parsed sentence: [FunDecl] kw(void) id(value) pu(() ty(int) id(days) pu(,) ty(int) id(hours) pu(,) ty(int) id(minutes) pu(,) ty(int) id(seconds) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;void value(int days,int hours,int minutes,int seconds)
[Y] Store OFUN[74]: name=value Kind=2 SupTypIndex=16 SubScope=1 Address=0 TypIndex=-1 IsVoid=1 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[219]: name=value kind=Member returns=undefined void=yes nested=no subscope={Pub:timespan}
[Y] Store OPAR[291]: name=self TypIndex=16 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=74
[D] PAR[480]: function=value name=self type=timespan order=0 const=no ref=yes
[Y] Store OPAR[292]: name=days TypIndex=3 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=74
[D] PAR[481]: function=value name=days type=int order=1 const=no ref=no
[Y] Store OPAR[293]: name=hours TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=74
[D] PAR[482]: function=value name=hours type=int order=2 const=no ref=no
[Y] Store OPAR[294]: name=minutes TypIndex=3 IsConst=0 IsReference=0 ParmOrder=3 FunIndex=74
[D] PAR[483]: function=value name=minutes type=int order=3 const=no ref=no
[Y] Store OPAR[295]: name=seconds TypIndex=3 IsConst=0 IsReference=0 ParmOrder=4 FunIndex=74
[D] PAR[484]: function=value name=seconds type=int order=4 const=no ref=no
[I] FUN: name=standard.timespan.value(int,int,int,int) index=219 searchindex=181, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.timespan.value($cvint,$cvint,$cvint,$cvint) index=219 searchindex=54, scope={Pub:main}, scope={Pub:main}
[D] FID[219]: name=value kind=2 fullname=standard.timespan.value(int,int,int,int) id=standard_timespan_value2
[Y] Update OFUN[74]: ParmNr=5 ParmLow=291 ParmHigh=295
[A] DECL: (standard_timespan_value2)          DECLARE {REF UNDEFINED self,INTEGER days,INTEGER hours,INTEGER minutes,INTEGER seconds} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):183:70: "  void value(int days,int hours,int minutes,int seconds,int millisecs)"
[P] Parsed sentence: [FunDecl] kw(void) id(value) pu(() ty(int) id(days) pu(,) ty(int) id(hours) pu(,) ty(int) id(minutes) pu(,) ty(int) id(seconds) pu(,) ty(int) id(millisecs) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;void value(int days,int hours,int minutes,int seconds,int millisecs)
[Y] Store OFUN[75]: name=value Kind=2 SupTypIndex=16 SubScope=1 Address=0 TypIndex=-1 IsVoid=1 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[220]: name=value kind=Member returns=undefined void=yes nested=no subscope={Pub:timespan}
[Y] Store OPAR[296]: name=self TypIndex=16 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=75
[D] PAR[485]: function=value name=self type=timespan order=0 const=no ref=yes
[Y] Store OPAR[297]: name=days TypIndex=3 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=75
[D] PAR[486]: function=value name=days type=int order=1 const=no ref=no
[Y] Store OPAR[298]: name=hours TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=75
[D] PAR[487]: function=value name=hours type=int order=2 const=no ref=no
[Y] Store OPAR[299]: name=minutes TypIndex=3 IsConst=0 IsReference=0 ParmOrder=3 FunIndex=75
[D] PAR[488]: function=value name=minutes type=int order=3 const=no ref=no
[Y] Store OPAR[300]: name=seconds TypIndex=3 IsConst=0 IsReference=0 ParmOrder=4 FunIndex=75
[D] PAR[489]: function=value name=seconds type=int order=4 const=no ref=no
[Y] Store OPAR[301]: name=millisecs TypIndex=3 IsConst=0 IsReference=0 ParmOrder=5 FunIndex=75
[D] PAR[490]: function=value name=millisecs type=int order=5 const=no ref=no
[I] FUN: name=standard.timespan.value(int,int,int,int,int) index=220 searchindex=182, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.timespan.value($cvint,$cvint,$cvint,$cvint,$cvint) index=220 searchindex=55, scope={Pub:main}, scope={Pub:main}
[D] FID[220]: name=value kind=2 fullname=standard.timespan.value(int,int,int,int,int) id=standard_timespan_value3
[Y] Update OFUN[75]: ParmNr=6 ParmLow=296 ParmHigh=301
[A] DECL: (standard_timespan_value3)          DECLARE {REF UNDEFINED self,INTEGER days,INTEGER hours,INTEGER minutes,INTEGER seconds,INTEGER millisecs} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):184:84: "  void value(int days,int hours,int minutes,int seconds,int millisecs,int microsecs)"
[P] Parsed sentence: [FunDecl] kw(void) id(value) pu(() ty(int) id(days) pu(,) ty(int) id(hours) pu(,) ty(int) id(minutes) pu(,) ty(int) id(seconds) pu(,) ty(int) id(millisecs) pu(,) ty(int) id(microsecs) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;void value(int days,int hours,int minutes,int seconds,int millisecs,int microsecs)
[Y] Store OFUN[76]: name=value Kind=2 SupTypIndex=16 SubScope=1 Address=0 TypIndex=-1 IsVoid=1 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[221]: name=value kind=Member returns=undefined void=yes nested=no subscope={Pub:timespan}
[Y] Store OPAR[302]: name=self TypIndex=16 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=76
[D] PAR[491]: function=value name=self type=timespan order=0 const=no ref=yes
[Y] Store OPAR[303]: name=days TypIndex=3 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=76
[D] PAR[492]: function=value name=days type=int order=1 const=no ref=no
[Y] Store OPAR[304]: name=hours TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=76
[D] PAR[493]: function=value name=hours type=int order=2 const=no ref=no
[Y] Store OPAR[305]: name=minutes TypIndex=3 IsConst=0 IsReference=0 ParmOrder=3 FunIndex=76
[D] PAR[494]: function=value name=minutes type=int order=3 const=no ref=no
[Y] Store OPAR[306]: name=seconds TypIndex=3 IsConst=0 IsReference=0 ParmOrder=4 FunIndex=76
[D] PAR[495]: function=value name=seconds type=int order=4 const=no ref=no
[Y] Store OPAR[307]: name=millisecs TypIndex=3 IsConst=0 IsReference=0 ParmOrder=5 FunIndex=76
[D] PAR[496]: function=value name=millisecs type=int order=5 const=no ref=no
[Y] Store OPAR[308]: name=microsecs TypIndex=3 IsConst=0 IsReference=0 ParmOrder=6 FunIndex=76
[D] PAR[497]: function=value name=microsecs type=int order=6 const=no ref=no
[I] FUN: name=standard.timespan.value(int,int,int,int,int,int) index=221 searchindex=183, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.timespan.value($cvint,$cvint,$cvint,$cvint,$cvint,$cvint) index=221 searchindex=56, scope={Pub:main}, scope={Pub:main}
[D] FID[221]: name=value kind=2 fullname=standard.timespan.value(int,int,int,int,int,int) id=standard_timespan_value4
[Y] Update OFUN[76]: ParmNr=7 ParmLow=302 ParmHigh=308
[A] DECL: (standard_timespan_value4)          DECLARE {REF UNDEFINED self,INTEGER days,INTEGER hours,INTEGER minutes,INTEGER seconds,INTEGER millisecs,INTEGER microsecs} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):185:97: "  void value(int days,int hours,int minutes,int seconds,int millisecs,int microsecs,int nanosecs)"
[P] Parsed sentence: [FunDecl] kw(void) id(value) pu(() ty(int) id(days) pu(,) ty(int) id(hours) pu(,) ty(int) id(minutes) pu(,) ty(int) id(seconds) pu(,) ty(int) id(millisecs) pu(,) ty(int) id(microsecs) pu(,) ty(int) id(nanosecs) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;void value(int days,int hours,int minutes,int seconds,int millisecs,int microsecs,int nanosecs)
[Y] Store OFUN[77]: name=value Kind=2 SupTypIndex=16 SubScope=1 Address=0 TypIndex=-1 IsVoid=1 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[222]: name=value kind=Member returns=undefined void=yes nested=no subscope={Pub:timespan}
[Y] Store OPAR[309]: name=self TypIndex=16 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=77
[D] PAR[498]: function=value name=self type=timespan order=0 const=no ref=yes
[Y] Store OPAR[310]: name=days TypIndex=3 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=77
[D] PAR[499]: function=value name=days type=int order=1 const=no ref=no
[Y] Store OPAR[311]: name=hours TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=77
[D] PAR[500]: function=value name=hours type=int order=2 const=no ref=no
[Y] Store OPAR[312]: name=minutes TypIndex=3 IsConst=0 IsReference=0 ParmOrder=3 FunIndex=77
[D] PAR[501]: function=value name=minutes type=int order=3 const=no ref=no
[Y] Store OPAR[313]: name=seconds TypIndex=3 IsConst=0 IsReference=0 ParmOrder=4 FunIndex=77
[D] PAR[502]: function=value name=seconds type=int order=4 const=no ref=no
[Y] Store OPAR[314]: name=millisecs TypIndex=3 IsConst=0 IsReference=0 ParmOrder=5 FunIndex=77
[D] PAR[503]: function=value name=millisecs type=int order=5 const=no ref=no
[Y] Store OPAR[315]: name=microsecs TypIndex=3 IsConst=0 IsReference=0 ParmOrder=6 FunIndex=77
[D] PAR[504]: function=value name=microsecs type=int order=6 const=no ref=no
[Y] Store OPAR[316]: name=nanosecs TypIndex=3 IsConst=0 IsReference=0 ParmOrder=7 FunIndex=77
[D] PAR[505]: function=value name=nanosecs type=int order=7 const=no ref=no
[I] FUN: name=standard.timespan.value(int,int,int,int,int,int,int) index=222 searchindex=184, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.timespan.value($cvint,$cvint,$cvint,$cvint,$cvint,$cvint,$cvint) index=222 searchindex=57, scope={Pub:main}, scope={Pub:main}
[D] FID[222]: name=value kind=2 fullname=standard.timespan.value(int,int,int,int,int,int,int) id=standard_timespan_value5
[Y] Update OFUN[77]: ParmNr=8 ParmLow=309 ParmHigh=316
[A] DECL: (standard_timespan_value5)          DECLARE {REF UNDEFINED self,INTEGER days,INTEGER hours,INTEGER minutes,INTEGER seconds,INTEGER millisecs,INTEGER microsecs,INTEGER nanosecs} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):186:13: "  char sign()"
[P] Parsed sentence: [FunDecl] ty(char) id(sign) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;char sign()
[Y] Store OFUN[78]: name=sign Kind=2 SupTypIndex=16 SubScope=1 Address=0 TypIndex=1 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[223]: name=sign kind=Member returns=char void=no nested=no subscope={Pub:timespan}
[Y] Store OPAR[317]: name=$result TypIndex=1 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=78
[D] PAR[506]: function=sign name=$result type=char order=0 const=no ref=yes
[Y] Store OPAR[318]: name=self TypIndex=16 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=78
[D] PAR[507]: function=sign name=self type=timespan order=1 const=no ref=yes
[I] FUN: name=standard.timespan.sign() index=223 searchindex=175, scope={Pub:main}, scope={Pub:main}
[D] FID[223]: name=sign kind=2 fullname=standard.timespan.sign() id=standard_timespan_sign
[Y] Update OFUN[78]: ParmNr=1 ParmLow=317 ParmHigh=318
[A] DECL: (standard_timespan_sign)            DECLARE {REF CHAR $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):187:12: "  long day()"
[P] Parsed sentence: [FunDecl] ty(long) id(day) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;long day()
[Y] Store OFUN[79]: name=day Kind=2 SupTypIndex=16 SubScope=1 Address=0 TypIndex=4 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[224]: name=day kind=Member returns=long void=no nested=no subscope={Pub:timespan}
[Y] Store OPAR[319]: name=$result TypIndex=4 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=79
[D] PAR[508]: function=day name=$result type=long order=0 const=no ref=yes
[Y] Store OPAR[320]: name=self TypIndex=16 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=79
[D] PAR[509]: function=day name=self type=timespan order=1 const=no ref=yes
[I] FUN: name=standard.timespan.day() index=224 searchindex=175, scope={Pub:main}, scope={Pub:main}
[D] FID[224]: name=day kind=2 fullname=standard.timespan.day() id=standard_timespan_day
[Y] Update OFUN[79]: ParmNr=1 ParmLow=319 ParmHigh=320
[A] DECL: (standard_timespan_day)             DECLARE {REF LONG $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):188:12: "  int hour()"
[P] Parsed sentence: [FunDecl] ty(int) id(hour) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;int hour()
[Y] Store OFUN[80]: name=hour Kind=2 SupTypIndex=16 SubScope=1 Address=0 TypIndex=3 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[225]: name=hour kind=Member returns=int void=no nested=no subscope={Pub:timespan}
[Y] Store OPAR[321]: name=$result TypIndex=3 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=80
[D] PAR[510]: function=hour name=$result type=int order=0 const=no ref=yes
[Y] Store OPAR[322]: name=self TypIndex=16 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=80
[D] PAR[511]: function=hour name=self type=timespan order=1 const=no ref=yes
[I] FUN: name=standard.timespan.hour() index=225 searchindex=176, scope={Pub:main}, scope={Pub:main}
[D] FID[225]: name=hour kind=2 fullname=standard.timespan.hour() id=standard_timespan_hour
[Y] Update OFUN[80]: ParmNr=1 ParmLow=321 ParmHigh=322
[A] DECL: (standard_timespan_hour)            DECLARE {REF INTEGER $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):189:14: "  int minute()"
[P] Parsed sentence: [FunDecl] ty(int) id(minute) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;int minute()
[Y] Store OFUN[81]: name=minute Kind=2 SupTypIndex=16 SubScope=1 Address=0 TypIndex=3 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[226]: name=minute kind=Member returns=int void=no nested=no subscope={Pub:timespan}
[Y] Store OPAR[323]: name=$result TypIndex=3 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=81
[D] PAR[512]: function=minute name=$result type=int order=0 const=no ref=yes
[Y] Store OPAR[324]: name=self TypIndex=16 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=81
[D] PAR[513]: function=minute name=self type=timespan order=1 const=no ref=yes
[I] FUN: name=standard.timespan.minute() index=226 searchindex=177, scope={Pub:main}, scope={Pub:main}
[D] FID[226]: name=minute kind=2 fullname=standard.timespan.minute() id=standard_timespan_minute
[Y] Update OFUN[81]: ParmNr=1 ParmLow=323 ParmHigh=324
[A] DECL: (standard_timespan_minute)          DECLARE {REF INTEGER $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):190:14: "  int second()"
[P] Parsed sentence: [FunDecl] ty(int) id(second) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;int second()
[Y] Store OFUN[82]: name=second Kind=2 SupTypIndex=16 SubScope=1 Address=0 TypIndex=3 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[227]: name=second kind=Member returns=int void=no nested=no subscope={Pub:timespan}
[Y] Store OPAR[325]: name=$result TypIndex=3 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=82
[D] PAR[514]: function=second name=$result type=int order=0 const=no ref=yes
[Y] Store OPAR[326]: name=self TypIndex=16 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=82
[D] PAR[515]: function=second name=self type=timespan order=1 const=no ref=yes
[I] FUN: name=standard.timespan.second() index=227 searchindex=178, scope={Pub:main}, scope={Pub:main}
[D] FID[227]: name=second kind=2 fullname=standard.timespan.second() id=standard_timespan_second
[Y] Update OFUN[82]: ParmNr=1 ParmLow=325 ParmHigh=326
[A] DECL: (standard_timespan_second)          DECLARE {REF INTEGER $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):191:16: "  int millisec()"
[P] Parsed sentence: [FunDecl] ty(int) id(millisec) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;int millisec()
[Y] Store OFUN[83]: name=millisec Kind=2 SupTypIndex=16 SubScope=1 Address=0 TypIndex=3 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[228]: name=millisec kind=Member returns=int void=no nested=no subscope={Pub:timespan}
[Y] Store OPAR[327]: name=$result TypIndex=3 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=83
[D] PAR[516]: function=millisec name=$result type=int order=0 const=no ref=yes
[Y] Store OPAR[328]: name=self TypIndex=16 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=83
[D] PAR[517]: function=millisec name=self type=timespan order=1 const=no ref=yes
[I] FUN: name=standard.timespan.millisec() index=228 searchindex=177, scope={Pub:main}, scope={Pub:main}
[D] FID[228]: name=millisec kind=2 fullname=standard.timespan.millisec() id=standard_timespan_millisec
[Y] Update OFUN[83]: ParmNr=1 ParmLow=327 ParmHigh=328
[A] DECL: (standard_timespan_millisec)        DECLARE {REF INTEGER $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):192:16: "  int microsec()"
[P] Parsed sentence: [FunDecl] ty(int) id(microsec) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;int microsec()
[Y] Store OFUN[84]: name=microsec Kind=2 SupTypIndex=16 SubScope=1 Address=0 TypIndex=3 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[229]: name=microsec kind=Member returns=int void=no nested=no subscope={Pub:timespan}
[Y] Store OPAR[329]: name=$result TypIndex=3 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=84
[D] PAR[518]: function=microsec name=$result type=int order=0 const=no ref=yes
[Y] Store OPAR[330]: name=self TypIndex=16 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=84
[D] PAR[519]: function=microsec name=self type=timespan order=1 const=no ref=yes
[I] FUN: name=standard.timespan.microsec() index=229 searchindex=177, scope={Pub:main}, scope={Pub:main}
[D] FID[229]: name=microsec kind=2 fullname=standard.timespan.microsec() id=standard_timespan_microsec
[Y] Update OFUN[84]: ParmNr=1 ParmLow=329 ParmHigh=330
[A] DECL: (standard_timespan_microsec)        DECLARE {REF INTEGER $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):193:15: "  int nanosec()"
[P] Parsed sentence: [FunDecl] ty(int) id(nanosec) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;int nanosec()
[Y] Store OFUN[85]: name=nanosec Kind=2 SupTypIndex=16 SubScope=1 Address=0 TypIndex=3 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[230]: name=nanosec kind=Member returns=int void=no nested=no subscope={Pub:timespan}
[Y] Store OPAR[331]: name=$result TypIndex=3 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=85
[D] PAR[520]: function=nanosec name=$result type=int order=0 const=no ref=yes
[Y] Store OPAR[332]: name=self TypIndex=16 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=85
[D] PAR[521]: function=nanosec name=self type=timespan order=1 const=no ref=yes
[I] FUN: name=standard.timespan.nanosec() index=230 searchindex=180, scope={Pub:main}, scope={Pub:main}
[D] FID[230]: name=nanosec kind=2 fullname=standard.timespan.nanosec() id=standard_timespan_nanosec
[Y] Update OFUN[85]: ParmNr=1 ParmLow=331 ParmHigh=332
[A] DECL: (standard_timespan_nanosec)         DECLARE {REF INTEGER $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):194:16: "  float indays()"
[P] Parsed sentence: [FunDecl] ty(float) id(indays) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;float indays()
[Y] Store OFUN[86]: name=indays Kind=2 SupTypIndex=16 SubScope=1 Address=0 TypIndex=5 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[231]: name=indays kind=Member returns=float void=no nested=no subscope={Pub:timespan}
[Y] Store OPAR[333]: name=$result TypIndex=5 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=86
[D] PAR[522]: function=indays name=$result type=float order=0 const=no ref=yes
[Y] Store OPAR[334]: name=self TypIndex=16 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=86
[D] PAR[523]: function=indays name=self type=timespan order=1 const=no ref=yes
[I] FUN: name=standard.timespan.indays() index=231 searchindex=177, scope={Pub:main}, scope={Pub:main}
[D] FID[231]: name=indays kind=2 fullname=standard.timespan.indays() id=standard_timespan_indays
[Y] Update OFUN[86]: ParmNr=1 ParmLow=333 ParmHigh=334
[A] DECL: (standard_timespan_indays)          DECLARE {REF FLOAT $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):195:17: "  float inhours()"
[P] Parsed sentence: [FunDecl] ty(float) id(inhours) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;float inhours()
[Y] Store OFUN[87]: name=inhours Kind=2 SupTypIndex=16 SubScope=1 Address=0 TypIndex=5 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[232]: name=inhours kind=Member returns=float void=no nested=no subscope={Pub:timespan}
[Y] Store OPAR[335]: name=$result TypIndex=5 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=87
[D] PAR[524]: function=inhours name=$result type=float order=0 const=no ref=yes
[Y] Store OPAR[336]: name=self TypIndex=16 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=87
[D] PAR[525]: function=inhours name=self type=timespan order=1 const=no ref=yes
[I] FUN: name=standard.timespan.inhours() index=232 searchindex=178, scope={Pub:main}, scope={Pub:main}
[D] FID[232]: name=inhours kind=2 fullname=standard.timespan.inhours() id=standard_timespan_inhours
[Y] Update OFUN[87]: ParmNr=1 ParmLow=335 ParmHigh=336
[A] DECL: (standard_timespan_inhours)         DECLARE {REF FLOAT $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):196:19: "  float inminutes()"
[P] Parsed sentence: [FunDecl] ty(float) id(inminutes) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;float inminutes()
[Y] Store OFUN[88]: name=inminutes Kind=2 SupTypIndex=16 SubScope=1 Address=0 TypIndex=5 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[233]: name=inminutes kind=Member returns=float void=no nested=no subscope={Pub:timespan}
[Y] Store OPAR[337]: name=$result TypIndex=5 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=88
[D] PAR[526]: function=inminutes name=$result type=float order=0 const=no ref=yes
[Y] Store OPAR[338]: name=self TypIndex=16 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=88
[D] PAR[527]: function=inminutes name=self type=timespan order=1 const=no ref=yes
[I] FUN: name=standard.timespan.inminutes() index=233 searchindex=179, scope={Pub:main}, scope={Pub:main}
[D] FID[233]: name=inminutes kind=2 fullname=standard.timespan.inminutes() id=standard_timespan_inminutes
[Y] Update OFUN[88]: ParmNr=1 ParmLow=337 ParmHigh=338
[A] DECL: (standard_timespan_inminutes)       DECLARE {REF FLOAT $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):197:19: "  float inseconds()"
[P] Parsed sentence: [FunDecl] ty(float) id(inseconds) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;float inseconds()
[Y] Store OFUN[89]: name=inseconds Kind=2 SupTypIndex=16 SubScope=1 Address=0 TypIndex=5 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[234]: name=inseconds kind=Member returns=float void=no nested=no subscope={Pub:timespan}
[Y] Store OPAR[339]: name=$result TypIndex=5 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=89
[D] PAR[528]: function=inseconds name=$result type=float order=0 const=no ref=yes
[Y] Store OPAR[340]: name=self TypIndex=16 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=89
[D] PAR[529]: function=inseconds name=self type=timespan order=1 const=no ref=yes
[I] FUN: name=standard.timespan.inseconds() index=234 searchindex=180, scope={Pub:main}, scope={Pub:main}
[D] FID[234]: name=inseconds kind=2 fullname=standard.timespan.inseconds() id=standard_timespan_inseconds
[Y] Update OFUN[89]: ParmNr=1 ParmLow=339 ParmHigh=340
[A] DECL: (standard_timespan_inseconds)       DECLARE {REF FLOAT $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):198:21: "  float inmillisecs()"
[P] Parsed sentence: [FunDecl] ty(float) id(inmillisecs) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;float inmillisecs()
[Y] Store OFUN[90]: name=inmillisecs Kind=2 SupTypIndex=16 SubScope=1 Address=0 TypIndex=5 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[235]: name=inmillisecs kind=Member returns=float void=no nested=no subscope={Pub:timespan}
[Y] Store OPAR[341]: name=$result TypIndex=5 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=90
[D] PAR[530]: function=inmillisecs name=$result type=float order=0 const=no ref=yes
[Y] Store OPAR[342]: name=self TypIndex=16 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=90
[D] PAR[531]: function=inmillisecs name=self type=timespan order=1 const=no ref=yes
[I] FUN: name=standard.timespan.inmillisecs() index=235 searchindex=179, scope={Pub:main}, scope={Pub:main}
[D] FID[235]: name=inmillisecs kind=2 fullname=standard.timespan.inmillisecs() id=standard_timespan_inmillisecs
[Y] Update OFUN[90]: ParmNr=1 ParmLow=341 ParmHigh=342
[A] DECL: (standard_timespan_inmillisecs)     DECLARE {REF FLOAT $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):199:21: "  float inmicrosecs()"
[P] Parsed sentence: [FunDecl] ty(float) id(inmicrosecs) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;float inmicrosecs()
[Y] Store OFUN[91]: name=inmicrosecs Kind=2 SupTypIndex=16 SubScope=1 Address=0 TypIndex=5 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[236]: name=inmicrosecs kind=Member returns=float void=no nested=no subscope={Pub:timespan}
[Y] Store OPAR[343]: name=$result TypIndex=5 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=91
[D] PAR[532]: function=inmicrosecs name=$result type=float order=0 const=no ref=yes
[Y] Store OPAR[344]: name=self TypIndex=16 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=91
[D] PAR[533]: function=inmicrosecs name=self type=timespan order=1 const=no ref=yes
[I] FUN: name=standard.timespan.inmicrosecs() index=236 searchindex=179, scope={Pub:main}, scope={Pub:main}
[D] FID[236]: name=inmicrosecs kind=2 fullname=standard.timespan.inmicrosecs() id=standard_timespan_inmicrosecs
[Y] Update OFUN[91]: ParmNr=1 ParmLow=343 ParmHigh=344
[A] DECL: (standard_timespan_inmicrosecs)     DECLARE {REF FLOAT $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):200:20: "  float innanosecs()"
[P] Parsed sentence: [FunDecl] ty(float) id(innanosecs) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;float innanosecs()
[Y] Store OFUN[92]: name=innanosecs Kind=2 SupTypIndex=16 SubScope=1 Address=0 TypIndex=5 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[237]: name=innanosecs kind=Member returns=float void=no nested=no subscope={Pub:timespan}
[Y] Store OPAR[345]: name=$result TypIndex=5 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=92
[D] PAR[534]: function=innanosecs name=$result type=float order=0 const=no ref=yes
[Y] Store OPAR[346]: name=self TypIndex=16 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=92
[D] PAR[535]: function=innanosecs name=self type=timespan order=1 const=no ref=yes
[I] FUN: name=standard.timespan.innanosecs() index=237 searchindex=182, scope={Pub:main}, scope={Pub:main}
[D] FID[237]: name=innanosecs kind=2 fullname=standard.timespan.innanosecs() id=standard_timespan_innanosecs
[Y] Update OFUN[92]: ParmNr=1 ParmLow=345 ParmHigh=346
[A] DECL: (standard_timespan_innanosecs)      DECLARE {REF FLOAT $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):201:28: "  timespan adddays(int days)"
[P] Parsed sentence: [FunDecl] ty(timespan) id(adddays) pu(() ty(int) id(days) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;timespan adddays(int days)
[Y] Store OFUN[93]: name=adddays Kind=2 SupTypIndex=16 SubScope=1 Address=0 TypIndex=16 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[238]: name=adddays kind=Member returns=timespan void=no nested=no subscope={Pub:timespan}
[Y] Store OPAR[347]: name=$result TypIndex=16 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=93
[D] PAR[536]: function=adddays name=$result type=timespan order=0 const=no ref=yes
[Y] Store OPAR[348]: name=self TypIndex=16 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=93
[D] PAR[537]: function=adddays name=self type=timespan order=1 const=no ref=yes
[Y] Store OPAR[349]: name=days TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=93
[D] PAR[538]: function=adddays name=days type=int order=2 const=no ref=no
[I] FUN: name=standard.timespan.adddays(int) index=238 searchindex=175, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.timespan.adddays($cvint) index=238 searchindex=48, scope={Pub:main}, scope={Pub:main}
[D] FID[238]: name=adddays kind=2 fullname=standard.timespan.adddays(int) id=standard_timespan_adddays
[Y] Update OFUN[93]: ParmNr=3 ParmLow=347 ParmHigh=349
[A] DECL: (standard_timespan_adddays)         DECLARE {REF UNDEFINED $result,REF UNDEFINED self,INTEGER days} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):202:30: "  timespan addhours(int hours)"
[P] Parsed sentence: [FunDecl] ty(timespan) id(addhours) pu(() ty(int) id(hours) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;timespan addhours(int hours)
[Y] Store OFUN[94]: name=addhours Kind=2 SupTypIndex=16 SubScope=1 Address=0 TypIndex=16 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[239]: name=addhours kind=Member returns=timespan void=no nested=no subscope={Pub:timespan}
[Y] Store OPAR[350]: name=$result TypIndex=16 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=94
[D] PAR[539]: function=addhours name=$result type=timespan order=0 const=no ref=yes
[Y] Store OPAR[351]: name=self TypIndex=16 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=94
[D] PAR[540]: function=addhours name=self type=timespan order=1 const=no ref=yes
[Y] Store OPAR[352]: name=hours TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=94
[D] PAR[541]: function=addhours name=hours type=int order=2 const=no ref=no
[I] FUN: name=standard.timespan.addhours(int) index=239 searchindex=176, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.timespan.addhours($cvint) index=239 searchindex=49, scope={Pub:main}, scope={Pub:main}
[D] FID[239]: name=addhours kind=2 fullname=standard.timespan.addhours(int) id=standard_timespan_addhours
[Y] Update OFUN[94]: ParmNr=3 ParmLow=350 ParmHigh=352
[A] DECL: (standard_timespan_addhours)        DECLARE {REF UNDEFINED $result,REF UNDEFINED self,INTEGER hours} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):203:34: "  timespan addminutes(int minutes)"
[P] Parsed sentence: [FunDecl] ty(timespan) id(addminutes) pu(() ty(int) id(minutes) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;timespan addminutes(int minutes)
[Y] Store OFUN[95]: name=addminutes Kind=2 SupTypIndex=16 SubScope=1 Address=0 TypIndex=16 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[240]: name=addminutes kind=Member returns=timespan void=no nested=no subscope={Pub:timespan}
[Y] Store OPAR[353]: name=$result TypIndex=16 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=95
[D] PAR[542]: function=addminutes name=$result type=timespan order=0 const=no ref=yes
[Y] Store OPAR[354]: name=self TypIndex=16 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=95
[D] PAR[543]: function=addminutes name=self type=timespan order=1 const=no ref=yes
[Y] Store OPAR[355]: name=minutes TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=95
[D] PAR[544]: function=addminutes name=minutes type=int order=2 const=no ref=no
[I] FUN: name=standard.timespan.addminutes(int) index=240 searchindex=177, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.timespan.addminutes($cvint) index=240 searchindex=50, scope={Pub:main}, scope={Pub:main}
[D] FID[240]: name=addminutes kind=2 fullname=standard.timespan.addminutes(int) id=standard_timespan_addminutes
[Y] Update OFUN[95]: ParmNr=3 ParmLow=353 ParmHigh=355
[A] DECL: (standard_timespan_addminutes)      DECLARE {REF UNDEFINED $result,REF UNDEFINED self,INTEGER minutes} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):204:34: "  timespan addseconds(int seconds)"
[P] Parsed sentence: [FunDecl] ty(timespan) id(addseconds) pu(() ty(int) id(seconds) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;timespan addseconds(int seconds)
[Y] Store OFUN[96]: name=addseconds Kind=2 SupTypIndex=16 SubScope=1 Address=0 TypIndex=16 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[241]: name=addseconds kind=Member returns=timespan void=no nested=no subscope={Pub:timespan}
[Y] Store OPAR[356]: name=$result TypIndex=16 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=96
[D] PAR[545]: function=addseconds name=$result type=timespan order=0 const=no ref=yes
[Y] Store OPAR[357]: name=self TypIndex=16 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=96
[D] PAR[546]: function=addseconds name=self type=timespan order=1 const=no ref=yes
[Y] Store OPAR[358]: name=seconds TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=96
[D] PAR[547]: function=addseconds name=seconds type=int order=2 const=no ref=no
[I] FUN: name=standard.timespan.addseconds(int) index=241 searchindex=178, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.timespan.addseconds($cvint) index=241 searchindex=51, scope={Pub:main}, scope={Pub:main}
[D] FID[241]: name=addseconds kind=2 fullname=standard.timespan.addseconds(int) id=standard_timespan_addseconds
[Y] Update OFUN[96]: ParmNr=3 ParmLow=356 ParmHigh=358
[A] DECL: (standard_timespan_addseconds)      DECLARE {REF UNDEFINED $result,REF UNDEFINED self,INTEGER seconds} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):205:39: "  timespan addmillisecs(long millisecs)"
[P] Parsed sentence: [FunDecl] ty(timespan) id(addmillisecs) pu(() ty(long) id(millisecs) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;timespan addmillisecs(long millisecs)
[Y] Store OFUN[97]: name=addmillisecs Kind=2 SupTypIndex=16 SubScope=1 Address=0 TypIndex=16 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[242]: name=addmillisecs kind=Member returns=timespan void=no nested=no subscope={Pub:timespan}
[Y] Store OPAR[359]: name=$result TypIndex=16 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=97
[D] PAR[548]: function=addmillisecs name=$result type=timespan order=0 const=no ref=yes
[Y] Store OPAR[360]: name=self TypIndex=16 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=97
[D] PAR[549]: function=addmillisecs name=self type=timespan order=1 const=no ref=yes
[Y] Store OPAR[361]: name=millisecs TypIndex=4 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=97
[D] PAR[550]: function=addmillisecs name=millisecs type=long order=2 const=no ref=no
[I] FUN: name=standard.timespan.addmillisecs(long) index=242 searchindex=177, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.timespan.addmillisecs($cvint) index=242 searchindex=50, scope={Pub:main}, scope={Pub:main}
[D] FID[242]: name=addmillisecs kind=2 fullname=standard.timespan.addmillisecs(long) id=standard_timespan_addmillisecs
[Y] Update OFUN[97]: ParmNr=3 ParmLow=359 ParmHigh=361
[A] DECL: (standard_timespan_addmillisecs)    DECLARE {REF UNDEFINED $result,REF UNDEFINED self,LONG millisecs} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):206:39: "  timespan addmicrosecs(long microsecs)"
[P] Parsed sentence: [FunDecl] ty(timespan) id(addmicrosecs) pu(() ty(long) id(microsecs) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;timespan addmicrosecs(long microsecs)
[Y] Store OFUN[98]: name=addmicrosecs Kind=2 SupTypIndex=16 SubScope=1 Address=0 TypIndex=16 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[243]: name=addmicrosecs kind=Member returns=timespan void=no nested=no subscope={Pub:timespan}
[Y] Store OPAR[362]: name=$result TypIndex=16 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=98
[D] PAR[551]: function=addmicrosecs name=$result type=timespan order=0 const=no ref=yes
[Y] Store OPAR[363]: name=self TypIndex=16 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=98
[D] PAR[552]: function=addmicrosecs name=self type=timespan order=1 const=no ref=yes
[Y] Store OPAR[364]: name=microsecs TypIndex=4 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=98
[D] PAR[553]: function=addmicrosecs name=microsecs type=long order=2 const=no ref=no
[I] FUN: name=standard.timespan.addmicrosecs(long) index=243 searchindex=177, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.timespan.addmicrosecs($cvint) index=243 searchindex=50, scope={Pub:main}, scope={Pub:main}
[D] FID[243]: name=addmicrosecs kind=2 fullname=standard.timespan.addmicrosecs(long) id=standard_timespan_addmicrosecs
[Y] Update OFUN[98]: ParmNr=3 ParmLow=362 ParmHigh=364
[A] DECL: (standard_timespan_addmicrosecs)    DECLARE {REF UNDEFINED $result,REF UNDEFINED self,LONG microsecs} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):207:37: "  timespan addnanosecs(long nanosecs)"
[P] Parsed sentence: [FunDecl] ty(timespan) id(addnanosecs) pu(() ty(long) id(nanosecs) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;timespan addnanosecs(long nanosecs)
[Y] Store OFUN[99]: name=addnanosecs Kind=2 SupTypIndex=16 SubScope=1 Address=0 TypIndex=16 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[244]: name=addnanosecs kind=Member returns=timespan void=no nested=no subscope={Pub:timespan}
[Y] Store OPAR[365]: name=$result TypIndex=16 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=99
[D] PAR[554]: function=addnanosecs name=$result type=timespan order=0 const=no ref=yes
[Y] Store OPAR[366]: name=self TypIndex=16 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=99
[D] PAR[555]: function=addnanosecs name=self type=timespan order=1 const=no ref=yes
[Y] Store OPAR[367]: name=nanosecs TypIndex=4 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=99
[D] PAR[556]: function=addnanosecs name=nanosecs type=long order=2 const=no ref=no
[I] FUN: name=standard.timespan.addnanosecs(long) index=244 searchindex=180, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.timespan.addnanosecs($cvint) index=244 searchindex=53, scope={Pub:main}, scope={Pub:main}
[D] FID[244]: name=addnanosecs kind=2 fullname=standard.timespan.addnanosecs(long) id=standard_timespan_addnanosecs
[Y] Update OFUN[99]: ParmNr=3 ParmLow=365 ParmHigh=367
[A] DECL: (standard_timespan_addnanosecs)     DECLARE {REF UNDEFINED $result,REF UNDEFINED self,LONG nanosecs} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):208:16: "  string tostr()"
[P] Parsed sentence: [FunDecl] ty(string) id(tostr) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;string tostr()
[Y] Store OFUN[100]: name=tostr Kind=2 SupTypIndex=16 SubScope=1 Address=0 TypIndex=6 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[245]: name=tostr kind=Member returns=string void=no nested=no subscope={Pub:timespan}
[Y] Store OPAR[368]: name=$result TypIndex=6 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=100
[D] PAR[557]: function=tostr name=$result type=string order=0 const=no ref=yes
[Y] Store OPAR[369]: name=self TypIndex=16 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=100
[D] PAR[558]: function=tostr name=self type=timespan order=1 const=no ref=yes
[I] FUN: name=standard.timespan.tostr() index=245 searchindex=202, scope={Pub:main}, scope={Pub:main}
[D] FID[245]: name=tostr kind=2 fullname=standard.timespan.tostr() id=standard_timespan_tostr
[Y] Update OFUN[100]: ParmNr=1 ParmLow=368 ParmHigh=369
[A] DECL: (standard_timespan_tostr)           DECLARE {REF STRINGBLOCK $result,REF UNDEFINED self} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):209:26: "  string tostr(char delim)"
[P] Parsed sentence: [FunDecl] ty(string) id(tostr) pu(() ty(char) id(delim) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;string tostr(char delim)
[Y] Store OFUN[101]: name=tostr Kind=2 SupTypIndex=16 SubScope=1 Address=0 TypIndex=6 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[246]: name=tostr kind=Member returns=string void=no nested=no subscope={Pub:timespan}
[Y] Store OPAR[370]: name=$result TypIndex=6 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=101
[D] PAR[559]: function=tostr name=$result type=string order=0 const=no ref=yes
[Y] Store OPAR[371]: name=self TypIndex=16 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=101
[D] PAR[560]: function=tostr name=self type=timespan order=1 const=no ref=yes
[Y] Store OPAR[372]: name=delim TypIndex=1 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=101
[D] PAR[561]: function=tostr name=delim type=char order=2 const=no ref=no
[I] FUN: name=standard.timespan.tostr(char) index=246 searchindex=203, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.timespan.tostr($cvint) index=246 searchindex=60, scope={Pub:main}, scope={Pub:main}
[D] FID[246]: name=tostr kind=2 fullname=standard.timespan.tostr(char) id=standard_timespan_tostr2
[Y] Update OFUN[101]: ParmNr=3 ParmLow=370 ParmHigh=372
[A] DECL: (standard_timespan_tostr2)          DECLARE {REF STRINGBLOCK $result,REF UNDEFINED self,CHAR delim} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):210:7: "  .priv"
[P] Parsed sentence: [Priv] kw(.priv)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[S] Subscope end: {Pub:timespan}
[S] Subscope begin: {Pri:timespan}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):211:12: "  char _sign"
[P] Parsed sentence: [VarDecl] ty(char) id(_sign)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;char _sign
[D] FLD[22]: type=char name=_sign subscope={Pri:timespan} offset=0 static=no enumvalue=0
[P] -------------------------------------------------------------------------------------
[L] Read line (src):212:12: "  long _days"
[P] Parsed sentence: [VarDecl] ty(long) id(_days)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;long _days
[D] FLD[23]: type=long name=_days subscope={Pri:timespan} offset=1 static=no enumvalue=0
[P] -------------------------------------------------------------------------------------
[L] Read line (src):213:12: "  long _nsec"
[P] Parsed sentence: [VarDecl] ty(long) id(_nsec)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;long _nsec
[D] FLD[24]: type=long name=_nsec subscope={Pri:timespan} offset=9 static=no enumvalue=0
[P] -------------------------------------------------------------------------------------
[L] Read line (src):214:22: "  allow [+]() to _sign"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(+) pu(]) pu(() pu()) kw(to) id(_sign)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[32]: name=OPFI:[+]()->standard.timespan._sign
[I] GRA: name=OPFI:[+]()->standard.timespan._sign index=32 searchindex=8, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):215:22: "  allow [+]() to _days"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(+) pu(]) pu(() pu()) kw(to) id(_days)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[33]: name=OPFI:[+]()->standard.timespan._days
[I] GRA: name=OPFI:[+]()->standard.timespan._days index=33 searchindex=8, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):216:22: "  allow [+]() to _nsec"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(+) pu(]) pu(() pu()) kw(to) id(_nsec)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[34]: name=OPFI:[+]()->standard.timespan._nsec
[I] GRA: name=OPFI:[+]()->standard.timespan._nsec index=34 searchindex=9, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):217:22: "  allow [-]() to _sign"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(-) pu(]) pu(() pu()) kw(to) id(_sign)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[35]: name=OPFI:[-]()->standard.timespan._sign
[I] GRA: name=OPFI:[-]()->standard.timespan._sign index=35 searchindex=15, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):218:22: "  allow [-]() to _days"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(-) pu(]) pu(() pu()) kw(to) id(_days)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[36]: name=OPFI:[-]()->standard.timespan._days
[I] GRA: name=OPFI:[-]()->standard.timespan._days index=36 searchindex=15, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):219:22: "  allow [-]() to _nsec"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(-) pu(]) pu(() pu()) kw(to) id(_nsec)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[37]: name=OPFI:[-]()->standard.timespan._nsec
[I] GRA: name=OPFI:[-]()->standard.timespan._nsec index=37 searchindex=16, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):220:23: "  allow [==]() to _sign"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(==) pu(]) pu(() pu()) kw(to) id(_sign)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[38]: name=OPFI:[==]()->standard.timespan._sign
[I] GRA: name=OPFI:[==]()->standard.timespan._sign index=38 searchindex=30, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):221:23: "  allow [!=]() to _sign"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(!=) pu(]) pu(() pu()) kw(to) id(_sign)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[39]: name=OPFI:[!=]()->standard.timespan._sign
[I] GRA: name=OPFI:[!=]()->standard.timespan._sign index=39 searchindex=4, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):222:22: "  allow [<]() to _sign"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(<) pu(]) pu(() pu()) kw(to) id(_sign)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[40]: name=OPFI:[<]()->standard.timespan._sign
[I] GRA: name=OPFI:[<]()->standard.timespan._sign index=40 searchindex=27, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):223:22: "  allow [>]() to _sign"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(>) pu(]) pu(() pu()) kw(to) id(_sign)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[41]: name=OPFI:[>]()->standard.timespan._sign
[I] GRA: name=OPFI:[>]()->standard.timespan._sign index=41 searchindex=41, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):224:23: "  allow [<=]() to _sign"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(<=) pu(]) pu(() pu()) kw(to) id(_sign)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[42]: name=OPFI:[<=]()->standard.timespan._sign
[I] GRA: name=OPFI:[<=]()->standard.timespan._sign index=42 searchindex=23, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):225:23: "  allow [>=]() to _sign"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(>=) pu(]) pu(() pu()) kw(to) id(_sign)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[43]: name=OPFI:[>=]()->standard.timespan._sign
[I] GRA: name=OPFI:[>=]()->standard.timespan._sign index=43 searchindex=38, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):226:23: "  allow [==]() to _days"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(==) pu(]) pu(() pu()) kw(to) id(_days)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[44]: name=OPFI:[==]()->standard.timespan._days
[I] GRA: name=OPFI:[==]()->standard.timespan._days index=44 searchindex=33, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):227:23: "  allow [!=]() to _days"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(!=) pu(]) pu(() pu()) kw(to) id(_days)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[45]: name=OPFI:[!=]()->standard.timespan._days
[I] GRA: name=OPFI:[!=]()->standard.timespan._days index=45 searchindex=4, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):228:22: "  allow [<]() to _days"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(<) pu(]) pu(() pu()) kw(to) id(_days)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[46]: name=OPFI:[<]()->standard.timespan._days
[I] GRA: name=OPFI:[<]()->standard.timespan._days index=46 searchindex=29, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):229:22: "  allow [>]() to _days"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(>) pu(]) pu(() pu()) kw(to) id(_days)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[47]: name=OPFI:[>]()->standard.timespan._days
[I] GRA: name=OPFI:[>]()->standard.timespan._days index=47 searchindex=46, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):230:23: "  allow [<=]() to _days"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(<=) pu(]) pu(() pu()) kw(to) id(_days)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[48]: name=OPFI:[<=]()->standard.timespan._days
[I] GRA: name=OPFI:[<=]()->standard.timespan._days index=48 searchindex=24, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):231:23: "  allow [>=]() to _days"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(>=) pu(]) pu(() pu()) kw(to) id(_days)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[49]: name=OPFI:[>=]()->standard.timespan._days
[I] GRA: name=OPFI:[>=]()->standard.timespan._days index=49 searchindex=42, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):232:23: "  allow [==]() to _nsec"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(==) pu(]) pu(() pu()) kw(to) id(_nsec)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[50]: name=OPFI:[==]()->standard.timespan._nsec
[I] GRA: name=OPFI:[==]()->standard.timespan._nsec index=50 searchindex=37, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):233:23: "  allow [!=]() to _nsec"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(!=) pu(]) pu(() pu()) kw(to) id(_nsec)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[51]: name=OPFI:[!=]()->standard.timespan._nsec
[I] GRA: name=OPFI:[!=]()->standard.timespan._nsec index=51 searchindex=5, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):234:22: "  allow [<]() to _nsec"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(<) pu(]) pu(() pu()) kw(to) id(_nsec)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[52]: name=OPFI:[<]()->standard.timespan._nsec
[I] GRA: name=OPFI:[<]()->standard.timespan._nsec index=52 searchindex=32, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):235:22: "  allow [>]() to _nsec"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(>) pu(]) pu(() pu()) kw(to) id(_nsec)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[53]: name=OPFI:[>]()->standard.timespan._nsec
[I] GRA: name=OPFI:[>]()->standard.timespan._nsec index=53 searchindex=52, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):236:23: "  allow [<=]() to _nsec"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(<=) pu(]) pu(() pu()) kw(to) id(_nsec)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[54]: name=OPFI:[<=]()->standard.timespan._nsec
[I] GRA: name=OPFI:[<=]()->standard.timespan._nsec index=54 searchindex=26, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):237:23: "  allow [>=]() to _nsec"
[P] Parsed sentence: [Allow] kw(allow) pu([) op(>=) pu(]) pu(() pu()) kw(to) id(_nsec)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[D] GRA[55]: name=OPFI:[>=]()->standard.timespan._nsec
[I] GRA: name=OPFI:[>=]()->standard.timespan._nsec index=55 searchindex=47, scope={Pub:main}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):238:6: ":class"
[P] Parsed sentence: [EndClass] kw(:class)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000000h, LocBlk=00000057h
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000004h, LocBlk=00000057h
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000008h, LocBlk=00000057h
[O] Relocation added: Type=BlkInsideGlo, LocAdr=00000000000000E0h
[A] DATA:                                     STORE {"_sign"                                                  ;Address=[00000000000000E0h]
[A] DATA:                                     STORE  "_days",
[A] DATA:                                     STORE  "_nsec"}
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000000h, LocBlk=0000005Bh
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000004h, LocBlk=0000005Bh
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000008h, LocBlk=0000005Bh
[O] Relocation added: Type=BlkInsideGlo, LocAdr=00000000000000E4h
[A] DATA:                                     STORE {"char"                                                   ;Address=[00000000000000E4h]
[A] DATA:                                     STORE  "long",
[A] DATA:                                     STORE  "long"}
[Y] Update OTYP[16]: MetaStNames=224 MetaStTypes=228 Length=17 FieldLow=-1 FieldHigh=-1
[S] Subscope end: {Pri:timespan}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):241:44: "bool isdatevalid(int year,int month,int day)"
[P] Parsed sentence: [FunDecl] ty(bool) id(isdatevalid) pu(() ty(int) id(year) pu(,) ty(int) id(month) pu(,) ty(int) id(day) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;bool isdatevalid(int year,int month,int day)
[Y] Store OFUN[102]: name=isdatevalid Kind=0 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[247]: name=isdatevalid kind=Function returns=bool void=no nested=no scope={Pub:main}
[Y] Store OPAR[373]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=102
[D] PAR[562]: function=isdatevalid name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[374]: name=year TypIndex=3 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=102
[D] PAR[563]: function=isdatevalid name=year type=int order=1 const=no ref=no
[Y] Store OPAR[375]: name=month TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=102
[D] PAR[564]: function=isdatevalid name=month type=int order=2 const=no ref=no
[Y] Store OPAR[376]: name=day TypIndex=3 IsConst=0 IsReference=0 ParmOrder=3 FunIndex=102
[D] PAR[565]: function=isdatevalid name=day type=int order=3 const=no ref=no
[I] FUN: name=standard.isdatevalid(int,int,int) index=247 searchindex=153, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.isdatevalid($cvint,$cvint,$cvint) index=247 searchindex=33, scope={Pub:main}, scope={Pub:main}
[D] FID[247]: name=isdatevalid kind=0 fullname=standard.isdatevalid(int,int,int) id=standard_isdatevalid
[Y] Update OFUN[102]: ParmNr=4 ParmLow=373 ParmHigh=376
[A] DECL: (standard_isdatevalid)              DECLARE {REF BOOLEAN $result,INTEGER year,INTEGER month,INTEGER day} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):242:51: "bool istimevalid(int hours,int minutes,int seconds)"
[P] Parsed sentence: [FunDecl] ty(bool) id(istimevalid) pu(() ty(int) id(hours) pu(,) ty(int) id(minutes) pu(,) ty(int) id(seconds) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;bool istimevalid(int hours,int minutes,int seconds)
[Y] Store OFUN[103]: name=istimevalid Kind=0 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[248]: name=istimevalid kind=Function returns=bool void=no nested=no scope={Pub:main}
[Y] Store OPAR[377]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=103
[D] PAR[566]: function=istimevalid name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[378]: name=hours TypIndex=3 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=103
[D] PAR[567]: function=istimevalid name=hours type=int order=1 const=no ref=no
[Y] Store OPAR[379]: name=minutes TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=103
[D] PAR[568]: function=istimevalid name=minutes type=int order=2 const=no ref=no
[Y] Store OPAR[380]: name=seconds TypIndex=3 IsConst=0 IsReference=0 ParmOrder=3 FunIndex=103
[D] PAR[569]: function=istimevalid name=seconds type=int order=3 const=no ref=no
[I] FUN: name=standard.istimevalid(int,int,int) index=248 searchindex=154, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.istimevalid($cvint,$cvint,$cvint) index=248 searchindex=34, scope={Pub:main}, scope={Pub:main}
[D] FID[248]: name=istimevalid kind=0 fullname=standard.istimevalid(int,int,int) id=standard_istimevalid
[Y] Update OFUN[103]: ParmNr=4 ParmLow=377 ParmHigh=380
[A] DECL: (standard_istimevalid)              DECLARE {REF BOOLEAN $result,INTEGER hours,INTEGER minutes,INTEGER seconds} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):243:65: "bool istimevalid(int hours,int minutes,int seconds,int millisecs)"
[P] Parsed sentence: [FunDecl] ty(bool) id(istimevalid) pu(() ty(int) id(hours) pu(,) ty(int) id(minutes) pu(,) ty(int) id(seconds) pu(,) ty(int) id(millisecs) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;bool istimevalid(int hours,int minutes,int seconds,int millisecs)
[Y] Store OFUN[104]: name=istimevalid Kind=0 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[249]: name=istimevalid kind=Function returns=bool void=no nested=no scope={Pub:main}
[Y] Store OPAR[381]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=104
[D] PAR[570]: function=istimevalid name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[382]: name=hours TypIndex=3 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=104
[D] PAR[571]: function=istimevalid name=hours type=int order=1 const=no ref=no
[Y] Store OPAR[383]: name=minutes TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=104
[D] PAR[572]: function=istimevalid name=minutes type=int order=2 const=no ref=no
[Y] Store OPAR[384]: name=seconds TypIndex=3 IsConst=0 IsReference=0 ParmOrder=3 FunIndex=104
[D] PAR[573]: function=istimevalid name=seconds type=int order=3 const=no ref=no
[Y] Store OPAR[385]: name=millisecs TypIndex=3 IsConst=0 IsReference=0 ParmOrder=4 FunIndex=104
[D] PAR[574]: function=istimevalid name=millisecs type=int order=4 const=no ref=no
[I] FUN: name=standard.istimevalid(int,int,int,int) index=249 searchindex=155, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.istimevalid($cvint,$cvint,$cvint,$cvint) index=249 searchindex=35, scope={Pub:main}, scope={Pub:main}
[D] FID[249]: name=istimevalid kind=0 fullname=standard.istimevalid(int,int,int,int) id=standard_istimevalid2
[Y] Update OFUN[104]: ParmNr=5 ParmLow=381 ParmHigh=385
[A] DECL: (standard_istimevalid2)             DECLARE {REF BOOLEAN $result,INTEGER hours,INTEGER minutes,INTEGER seconds,INTEGER millisecs} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):244:79: "bool istimevalid(int hours,int minutes,int seconds,int millisecs,int microsecs)"
[P] Parsed sentence: [FunDecl] ty(bool) id(istimevalid) pu(() ty(int) id(hours) pu(,) ty(int) id(minutes) pu(,) ty(int) id(seconds) pu(,) ty(int) id(millisecs) pu(,) ty(int) id(microsecs) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;bool istimevalid(int hours,int minutes,int seconds,int millisecs,int microsecs)
[Y] Store OFUN[105]: name=istimevalid Kind=0 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[250]: name=istimevalid kind=Function returns=bool void=no nested=no scope={Pub:main}
[Y] Store OPAR[386]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=105
[D] PAR[575]: function=istimevalid name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[387]: name=hours TypIndex=3 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=105
[D] PAR[576]: function=istimevalid name=hours type=int order=1 const=no ref=no
[Y] Store OPAR[388]: name=minutes TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=105
[D] PAR[577]: function=istimevalid name=minutes type=int order=2 const=no ref=no
[Y] Store OPAR[389]: name=seconds TypIndex=3 IsConst=0 IsReference=0 ParmOrder=3 FunIndex=105
[D] PAR[578]: function=istimevalid name=seconds type=int order=3 const=no ref=no
[Y] Store OPAR[390]: name=millisecs TypIndex=3 IsConst=0 IsReference=0 ParmOrder=4 FunIndex=105
[D] PAR[579]: function=istimevalid name=millisecs type=int order=4 const=no ref=no
[Y] Store OPAR[391]: name=microsecs TypIndex=3 IsConst=0 IsReference=0 ParmOrder=5 FunIndex=105
[D] PAR[580]: function=istimevalid name=microsecs type=int order=5 const=no ref=no
[I] FUN: name=standard.istimevalid(int,int,int,int,int) index=250 searchindex=156, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.istimevalid($cvint,$cvint,$cvint,$cvint,$cvint) index=250 searchindex=36, scope={Pub:main}, scope={Pub:main}
[D] FID[250]: name=istimevalid kind=0 fullname=standard.istimevalid(int,int,int,int,int) id=standard_istimevalid3
[Y] Update OFUN[105]: ParmNr=6 ParmLow=386 ParmHigh=391
[A] DECL: (standard_istimevalid3)             DECLARE {REF BOOLEAN $result,INTEGER hours,INTEGER minutes,INTEGER seconds,INTEGER millisecs,INTEGER microsecs} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):245:92: "bool istimevalid(int hours,int minutes,int seconds,int millisecs,int microsecs,int nanosecs)"
[P] Parsed sentence: [FunDecl] ty(bool) id(istimevalid) pu(() ty(int) id(hours) pu(,) ty(int) id(minutes) pu(,) ty(int) id(seconds) pu(,) ty(int) id(millisecs) pu(,) ty(int) id(microsecs) pu(,) ty(int) id(nanosecs) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;bool istimevalid(int hours,int minutes,int seconds,int millisecs,int microsecs,int nanosecs)
[Y] Store OFUN[106]: name=istimevalid Kind=0 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[251]: name=istimevalid kind=Function returns=bool void=no nested=no scope={Pub:main}
[Y] Store OPAR[392]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=106
[D] PAR[581]: function=istimevalid name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[393]: name=hours TypIndex=3 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=106
[D] PAR[582]: function=istimevalid name=hours type=int order=1 const=no ref=no
[Y] Store OPAR[394]: name=minutes TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=106
[D] PAR[583]: function=istimevalid name=minutes type=int order=2 const=no ref=no
[Y] Store OPAR[395]: name=seconds TypIndex=3 IsConst=0 IsReference=0 ParmOrder=3 FunIndex=106
[D] PAR[584]: function=istimevalid name=seconds type=int order=3 const=no ref=no
[Y] Store OPAR[396]: name=millisecs TypIndex=3 IsConst=0 IsReference=0 ParmOrder=4 FunIndex=106
[D] PAR[585]: function=istimevalid name=millisecs type=int order=4 const=no ref=no
[Y] Store OPAR[397]: name=microsecs TypIndex=3 IsConst=0 IsReference=0 ParmOrder=5 FunIndex=106
[D] PAR[586]: function=istimevalid name=microsecs type=int order=5 const=no ref=no
[Y] Store OPAR[398]: name=nanosecs TypIndex=3 IsConst=0 IsReference=0 ParmOrder=6 FunIndex=106
[D] PAR[587]: function=istimevalid name=nanosecs type=int order=6 const=no ref=no
[I] FUN: name=standard.istimevalid(int,int,int,int,int,int) index=251 searchindex=157, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.istimevalid($cvint,$cvint,$cvint,$cvint,$cvint,$cvint) index=251 searchindex=37, scope={Pub:main}, scope={Pub:main}
[D] FID[251]: name=istimevalid kind=0 fullname=standard.istimevalid(int,int,int,int,int,int) id=standard_istimevalid4
[Y] Update OFUN[106]: ParmNr=7 ParmLow=392 ParmHigh=398
[A] DECL: (standard_istimevalid4)             DECLARE {REF BOOLEAN $result,INTEGER hours,INTEGER minutes,INTEGER seconds,INTEGER millisecs,INTEGER microsecs,INTEGER nanosecs} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):246:14: "date getdate()"
[P] Parsed sentence: [FunDecl] ty(date) id(getdate) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;date getdate()
[Y] Store OFUN[107]: name=getdate Kind=0 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=13 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[252]: name=getdate kind=Function returns=date void=no nested=no scope={Pub:main}
[Y] Store OPAR[399]: name=$result TypIndex=13 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=107
[D] PAR[588]: function=getdate name=$result type=date order=0 const=no ref=yes
[I] FUN: name=standard.getdate() index=252 searchindex=153, scope={Pub:main}, scope={Pub:main}
[D] FID[252]: name=getdate kind=0 fullname=standard.getdate() id=standard_getdate
[Y] Update OFUN[107]: ParmNr=1 ParmLow=399 ParmHigh=399
[A] DECL: (standard_getdate)                  DECLARE {REF UNDEFINED $result} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):247:14: "time gettime()"
[P] Parsed sentence: [FunDecl] ty(time) id(gettime) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;time gettime()
[Y] Store OFUN[108]: name=gettime Kind=0 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=14 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[253]: name=gettime kind=Function returns=time void=no nested=no scope={Pub:main}
[Y] Store OPAR[400]: name=$result TypIndex=14 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=108
[D] PAR[589]: function=gettime name=$result type=time order=0 const=no ref=yes
[I] FUN: name=standard.gettime() index=253 searchindex=154, scope={Pub:main}, scope={Pub:main}
[D] FID[253]: name=gettime kind=0 fullname=standard.gettime() id=standard_gettime
[Y] Update OFUN[108]: ParmNr=1 ParmLow=400 ParmHigh=400
[A] DECL: (standard_gettime)                  DECLARE {REF UNDEFINED $result} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):248:17: "date getutcdate()"
[P] Parsed sentence: [FunDecl] ty(date) id(getutcdate) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;date getutcdate()
[Y] Store OFUN[109]: name=getutcdate Kind=0 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=13 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[254]: name=getutcdate kind=Function returns=date void=no nested=no scope={Pub:main}
[Y] Store OPAR[401]: name=$result TypIndex=13 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=109
[D] PAR[590]: function=getutcdate name=$result type=date order=0 const=no ref=yes
[I] FUN: name=standard.getutcdate() index=254 searchindex=155, scope={Pub:main}, scope={Pub:main}
[D] FID[254]: name=getutcdate kind=0 fullname=standard.getutcdate() id=standard_getutcdate
[Y] Update OFUN[109]: ParmNr=1 ParmLow=401 ParmHigh=401
[A] DECL: (standard_getutcdate)               DECLARE {REF UNDEFINED $result} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):249:17: "time getutctime()"
[P] Parsed sentence: [FunDecl] ty(time) id(getutctime) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;time getutctime()
[Y] Store OFUN[110]: name=getutctime Kind=0 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=14 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[255]: name=getutctime kind=Function returns=time void=no nested=no scope={Pub:main}
[Y] Store OPAR[402]: name=$result TypIndex=14 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=110
[D] PAR[591]: function=getutctime name=$result type=time order=0 const=no ref=yes
[I] FUN: name=standard.getutctime() index=255 searchindex=156, scope={Pub:main}, scope={Pub:main}
[D] FID[255]: name=getutctime kind=0 fullname=standard.getutctime() id=standard_getutctime
[Y] Update OFUN[110]: ParmNr=1 ParmLow=402 ParmHigh=402
[A] DECL: (standard_getutctime)               DECLARE {REF UNDEFINED $result} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):250:22: "datetime getdatetime()"
[P] Parsed sentence: [FunDecl] ty(datetime) id(getdatetime) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;datetime getdatetime()
[Y] Store OFUN[111]: name=getdatetime Kind=0 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=15 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[256]: name=getdatetime kind=Function returns=datetime void=no nested=no scope={Pub:main}
[Y] Store OPAR[403]: name=$result TypIndex=15 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=111
[D] PAR[592]: function=getdatetime name=$result type=datetime order=0 const=no ref=yes
[I] FUN: name=standard.getdatetime() index=256 searchindex=154, scope={Pub:main}, scope={Pub:main}
[D] FID[256]: name=getdatetime kind=0 fullname=standard.getdatetime() id=standard_getdatetime
[Y] Update OFUN[111]: ParmNr=1 ParmLow=403 ParmHigh=403
[A] DECL: (standard_getdatetime)              DECLARE {REF UNDEFINED $result} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):251:25: "datetime getutcdatetime()"
[P] Parsed sentence: [FunDecl] ty(datetime) id(getutcdatetime) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;datetime getutcdatetime()
[Y] Store OFUN[112]: name=getutcdatetime Kind=0 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=15 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[257]: name=getutcdatetime kind=Function returns=datetime void=no nested=no scope={Pub:main}
[Y] Store OPAR[404]: name=$result TypIndex=15 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=112
[D] PAR[593]: function=getutcdatetime name=$result type=datetime order=0 const=no ref=yes
[I] FUN: name=standard.getutcdatetime() index=257 searchindex=157, scope={Pub:main}, scope={Pub:main}
[D] FID[257]: name=getutcdatetime kind=0 fullname=standard.getutcdatetime() id=standard_getutcdatetime
[Y] Update OFUN[112]: ParmNr=1 ParmLow=404 ParmHigh=404
[A] DECL: (standard_getutcdatetime)           DECLARE {REF UNDEFINED $result} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):252:33: "timespan [-](date end,date start)"
[P] Parsed sentence: [FunDecl] ty(timespan) pu([) op(-) pu(]) pu(() ty(date) id(end) pu(,) ty(date) id(start) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;timespan [-](date end,date start)
[Y] Store OFUN[113]: name=[-] Kind=6 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=16 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[258]: name=[-] kind=Operator returns=timespan void=no nested=no
[Y] Store OPAR[405]: name=$result TypIndex=16 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=113
[D] PAR[594]: function=[-] name=$result type=timespan order=0 const=no ref=yes
[Y] Store OPAR[406]: name=end TypIndex=13 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=113
[D] PAR[595]: function=[-] name=end type=date order=1 const=yes ref=yes
[Y] Store OPAR[407]: name=start TypIndex=13 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=113
[D] PAR[596]: function=[-] name=start type=date order=2 const=yes ref=yes
[I] FUN: name=[-](date,date) index=258 searchindex=0, scope={Pub:main}, scope={Pub:main}
[D] FID[258]: name=[-] kind=6 fullname=[-](date,date) id=[-]
[Y] Update OFUN[113]: ParmNr=3 ParmLow=405 ParmHigh=407
[A] DECL: ([-])                               DECLARE {REF UNDEFINED $result,CONST REF UNDEFINED end,CONST REF UNDEFINED start} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):253:33: "timespan [-](time end,time start)"
[P] Parsed sentence: [FunDecl] ty(timespan) pu([) op(-) pu(]) pu(() ty(time) id(end) pu(,) ty(time) id(start) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;timespan [-](time end,time start)
[Y] Store OFUN[114]: name=[-] Kind=6 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=16 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[259]: name=[-] kind=Operator returns=timespan void=no nested=no
[Y] Store OPAR[408]: name=$result TypIndex=16 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=114
[D] PAR[597]: function=[-] name=$result type=timespan order=0 const=no ref=yes
[Y] Store OPAR[409]: name=end TypIndex=14 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=114
[D] PAR[598]: function=[-] name=end type=time order=1 const=yes ref=yes
[Y] Store OPAR[410]: name=start TypIndex=14 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=114
[D] PAR[599]: function=[-] name=start type=time order=2 const=yes ref=yes
[I] FUN: name=[-](time,time) index=259 searchindex=1, scope={Pub:main}, scope={Pub:main}
[D] FID[259]: name=[-] kind=6 fullname=[-](time,time) id=[-]2
[Y] Update OFUN[114]: ParmNr=3 ParmLow=408 ParmHigh=410
[A] DECL: ([-]2)                              DECLARE {REF UNDEFINED $result,CONST REF UNDEFINED end,CONST REF UNDEFINED start} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):254:41: "timespan [-](datetime end,datetime start)"
[P] Parsed sentence: [FunDecl] ty(timespan) pu([) op(-) pu(]) pu(() ty(datetime) id(end) pu(,) ty(datetime) id(start) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;timespan [-](datetime end,datetime start)
[Y] Store OFUN[115]: name=[-] Kind=6 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=16 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[260]: name=[-] kind=Operator returns=timespan void=no nested=no
[Y] Store OPAR[411]: name=$result TypIndex=16 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=115
[D] PAR[600]: function=[-] name=$result type=timespan order=0 const=no ref=yes
[Y] Store OPAR[412]: name=end TypIndex=15 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=115
[D] PAR[601]: function=[-] name=end type=datetime order=1 const=yes ref=yes
[Y] Store OPAR[413]: name=start TypIndex=15 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=115
[D] PAR[602]: function=[-] name=start type=datetime order=2 const=yes ref=yes
[I] FUN: name=[-](datetime,datetime) index=260 searchindex=1, scope={Pub:main}, scope={Pub:main}
[D] FID[260]: name=[-] kind=6 fullname=[-](datetime,datetime) id=[-]3
[Y] Update OFUN[115]: ParmNr=3 ParmLow=411 ParmHigh=413
[A] DECL: ([-]3)                              DECLARE {REF UNDEFINED $result,CONST REF UNDEFINED end,CONST REF UNDEFINED start} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):255:29: "date [+](date dt,timespan ts)"
[P] Parsed sentence: [FunDecl] ty(date) pu([) op(+) pu(]) pu(() ty(date) id(dt) pu(,) ty(timespan) id(ts) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;date [+](date dt,timespan ts)
[Y] Store OFUN[116]: name=[+] Kind=6 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=13 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[261]: name=[+] kind=Operator returns=date void=no nested=no
[Y] Store OPAR[414]: name=$result TypIndex=13 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=116
[D] PAR[603]: function=[+] name=$result type=date order=0 const=no ref=yes
[Y] Store OPAR[415]: name=dt TypIndex=13 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=116
[D] PAR[604]: function=[+] name=dt type=date order=1 const=yes ref=yes
[Y] Store OPAR[416]: name=ts TypIndex=16 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=116
[D] PAR[605]: function=[+] name=ts type=timespan order=2 const=yes ref=yes
[I] FUN: name=[+](date,timespan) index=261 searchindex=0, scope={Pub:main}, scope={Pub:main}
[D] FID[261]: name=[+] kind=6 fullname=[+](date,timespan) id=[+]
[Y] Update OFUN[116]: ParmNr=3 ParmLow=414 ParmHigh=416
[A] DECL: ([+])                               DECLARE {REF UNDEFINED $result,CONST REF UNDEFINED dt,CONST REF UNDEFINED ts} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):256:29: "time [+](time tm,timespan ts)"
[P] Parsed sentence: [FunDecl] ty(time) pu([) op(+) pu(]) pu(() ty(time) id(tm) pu(,) ty(timespan) id(ts) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;time [+](time tm,timespan ts)
[Y] Store OFUN[117]: name=[+] Kind=6 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=14 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[262]: name=[+] kind=Operator returns=time void=no nested=no
[Y] Store OPAR[417]: name=$result TypIndex=14 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=117
[D] PAR[606]: function=[+] name=$result type=time order=0 const=no ref=yes
[Y] Store OPAR[418]: name=tm TypIndex=14 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=117
[D] PAR[607]: function=[+] name=tm type=time order=1 const=yes ref=yes
[Y] Store OPAR[419]: name=ts TypIndex=16 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=117
[D] PAR[608]: function=[+] name=ts type=timespan order=2 const=yes ref=yes
[I] FUN: name=[+](time,timespan) index=262 searchindex=1, scope={Pub:main}, scope={Pub:main}
[D] FID[262]: name=[+] kind=6 fullname=[+](time,timespan) id=[+]2
[Y] Update OFUN[117]: ParmNr=3 ParmLow=417 ParmHigh=419
[A] DECL: ([+]2)                              DECLARE {REF UNDEFINED $result,CONST REF UNDEFINED tm,CONST REF UNDEFINED ts} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):257:37: "datetime [+](datetime dm,timespan ts)"
[P] Parsed sentence: [FunDecl] ty(datetime) pu([) op(+) pu(]) pu(() ty(datetime) id(dm) pu(,) ty(timespan) id(ts) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;datetime [+](datetime dm,timespan ts)
[Y] Store OFUN[118]: name=[+] Kind=6 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=15 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[263]: name=[+] kind=Operator returns=datetime void=no nested=no
[Y] Store OPAR[420]: name=$result TypIndex=15 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=118
[D] PAR[609]: function=[+] name=$result type=datetime order=0 const=no ref=yes
[Y] Store OPAR[421]: name=dm TypIndex=15 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=118
[D] PAR[610]: function=[+] name=dm type=datetime order=1 const=yes ref=yes
[Y] Store OPAR[422]: name=ts TypIndex=16 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=118
[D] PAR[611]: function=[+] name=ts type=timespan order=2 const=yes ref=yes
[I] FUN: name=[+](datetime,timespan) index=263 searchindex=1, scope={Pub:main}, scope={Pub:main}
[D] FID[263]: name=[+] kind=6 fullname=[+](datetime,timespan) id=[+]3
[Y] Update OFUN[118]: ParmNr=3 ParmLow=420 ParmHigh=422
[A] DECL: ([+]3)                              DECLARE {REF UNDEFINED $result,CONST REF UNDEFINED dm,CONST REF UNDEFINED ts} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):258:29: "date [-](date dt,timespan ts)"
[P] Parsed sentence: [FunDecl] ty(date) pu([) op(-) pu(]) pu(() ty(date) id(dt) pu(,) ty(timespan) id(ts) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;date [-](date dt,timespan ts)
[Y] Store OFUN[119]: name=[-] Kind=6 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=13 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[264]: name=[-] kind=Operator returns=date void=no nested=no
[Y] Store OPAR[423]: name=$result TypIndex=13 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=119
[D] PAR[612]: function=[-] name=$result type=date order=0 const=no ref=yes
[Y] Store OPAR[424]: name=dt TypIndex=13 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=119
[D] PAR[613]: function=[-] name=dt type=date order=1 const=yes ref=yes
[Y] Store OPAR[425]: name=ts TypIndex=16 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=119
[D] PAR[614]: function=[-] name=ts type=timespan order=2 const=yes ref=yes
[I] FUN: name=[-](date,timespan) index=264 searchindex=4, scope={Pub:main}, scope={Pub:main}
[D] FID[264]: name=[-] kind=6 fullname=[-](date,timespan) id=[-]4
[Y] Update OFUN[119]: ParmNr=3 ParmLow=423 ParmHigh=425
[A] DECL: ([-]4)                              DECLARE {REF UNDEFINED $result,CONST REF UNDEFINED dt,CONST REF UNDEFINED ts} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):259:29: "time [-](time tm,timespan ts)"
[P] Parsed sentence: [FunDecl] ty(time) pu([) op(-) pu(]) pu(() ty(time) id(tm) pu(,) ty(timespan) id(ts) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;time [-](time tm,timespan ts)
[Y] Store OFUN[120]: name=[-] Kind=6 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=14 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[265]: name=[-] kind=Operator returns=time void=no nested=no
[Y] Store OPAR[426]: name=$result TypIndex=14 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=120
[D] PAR[615]: function=[-] name=$result type=time order=0 const=no ref=yes
[Y] Store OPAR[427]: name=tm TypIndex=14 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=120
[D] PAR[616]: function=[-] name=tm type=time order=1 const=yes ref=yes
[Y] Store OPAR[428]: name=ts TypIndex=16 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=120
[D] PAR[617]: function=[-] name=ts type=timespan order=2 const=yes ref=yes
[I] FUN: name=[-](time,timespan) index=265 searchindex=7, scope={Pub:main}, scope={Pub:main}
[D] FID[265]: name=[-] kind=6 fullname=[-](time,timespan) id=[-]5
[Y] Update OFUN[120]: ParmNr=3 ParmLow=426 ParmHigh=428
[A] DECL: ([-]5)                              DECLARE {REF UNDEFINED $result,CONST REF UNDEFINED tm,CONST REF UNDEFINED ts} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):260:37: "datetime [-](datetime dm,timespan ts)"
[P] Parsed sentence: [FunDecl] ty(datetime) pu([) op(-) pu(]) pu(() ty(datetime) id(dm) pu(,) ty(timespan) id(ts) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;datetime [-](datetime dm,timespan ts)
[Y] Store OFUN[121]: name=[-] Kind=6 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=15 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[266]: name=[-] kind=Operator returns=datetime void=no nested=no
[Y] Store OPAR[429]: name=$result TypIndex=15 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=121
[D] PAR[618]: function=[-] name=$result type=datetime order=0 const=no ref=yes
[Y] Store OPAR[430]: name=dm TypIndex=15 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=121
[D] PAR[619]: function=[-] name=dm type=datetime order=1 const=yes ref=yes
[Y] Store OPAR[431]: name=ts TypIndex=16 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=121
[D] PAR[620]: function=[-] name=ts type=timespan order=2 const=yes ref=yes
[I] FUN: name=[-](datetime,timespan) index=266 searchindex=6, scope={Pub:main}, scope={Pub:main}
[D] FID[266]: name=[-] kind=6 fullname=[-](datetime,timespan) id=[-]6
[Y] Update OFUN[121]: ParmNr=3 ParmLow=429 ParmHigh=431
[A] DECL: ([-]6)                              DECLARE {REF UNDEFINED $result,CONST REF UNDEFINED dm,CONST REF UNDEFINED ts} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):261:39: "timespan [+](timespan ts1,timespan ts2)"
[P] Parsed sentence: [FunDecl] ty(timespan) pu([) op(+) pu(]) pu(() ty(timespan) id(ts1) pu(,) ty(timespan) id(ts2) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;timespan [+](timespan ts1,timespan ts2)
[Y] Store OFUN[122]: name=[+] Kind=6 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=16 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[267]: name=[+] kind=Operator returns=timespan void=no nested=no
[Y] Store OPAR[432]: name=$result TypIndex=16 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=122
[D] PAR[621]: function=[+] name=$result type=timespan order=0 const=no ref=yes
[Y] Store OPAR[433]: name=ts1 TypIndex=16 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=122
[D] PAR[622]: function=[+] name=ts1 type=timespan order=1 const=yes ref=yes
[Y] Store OPAR[434]: name=ts2 TypIndex=16 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=122
[D] PAR[623]: function=[+] name=ts2 type=timespan order=2 const=yes ref=yes
[I] FUN: name=[+](timespan,timespan) index=267 searchindex=3, scope={Pub:main}, scope={Pub:main}
[D] FID[267]: name=[+] kind=6 fullname=[+](timespan,timespan) id=[+]4
[Y] Update OFUN[122]: ParmNr=3 ParmLow=432 ParmHigh=434
[A] DECL: ([+]4)                              DECLARE {REF UNDEFINED $result,CONST REF UNDEFINED ts1,CONST REF UNDEFINED ts2} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):262:39: "timespan [-](timespan ts1,timespan ts2)"
[P] Parsed sentence: [FunDecl] ty(timespan) pu([) op(-) pu(]) pu(() ty(timespan) id(ts1) pu(,) ty(timespan) id(ts2) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;timespan [-](timespan ts1,timespan ts2)
[Y] Store OFUN[123]: name=[-] Kind=6 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=16 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[268]: name=[-] kind=Operator returns=timespan void=no nested=no
[Y] Store OPAR[435]: name=$result TypIndex=16 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=123
[D] PAR[624]: function=[-] name=$result type=timespan order=0 const=no ref=yes
[Y] Store OPAR[436]: name=ts1 TypIndex=16 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=123
[D] PAR[625]: function=[-] name=ts1 type=timespan order=1 const=yes ref=yes
[Y] Store OPAR[437]: name=ts2 TypIndex=16 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=123
[D] PAR[626]: function=[-] name=ts2 type=timespan order=2 const=yes ref=yes
[I] FUN: name=[-](timespan,timespan) index=268 searchindex=10, scope={Pub:main}, scope={Pub:main}
[D] FID[268]: name=[-] kind=6 fullname=[-](timespan,timespan) id=[-]7
[Y] Update OFUN[123]: ParmNr=3 ParmLow=435 ParmHigh=437
[A] DECL: ([-]7)                              DECLARE {REF UNDEFINED $result,CONST REF UNDEFINED ts1,CONST REF UNDEFINED ts2} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):263:26: "bool [==](date d1,date d2)"
[P] Parsed sentence: [FunDecl] ty(bool) pu([) op(==) pu(]) pu(() ty(date) id(d1) pu(,) ty(date) id(d2) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;bool [==](date d1,date d2)
[Y] Store OFUN[124]: name=[==] Kind=6 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[269]: name=[==] kind=Operator returns=bool void=no nested=no
[Y] Store OPAR[438]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=124
[D] PAR[627]: function=[==] name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[439]: name=d1 TypIndex=13 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=124
[D] PAR[628]: function=[==] name=d1 type=date order=1 const=yes ref=yes
[Y] Store OPAR[440]: name=d2 TypIndex=13 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=124
[D] PAR[629]: function=[==] name=d2 type=date order=2 const=yes ref=yes
[I] FUN: name=[==](date,date) index=269 searchindex=11, scope={Pub:main}, scope={Pub:main}
[D] FID[269]: name=[==] kind=6 fullname=[==](date,date) id=[==]
[Y] Update OFUN[124]: ParmNr=3 ParmLow=438 ParmHigh=440
[A] DECL: ([==])                              DECLARE {REF BOOLEAN $result,CONST REF UNDEFINED d1,CONST REF UNDEFINED d2} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):264:26: "bool [!=](date d1,date d2)"
[P] Parsed sentence: [FunDecl] ty(bool) pu([) op(!=) pu(]) pu(() ty(date) id(d1) pu(,) ty(date) id(d2) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;bool [!=](date d1,date d2)
[Y] Store OFUN[125]: name=[!=] Kind=6 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[270]: name=[!=] kind=Operator returns=bool void=no nested=no
[Y] Store OPAR[441]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=125
[D] PAR[630]: function=[!=] name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[442]: name=d1 TypIndex=13 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=125
[D] PAR[631]: function=[!=] name=d1 type=date order=1 const=yes ref=yes
[Y] Store OPAR[443]: name=d2 TypIndex=13 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=125
[D] PAR[632]: function=[!=] name=d2 type=date order=2 const=yes ref=yes
[I] FUN: name=[!=](date,date) index=270 searchindex=0, scope={Pub:main}, scope={Pub:main}
[D] FID[270]: name=[!=] kind=6 fullname=[!=](date,date) id=[!=]
[Y] Update OFUN[125]: ParmNr=3 ParmLow=441 ParmHigh=443
[A] DECL: ([!=])                              DECLARE {REF BOOLEAN $result,CONST REF UNDEFINED d1,CONST REF UNDEFINED d2} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):265:25: "bool [<](date d1,date d2)"
[P] Parsed sentence: [FunDecl] ty(bool) pu([) op(<) pu(]) pu(() ty(date) id(d1) pu(,) ty(date) id(d2) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;bool [<](date d1,date d2)
[Y] Store OFUN[126]: name=[<] Kind=6 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[271]: name=[<] kind=Operator returns=bool void=no nested=no
[Y] Store OPAR[444]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=126
[D] PAR[633]: function=[<] name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[445]: name=d1 TypIndex=13 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=126
[D] PAR[634]: function=[<] name=d1 type=date order=1 const=yes ref=yes
[Y] Store OPAR[446]: name=d2 TypIndex=13 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=126
[D] PAR[635]: function=[<] name=d2 type=date order=2 const=yes ref=yes
[I] FUN: name=[<](date,date) index=271 searchindex=12, scope={Pub:main}, scope={Pub:main}
[D] FID[271]: name=[<] kind=6 fullname=[<](date,date) id=[<]
[Y] Update OFUN[126]: ParmNr=3 ParmLow=444 ParmHigh=446
[A] DECL: ([<])                               DECLARE {REF BOOLEAN $result,CONST REF UNDEFINED d1,CONST REF UNDEFINED d2} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):266:25: "bool [>](date d1,date d2)"
[P] Parsed sentence: [FunDecl] ty(bool) pu([) op(>) pu(]) pu(() ty(date) id(d1) pu(,) ty(date) id(d2) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;bool [>](date d1,date d2)
[Y] Store OFUN[127]: name=[>] Kind=6 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[272]: name=[>] kind=Operator returns=bool void=no nested=no
[Y] Store OPAR[447]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=127
[D] PAR[636]: function=[>] name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[448]: name=d1 TypIndex=13 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=127
[D] PAR[637]: function=[>] name=d1 type=date order=1 const=yes ref=yes
[Y] Store OPAR[449]: name=d2 TypIndex=13 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=127
[D] PAR[638]: function=[>] name=d2 type=date order=2 const=yes ref=yes
[I] FUN: name=[>](date,date) index=272 searchindex=14, scope={Pub:main}, scope={Pub:main}
[D] FID[272]: name=[>] kind=6 fullname=[>](date,date) id=[>]
[Y] Update OFUN[127]: ParmNr=3 ParmLow=447 ParmHigh=449
[A] DECL: ([>])                               DECLARE {REF BOOLEAN $result,CONST REF UNDEFINED d1,CONST REF UNDEFINED d2} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):267:26: "bool [<=](date d1,date d2)"
[P] Parsed sentence: [FunDecl] ty(bool) pu([) op(<=) pu(]) pu(() ty(date) id(d1) pu(,) ty(date) id(d2) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;bool [<=](date d1,date d2)
[Y] Store OFUN[128]: name=[<=] Kind=6 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[273]: name=[<=] kind=Operator returns=bool void=no nested=no
[Y] Store OPAR[450]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=128
[D] PAR[639]: function=[<=] name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[451]: name=d1 TypIndex=13 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=128
[D] PAR[640]: function=[<=] name=d1 type=date order=1 const=yes ref=yes
[Y] Store OPAR[452]: name=d2 TypIndex=13 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=128
[D] PAR[641]: function=[<=] name=d2 type=date order=2 const=yes ref=yes
[I] FUN: name=[<=](date,date) index=273 searchindex=12, scope={Pub:main}, scope={Pub:main}
[D] FID[273]: name=[<=] kind=6 fullname=[<=](date,date) id=[<=]
[Y] Update OFUN[128]: ParmNr=3 ParmLow=450 ParmHigh=452
[A] DECL: ([<=])                              DECLARE {REF BOOLEAN $result,CONST REF UNDEFINED d1,CONST REF UNDEFINED d2} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):268:26: "bool [>=](date d1,date d2)"
[P] Parsed sentence: [FunDecl] ty(bool) pu([) op(>=) pu(]) pu(() ty(date) id(d1) pu(,) ty(date) id(d2) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;bool [>=](date d1,date d2)
[Y] Store OFUN[129]: name=[>=] Kind=6 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[274]: name=[>=] kind=Operator returns=bool void=no nested=no
[Y] Store OPAR[453]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=129
[D] PAR[642]: function=[>=] name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[454]: name=d1 TypIndex=13 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=129
[D] PAR[643]: function=[>=] name=d1 type=date order=1 const=yes ref=yes
[Y] Store OPAR[455]: name=d2 TypIndex=13 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=129
[D] PAR[644]: function=[>=] name=d2 type=date order=2 const=yes ref=yes
[I] FUN: name=[>=](date,date) index=274 searchindex=15, scope={Pub:main}, scope={Pub:main}
[D] FID[274]: name=[>=] kind=6 fullname=[>=](date,date) id=[>=]
[Y] Update OFUN[129]: ParmNr=3 ParmLow=453 ParmHigh=455
[A] DECL: ([>=])                              DECLARE {REF BOOLEAN $result,CONST REF UNDEFINED d1,CONST REF UNDEFINED d2} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):269:26: "bool [==](time t1,time t2)"
[P] Parsed sentence: [FunDecl] ty(bool) pu([) op(==) pu(]) pu(() ty(time) id(t1) pu(,) ty(time) id(t2) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;bool [==](time t1,time t2)
[Y] Store OFUN[130]: name=[==] Kind=6 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[275]: name=[==] kind=Operator returns=bool void=no nested=no
[Y] Store OPAR[456]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=130
[D] PAR[645]: function=[==] name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[457]: name=t1 TypIndex=14 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=130
[D] PAR[646]: function=[==] name=t1 type=time order=1 const=yes ref=yes
[Y] Store OPAR[458]: name=t2 TypIndex=14 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=130
[D] PAR[647]: function=[==] name=t2 type=time order=2 const=yes ref=yes
[I] FUN: name=[==](time,time) index=275 searchindex=15, scope={Pub:main}, scope={Pub:main}
[D] FID[275]: name=[==] kind=6 fullname=[==](time,time) id=[==]2
[Y] Update OFUN[130]: ParmNr=3 ParmLow=456 ParmHigh=458
[A] DECL: ([==]2)                             DECLARE {REF BOOLEAN $result,CONST REF UNDEFINED t1,CONST REF UNDEFINED t2} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):270:26: "bool [!=](time t1,time t2)"
[P] Parsed sentence: [FunDecl] ty(bool) pu([) op(!=) pu(]) pu(() ty(time) id(t1) pu(,) ty(time) id(t2) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;bool [!=](time t1,time t2)
[Y] Store OFUN[131]: name=[!=] Kind=6 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[276]: name=[!=] kind=Operator returns=bool void=no nested=no
[Y] Store OPAR[459]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=131
[D] PAR[648]: function=[!=] name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[460]: name=t1 TypIndex=14 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=131
[D] PAR[649]: function=[!=] name=t1 type=time order=1 const=yes ref=yes
[Y] Store OPAR[461]: name=t2 TypIndex=14 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=131
[D] PAR[650]: function=[!=] name=t2 type=time order=2 const=yes ref=yes
[I] FUN: name=[!=](time,time) index=276 searchindex=1, scope={Pub:main}, scope={Pub:main}
[D] FID[276]: name=[!=] kind=6 fullname=[!=](time,time) id=[!=]2
[Y] Update OFUN[131]: ParmNr=3 ParmLow=459 ParmHigh=461
[A] DECL: ([!=]2)                             DECLARE {REF BOOLEAN $result,CONST REF UNDEFINED t1,CONST REF UNDEFINED t2} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):271:25: "bool [<](time t1,time t2)"
[P] Parsed sentence: [FunDecl] ty(bool) pu([) op(<) pu(]) pu(() ty(time) id(t1) pu(,) ty(time) id(t2) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;bool [<](time t1,time t2)
[Y] Store OFUN[132]: name=[<] Kind=6 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[277]: name=[<] kind=Operator returns=bool void=no nested=no
[Y] Store OPAR[462]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=132
[D] PAR[651]: function=[<] name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[463]: name=t1 TypIndex=14 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=132
[D] PAR[652]: function=[<] name=t1 type=time order=1 const=yes ref=yes
[Y] Store OPAR[464]: name=t2 TypIndex=14 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=132
[D] PAR[653]: function=[<] name=t2 type=time order=2 const=yes ref=yes
[I] FUN: name=[<](time,time) index=277 searchindex=15, scope={Pub:main}, scope={Pub:main}
[D] FID[277]: name=[<] kind=6 fullname=[<](time,time) id=[<]2
[Y] Update OFUN[132]: ParmNr=3 ParmLow=462 ParmHigh=464
[A] DECL: ([<]2)                              DECLARE {REF BOOLEAN $result,CONST REF UNDEFINED t1,CONST REF UNDEFINED t2} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):272:25: "bool [>](time t1,time t2)"
[P] Parsed sentence: [FunDecl] ty(bool) pu([) op(>) pu(]) pu(() ty(time) id(t1) pu(,) ty(time) id(t2) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;bool [>](time t1,time t2)
[Y] Store OFUN[133]: name=[>] Kind=6 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[278]: name=[>] kind=Operator returns=bool void=no nested=no
[Y] Store OPAR[465]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=133
[D] PAR[654]: function=[>] name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[466]: name=t1 TypIndex=14 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=133
[D] PAR[655]: function=[>] name=t1 type=time order=1 const=yes ref=yes
[Y] Store OPAR[467]: name=t2 TypIndex=14 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=133
[D] PAR[656]: function=[>] name=t2 type=time order=2 const=yes ref=yes
[I] FUN: name=[>](time,time) index=278 searchindex=20, scope={Pub:main}, scope={Pub:main}
[D] FID[278]: name=[>] kind=6 fullname=[>](time,time) id=[>]2
[Y] Update OFUN[133]: ParmNr=3 ParmLow=465 ParmHigh=467
[A] DECL: ([>]2)                              DECLARE {REF BOOLEAN $result,CONST REF UNDEFINED t1,CONST REF UNDEFINED t2} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):273:26: "bool [<=](time t1,time t2)"
[P] Parsed sentence: [FunDecl] ty(bool) pu([) op(<=) pu(]) pu(() ty(time) id(t1) pu(,) ty(time) id(t2) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;bool [<=](time t1,time t2)
[Y] Store OFUN[134]: name=[<=] Kind=6 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[279]: name=[<=] kind=Operator returns=bool void=no nested=no
[Y] Store OPAR[468]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=134
[D] PAR[657]: function=[<=] name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[469]: name=t1 TypIndex=14 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=134
[D] PAR[658]: function=[<=] name=t1 type=time order=1 const=yes ref=yes
[Y] Store OPAR[470]: name=t2 TypIndex=14 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=134
[D] PAR[659]: function=[<=] name=t2 type=time order=2 const=yes ref=yes
[I] FUN: name=[<=](time,time) index=279 searchindex=14, scope={Pub:main}, scope={Pub:main}
[D] FID[279]: name=[<=] kind=6 fullname=[<=](time,time) id=[<=]2
[Y] Update OFUN[134]: ParmNr=3 ParmLow=468 ParmHigh=470
[A] DECL: ([<=]2)                             DECLARE {REF BOOLEAN $result,CONST REF UNDEFINED t1,CONST REF UNDEFINED t2} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):274:26: "bool [>=](time t1,time t2)"
[P] Parsed sentence: [FunDecl] ty(bool) pu([) op(>=) pu(]) pu(() ty(time) id(t1) pu(,) ty(time) id(t2) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;bool [>=](time t1,time t2)
[Y] Store OFUN[135]: name=[>=] Kind=6 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[280]: name=[>=] kind=Operator returns=bool void=no nested=no
[Y] Store OPAR[471]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=135
[D] PAR[660]: function=[>=] name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[472]: name=t1 TypIndex=14 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=135
[D] PAR[661]: function=[>=] name=t1 type=time order=1 const=yes ref=yes
[Y] Store OPAR[473]: name=t2 TypIndex=14 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=135
[D] PAR[662]: function=[>=] name=t2 type=time order=2 const=yes ref=yes
[I] FUN: name=[>=](time,time) index=280 searchindex=20, scope={Pub:main}, scope={Pub:main}
[D] FID[280]: name=[>=] kind=6 fullname=[>=](time,time) id=[>=]2
[Y] Update OFUN[135]: ParmNr=3 ParmLow=471 ParmHigh=473
[A] DECL: ([>=]2)                             DECLARE {REF BOOLEAN $result,CONST REF UNDEFINED t1,CONST REF UNDEFINED t2} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):275:36: "bool [==](datetime dt1,datetime dt2)"
[P] Parsed sentence: [FunDecl] ty(bool) pu([) op(==) pu(]) pu(() ty(datetime) id(dt1) pu(,) ty(datetime) id(dt2) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;bool [==](datetime dt1,datetime dt2)
[Y] Store OFUN[136]: name=[==] Kind=6 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[281]: name=[==] kind=Operator returns=bool void=no nested=no
[Y] Store OPAR[474]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=136
[D] PAR[663]: function=[==] name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[475]: name=dt1 TypIndex=15 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=136
[D] PAR[664]: function=[==] name=dt1 type=datetime order=1 const=yes ref=yes
[Y] Store OPAR[476]: name=dt2 TypIndex=15 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=136
[D] PAR[665]: function=[==] name=dt2 type=datetime order=2 const=yes ref=yes
[I] FUN: name=[==](datetime,datetime) index=281 searchindex=18, scope={Pub:main}, scope={Pub:main}
[D] FID[281]: name=[==] kind=6 fullname=[==](datetime,datetime) id=[==]3
[Y] Update OFUN[136]: ParmNr=3 ParmLow=474 ParmHigh=476
[A] DECL: ([==]3)                             DECLARE {REF BOOLEAN $result,CONST REF UNDEFINED dt1,CONST REF UNDEFINED dt2} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):276:36: "bool [!=](datetime dt1,datetime dt2)"
[P] Parsed sentence: [FunDecl] ty(bool) pu([) op(!=) pu(]) pu(() ty(datetime) id(dt1) pu(,) ty(datetime) id(dt2) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;bool [!=](datetime dt1,datetime dt2)
[Y] Store OFUN[137]: name=[!=] Kind=6 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[282]: name=[!=] kind=Operator returns=bool void=no nested=no
[Y] Store OPAR[477]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=137
[D] PAR[666]: function=[!=] name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[478]: name=dt1 TypIndex=15 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=137
[D] PAR[667]: function=[!=] name=dt1 type=datetime order=1 const=yes ref=yes
[Y] Store OPAR[479]: name=dt2 TypIndex=15 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=137
[D] PAR[668]: function=[!=] name=dt2 type=datetime order=2 const=yes ref=yes
[I] FUN: name=[!=](datetime,datetime) index=282 searchindex=1, scope={Pub:main}, scope={Pub:main}
[D] FID[282]: name=[!=] kind=6 fullname=[!=](datetime,datetime) id=[!=]3
[Y] Update OFUN[137]: ParmNr=3 ParmLow=477 ParmHigh=479
[A] DECL: ([!=]3)                             DECLARE {REF BOOLEAN $result,CONST REF UNDEFINED dt1,CONST REF UNDEFINED dt2} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):277:35: "bool [<](datetime dt1,datetime dt2)"
[P] Parsed sentence: [FunDecl] ty(bool) pu([) op(<) pu(]) pu(() ty(datetime) id(dt1) pu(,) ty(datetime) id(dt2) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;bool [<](datetime dt1,datetime dt2)
[Y] Store OFUN[138]: name=[<] Kind=6 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[283]: name=[<] kind=Operator returns=bool void=no nested=no
[Y] Store OPAR[480]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=138
[D] PAR[669]: function=[<] name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[481]: name=dt1 TypIndex=15 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=138
[D] PAR[670]: function=[<] name=dt1 type=datetime order=1 const=yes ref=yes
[Y] Store OPAR[482]: name=dt2 TypIndex=15 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=138
[D] PAR[671]: function=[<] name=dt2 type=datetime order=2 const=yes ref=yes
[I] FUN: name=[<](datetime,datetime) index=283 searchindex=17, scope={Pub:main}, scope={Pub:main}
[D] FID[283]: name=[<] kind=6 fullname=[<](datetime,datetime) id=[<]3
[Y] Update OFUN[138]: ParmNr=3 ParmLow=480 ParmHigh=482
[A] DECL: ([<]3)                              DECLARE {REF BOOLEAN $result,CONST REF UNDEFINED dt1,CONST REF UNDEFINED dt2} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):278:35: "bool [>](datetime dt1,datetime dt2)"
[P] Parsed sentence: [FunDecl] ty(bool) pu([) op(>) pu(]) pu(() ty(datetime) id(dt1) pu(,) ty(datetime) id(dt2) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;bool [>](datetime dt1,datetime dt2)
[Y] Store OFUN[139]: name=[>] Kind=6 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[284]: name=[>] kind=Operator returns=bool void=no nested=no
[Y] Store OPAR[483]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=139
[D] PAR[672]: function=[>] name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[484]: name=dt1 TypIndex=15 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=139
[D] PAR[673]: function=[>] name=dt1 type=datetime order=1 const=yes ref=yes
[Y] Store OPAR[485]: name=dt2 TypIndex=15 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=139
[D] PAR[674]: function=[>] name=dt2 type=datetime order=2 const=yes ref=yes
[I] FUN: name=[>](datetime,datetime) index=284 searchindex=25, scope={Pub:main}, scope={Pub:main}
[D] FID[284]: name=[>] kind=6 fullname=[>](datetime,datetime) id=[>]3
[Y] Update OFUN[139]: ParmNr=3 ParmLow=483 ParmHigh=485
[A] DECL: ([>]3)                              DECLARE {REF BOOLEAN $result,CONST REF UNDEFINED dt1,CONST REF UNDEFINED dt2} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):279:36: "bool [<=](datetime dt1,datetime dt2)"
[P] Parsed sentence: [FunDecl] ty(bool) pu([) op(<=) pu(]) pu(() ty(datetime) id(dt1) pu(,) ty(datetime) id(dt2) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;bool [<=](datetime dt1,datetime dt2)
[Y] Store OFUN[140]: name=[<=] Kind=6 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[285]: name=[<=] kind=Operator returns=bool void=no nested=no
[Y] Store OPAR[486]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=140
[D] PAR[675]: function=[<=] name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[487]: name=dt1 TypIndex=15 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=140
[D] PAR[676]: function=[<=] name=dt1 type=datetime order=1 const=yes ref=yes
[Y] Store OPAR[488]: name=dt2 TypIndex=15 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=140
[D] PAR[677]: function=[<=] name=dt2 type=datetime order=2 const=yes ref=yes
[I] FUN: name=[<=](datetime,datetime) index=285 searchindex=15, scope={Pub:main}, scope={Pub:main}
[D] FID[285]: name=[<=] kind=6 fullname=[<=](datetime,datetime) id=[<=]3
[Y] Update OFUN[140]: ParmNr=3 ParmLow=486 ParmHigh=488
[A] DECL: ([<=]3)                             DECLARE {REF BOOLEAN $result,CONST REF UNDEFINED dt1,CONST REF UNDEFINED dt2} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):280:36: "bool [>=](datetime dt1,datetime dt2)"
[P] Parsed sentence: [FunDecl] ty(bool) pu([) op(>=) pu(]) pu(() ty(datetime) id(dt1) pu(,) ty(datetime) id(dt2) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;bool [>=](datetime dt1,datetime dt2)
[Y] Store OFUN[141]: name=[>=] Kind=6 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[286]: name=[>=] kind=Operator returns=bool void=no nested=no
[Y] Store OPAR[489]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=141
[D] PAR[678]: function=[>=] name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[490]: name=dt1 TypIndex=15 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=141
[D] PAR[679]: function=[>=] name=dt1 type=datetime order=1 const=yes ref=yes
[Y] Store OPAR[491]: name=dt2 TypIndex=15 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=141
[D] PAR[680]: function=[>=] name=dt2 type=datetime order=2 const=yes ref=yes
[I] FUN: name=[>=](datetime,datetime) index=286 searchindex=24, scope={Pub:main}, scope={Pub:main}
[D] FID[286]: name=[>=] kind=6 fullname=[>=](datetime,datetime) id=[>=]3
[Y] Update OFUN[141]: ParmNr=3 ParmLow=489 ParmHigh=491
[A] DECL: ([>=]3)                             DECLARE {REF BOOLEAN $result,CONST REF UNDEFINED dt1,CONST REF UNDEFINED dt2} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):281:36: "bool [==](timespan ts1,timespan ts2)"
[P] Parsed sentence: [FunDecl] ty(bool) pu([) op(==) pu(]) pu(() ty(timespan) id(ts1) pu(,) ty(timespan) id(ts2) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;bool [==](timespan ts1,timespan ts2)
[Y] Store OFUN[142]: name=[==] Kind=6 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[287]: name=[==] kind=Operator returns=bool void=no nested=no
[Y] Store OPAR[492]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=142
[D] PAR[681]: function=[==] name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[493]: name=ts1 TypIndex=16 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=142
[D] PAR[682]: function=[==] name=ts1 type=timespan order=1 const=yes ref=yes
[Y] Store OPAR[494]: name=ts2 TypIndex=16 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=142
[D] PAR[683]: function=[==] name=ts2 type=timespan order=2 const=yes ref=yes
[I] FUN: name=[==](timespan,timespan) index=287 searchindex=23, scope={Pub:main}, scope={Pub:main}
[D] FID[287]: name=[==] kind=6 fullname=[==](timespan,timespan) id=[==]4
[Y] Update OFUN[142]: ParmNr=3 ParmLow=492 ParmHigh=494
[A] DECL: ([==]4)                             DECLARE {REF BOOLEAN $result,CONST REF UNDEFINED ts1,CONST REF UNDEFINED ts2} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):282:36: "bool [!=](timespan ts1,timespan ts2)"
[P] Parsed sentence: [FunDecl] ty(bool) pu([) op(!=) pu(]) pu(() ty(timespan) id(ts1) pu(,) ty(timespan) id(ts2) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;bool [!=](timespan ts1,timespan ts2)
[Y] Store OFUN[143]: name=[!=] Kind=6 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[288]: name=[!=] kind=Operator returns=bool void=no nested=no
[Y] Store OPAR[495]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=143
[D] PAR[684]: function=[!=] name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[496]: name=ts1 TypIndex=16 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=143
[D] PAR[685]: function=[!=] name=ts1 type=timespan order=1 const=yes ref=yes
[Y] Store OPAR[497]: name=ts2 TypIndex=16 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=143
[D] PAR[686]: function=[!=] name=ts2 type=timespan order=2 const=yes ref=yes
[I] FUN: name=[!=](timespan,timespan) index=288 searchindex=3, scope={Pub:main}, scope={Pub:main}
[D] FID[288]: name=[!=] kind=6 fullname=[!=](timespan,timespan) id=[!=]4
[Y] Update OFUN[143]: ParmNr=3 ParmLow=495 ParmHigh=497
[A] DECL: ([!=]4)                             DECLARE {REF BOOLEAN $result,CONST REF UNDEFINED ts1,CONST REF UNDEFINED ts2} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):283:35: "bool [<](timespan ts1,timespan ts2)"
[P] Parsed sentence: [FunDecl] ty(bool) pu([) op(<) pu(]) pu(() ty(timespan) id(ts1) pu(,) ty(timespan) id(ts2) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;bool [<](timespan ts1,timespan ts2)
[Y] Store OFUN[144]: name=[<] Kind=6 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[289]: name=[<] kind=Operator returns=bool void=no nested=no
[Y] Store OPAR[498]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=144
[D] PAR[687]: function=[<] name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[499]: name=ts1 TypIndex=16 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=144
[D] PAR[688]: function=[<] name=ts1 type=timespan order=1 const=yes ref=yes
[Y] Store OPAR[500]: name=ts2 TypIndex=16 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=144
[D] PAR[689]: function=[<] name=ts2 type=timespan order=2 const=yes ref=yes
[I] FUN: name=[<](timespan,timespan) index=289 searchindex=21, scope={Pub:main}, scope={Pub:main}
[D] FID[289]: name=[<] kind=6 fullname=[<](timespan,timespan) id=[<]4
[Y] Update OFUN[144]: ParmNr=3 ParmLow=498 ParmHigh=500
[A] DECL: ([<]4)                              DECLARE {REF BOOLEAN $result,CONST REF UNDEFINED ts1,CONST REF UNDEFINED ts2} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):284:35: "bool [>](timespan ts1,timespan ts2)"
[P] Parsed sentence: [FunDecl] ty(bool) pu([) op(>) pu(]) pu(() ty(timespan) id(ts1) pu(,) ty(timespan) id(ts2) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;bool [>](timespan ts1,timespan ts2)
[Y] Store OFUN[145]: name=[>] Kind=6 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[290]: name=[>] kind=Operator returns=bool void=no nested=no
[Y] Store OPAR[501]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=145
[D] PAR[690]: function=[>] name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[502]: name=ts1 TypIndex=16 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=145
[D] PAR[691]: function=[>] name=ts1 type=timespan order=1 const=yes ref=yes
[Y] Store OPAR[503]: name=ts2 TypIndex=16 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=145
[D] PAR[692]: function=[>] name=ts2 type=timespan order=2 const=yes ref=yes
[I] FUN: name=[>](timespan,timespan) index=290 searchindex=32, scope={Pub:main}, scope={Pub:main}
[D] FID[290]: name=[>] kind=6 fullname=[>](timespan,timespan) id=[>]4
[Y] Update OFUN[145]: ParmNr=3 ParmLow=501 ParmHigh=503
[A] DECL: ([>]4)                              DECLARE {REF BOOLEAN $result,CONST REF UNDEFINED ts1,CONST REF UNDEFINED ts2} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):285:36: "bool [<=](timespan ts1,timespan ts2)"
[P] Parsed sentence: [FunDecl] ty(bool) pu([) op(<=) pu(]) pu(() ty(timespan) id(ts1) pu(,) ty(timespan) id(ts2) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;bool [<=](timespan ts1,timespan ts2)
[Y] Store OFUN[146]: name=[<=] Kind=6 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[291]: name=[<=] kind=Operator returns=bool void=no nested=no
[Y] Store OPAR[504]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=146
[D] PAR[693]: function=[<=] name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[505]: name=ts1 TypIndex=16 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=146
[D] PAR[694]: function=[<=] name=ts1 type=timespan order=1 const=yes ref=yes
[Y] Store OPAR[506]: name=ts2 TypIndex=16 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=146
[D] PAR[695]: function=[<=] name=ts2 type=timespan order=2 const=yes ref=yes
[I] FUN: name=[<=](timespan,timespan) index=291 searchindex=18, scope={Pub:main}, scope={Pub:main}
[D] FID[291]: name=[<=] kind=6 fullname=[<=](timespan,timespan) id=[<=]4
[Y] Update OFUN[146]: ParmNr=3 ParmLow=504 ParmHigh=506
[A] DECL: ([<=]4)                             DECLARE {REF BOOLEAN $result,CONST REF UNDEFINED ts1,CONST REF UNDEFINED ts2} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):286:36: "bool [>=](timespan ts1,timespan ts2)"
[P] Parsed sentence: [FunDecl] ty(bool) pu([) op(>=) pu(]) pu(() ty(timespan) id(ts1) pu(,) ty(timespan) id(ts2) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;bool [>=](timespan ts1,timespan ts2)
[Y] Store OFUN[147]: name=[>=] Kind=6 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[292]: name=[>=] kind=Operator returns=bool void=no nested=no
[Y] Store OPAR[507]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=147
[D] PAR[696]: function=[>=] name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[508]: name=ts1 TypIndex=16 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=147
[D] PAR[697]: function=[>=] name=ts1 type=timespan order=1 const=yes ref=yes
[Y] Store OPAR[509]: name=ts2 TypIndex=16 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=147
[D] PAR[698]: function=[>=] name=ts2 type=timespan order=2 const=yes ref=yes
[I] FUN: name=[>=](timespan,timespan) index=292 searchindex=30, scope={Pub:main}, scope={Pub:main}
[D] FID[292]: name=[>=] kind=6 fullname=[>=](timespan,timespan) id=[>=]4
[Y] Update OFUN[147]: ParmNr=3 ParmLow=507 ParmHigh=509
[A] DECL: ([>=]4)                             DECLARE {REF BOOLEAN $result,CONST REF UNDEFINED ts1,CONST REF UNDEFINED ts2} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):289:35: "syscall<exit>           void exit()"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(exit) op(>) kw(void) id(exit) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<exit>           void exit()
[Y] Store OFUN[148]: name=exit Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=-1 IsVoid=1 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=0 InstCode=-1 DlName= DlFunction=
[D] FUN[293]: name=exit kind=SysCall returns=undefined void=yes nested=no scope={Pub:main} syscallnr=0
[I] FUN: name=standard.exit() index=293 searchindex=188, scope={Pub:main}, scope={Pub:main}
[D] FID[293]: name=exit kind=3 fullname=standard.exit() id=standard_exit
[A] DECL: (standard_exit)                     DECLARE {} AS SCALL(0) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):290:50: "                        void panic(string message)"
[P] Parsed sentence: [FunDecl] kw(void) id(panic) pu(() ty(string) id(message) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;void panic(string message)
[Y] Store OFUN[149]: name=panic Kind=0 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=-1 IsVoid=1 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[294]: name=panic kind=Function returns=undefined void=yes nested=no scope={Pub:main}
[Y] Store OPAR[510]: name=message TypIndex=6 IsConst=1 IsReference=1 ParmOrder=0 FunIndex=149
[D] PAR[699]: function=panic name=message type=string order=0 const=yes ref=yes
[I] FUN: name=standard.panic(string) index=294 searchindex=200, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.panic($cvstr) index=294 searchindex=38, scope={Pub:main}, scope={Pub:main}
[D] FID[294]: name=panic kind=0 fullname=standard.panic(string) id=standard_panic
[Y] Update OFUN[149]: ParmNr=1 ParmLow=510 ParmHigh=510
[A] DECL: (standard_panic)                    DECLARE {CONST REF STRINGBLOCK message} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):293:38: "syscall<getarg>         string[] arg()"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(getarg) op(>) ty(string) pu([) pu(]) id(arg) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<getarg>         string[] arg()
[Y] Store OFUN[150]: name=arg Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=8 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=7 InstCode=-1 DlName= DlFunction=
[D] FUN[295]: name=arg kind=SysCall returns=string[] void=no nested=no scope={Pub:main} syscallnr=7
[Y] Store OPAR[511]: name=$result TypIndex=8 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=150
[D] PAR[700]: function=arg name=$result type=string[] order=0 const=no ref=yes
[I] FUN: name=standard.arg() index=295 searchindex=142, scope={Pub:main}, scope={Pub:main}
[D] FID[295]: name=arg kind=3 fullname=standard.arg() id=standard_arg
[Y] Update OFUN[150]: ParmNr=1 ParmLow=511 ParmHigh=511
[A] DECL: (standard_arg)                      DECLARE {REF ARRAYBLOCK $result} AS SCALL(7) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):296:47: "syscall<print>          void print(string line)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(print) op(>) kw(void) id(print) pu(() ty(string) id(line) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<print>          void print(string line)
[Y] Store OFUN[151]: name=print Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=-1 IsVoid=1 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=9 InstCode=-1 DlName= DlFunction=
[D] FUN[296]: name=print kind=SysCall returns=undefined void=yes nested=no scope={Pub:main} syscallnr=9
[Y] Store OPAR[512]: name=line TypIndex=6 IsConst=1 IsReference=1 ParmOrder=0 FunIndex=151
[D] PAR[701]: function=print name=line type=string order=0 const=yes ref=yes
[I] FUN: name=standard.print(string) index=296 searchindex=202, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.print($cvstr) index=296 searchindex=39, scope={Pub:main}, scope={Pub:main}
[D] FID[296]: name=print kind=3 fullname=standard.print(string) id=standard_print
[Y] Update OFUN[151]: ParmNr=1 ParmLow=512 ParmHigh=512
[A] DECL: (standard_print)                    DECLARE {CONST REF STRINGBLOCK line} AS SCALL(9) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):297:49: "syscall<println>        void println(string line)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(println) op(>) kw(void) id(println) pu(() ty(string) id(line) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<println>        void println(string line)
[Y] Store OFUN[152]: name=println Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=-1 IsVoid=1 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=10 InstCode=-1 DlName= DlFunction=
[D] FUN[297]: name=println kind=SysCall returns=undefined void=yes nested=no scope={Pub:main} syscallnr=10
[Y] Store OPAR[513]: name=line TypIndex=6 IsConst=1 IsReference=1 ParmOrder=0 FunIndex=152
[D] PAR[702]: function=println name=line type=string order=0 const=yes ref=yes
[I] FUN: name=standard.println(string) index=297 searchindex=203, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.println($cvstr) index=297 searchindex=40, scope={Pub:main}, scope={Pub:main}
[D] FID[297]: name=println kind=3 fullname=standard.println(string) id=standard_println
[Y] Update OFUN[152]: ParmNr=1 ParmLow=513 ParmHigh=513
[A] DECL: (standard_println)                  DECLARE {CONST REF STRINGBLOCK line} AS SCALL(10) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):300:55: "syscall<getfnam>        string getfilename(string path)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(getfnam) op(>) ty(string) id(getfilename) pu(() ty(string) id(path) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<getfnam>        string getfilename(string path)
[Y] Store OFUN[153]: name=getfilename Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=6 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=11 InstCode=-1 DlName= DlFunction=
[D] FUN[298]: name=getfilename kind=SysCall returns=string void=no nested=no scope={Pub:main} syscallnr=11
[Y] Store OPAR[514]: name=$result TypIndex=6 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=153
[D] PAR[703]: function=getfilename name=$result type=string order=0 const=no ref=yes
[Y] Store OPAR[515]: name=path TypIndex=6 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=153
[D] PAR[704]: function=getfilename name=path type=string order=1 const=yes ref=yes
[I] FUN: name=standard.getfilename(string) index=298 searchindex=192, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.getfilename($cvstr) index=298 searchindex=33, scope={Pub:main}, scope={Pub:main}
[D] FID[298]: name=getfilename kind=3 fullname=standard.getfilename(string) id=standard_getfilename
[Y] Update OFUN[153]: ParmNr=2 ParmLow=514 ParmHigh=515
[A] DECL: (standard_getfilename)              DECLARE {REF STRINGBLOCK $result,CONST REF STRINGBLOCK path} AS SCALL(11) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):301:60: "syscall<getfnamnx>      string getfilenamenoext(string path)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(getfnamnx) op(>) ty(string) id(getfilenamenoext) pu(() ty(string) id(path) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<getfnamnx>      string getfilenamenoext(string path)
[Y] Store OFUN[154]: name=getfilenamenoext Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=6 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=12 InstCode=-1 DlName= DlFunction=
[D] FUN[299]: name=getfilenamenoext kind=SysCall returns=string void=no nested=no scope={Pub:main} syscallnr=12
[Y] Store OPAR[516]: name=$result TypIndex=6 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=154
[D] PAR[705]: function=getfilenamenoext name=$result type=string order=0 const=no ref=yes
[Y] Store OPAR[517]: name=path TypIndex=6 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=154
[D] PAR[706]: function=getfilenamenoext name=path type=string order=1 const=yes ref=yes
[I] FUN: name=standard.getfilenamenoext(string) index=299 searchindex=193, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.getfilenamenoext($cvstr) index=299 searchindex=34, scope={Pub:main}, scope={Pub:main}
[D] FID[299]: name=getfilenamenoext kind=3 fullname=standard.getfilenamenoext(string) id=standard_getfilenamenoext
[Y] Update OFUN[154]: ParmNr=2 ParmLow=516 ParmHigh=517
[A] DECL: (standard_getfilenamenoext)         DECLARE {REF STRINGBLOCK $result,CONST REF STRINGBLOCK path} AS SCALL(12) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):302:60: "syscall<getfnamx>       string getfileextension(string path)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(getfnamx) op(>) ty(string) id(getfileextension) pu(() ty(string) id(path) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<getfnamx>       string getfileextension(string path)
[Y] Store OFUN[155]: name=getfileextension Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=6 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=13 InstCode=-1 DlName= DlFunction=
[D] FUN[300]: name=getfileextension kind=SysCall returns=string void=no nested=no scope={Pub:main} syscallnr=13
[Y] Store OPAR[518]: name=$result TypIndex=6 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=155
[D] PAR[707]: function=getfileextension name=$result type=string order=0 const=no ref=yes
[Y] Store OPAR[519]: name=path TypIndex=6 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=155
[D] PAR[708]: function=getfileextension name=path type=string order=1 const=yes ref=yes
[I] FUN: name=standard.getfileextension(string) index=300 searchindex=192, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.getfileextension($cvstr) index=300 searchindex=33, scope={Pub:main}, scope={Pub:main}
[D] FID[300]: name=getfileextension kind=3 fullname=standard.getfileextension(string) id=standard_getfileextension
[Y] Update OFUN[155]: ParmNr=2 ParmLow=518 ParmHigh=519
[A] DECL: (standard_getfileextension)         DECLARE {REF STRINGBLOCK $result,CONST REF STRINGBLOCK path} AS SCALL(13) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):303:57: "syscall<getfolder>      string getfoldername(string path)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(getfolder) op(>) ty(string) id(getfoldername) pu(() ty(string) id(path) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<getfolder>      string getfoldername(string path)
[Y] Store OFUN[156]: name=getfoldername Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=6 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=14 InstCode=-1 DlName= DlFunction=
[D] FUN[301]: name=getfoldername kind=SysCall returns=string void=no nested=no scope={Pub:main} syscallnr=14
[Y] Store OPAR[520]: name=$result TypIndex=6 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=156
[D] PAR[709]: function=getfoldername name=$result type=string order=0 const=no ref=yes
[Y] Store OPAR[521]: name=path TypIndex=6 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=156
[D] PAR[710]: function=getfoldername name=path type=string order=1 const=yes ref=yes
[I] FUN: name=standard.getfoldername(string) index=301 searchindex=195, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.getfoldername($cvstr) index=301 searchindex=36, scope={Pub:main}, scope={Pub:main}
[D] FID[301]: name=getfoldername kind=3 fullname=standard.getfoldername(string) id=standard_getfoldername
[Y] Update OFUN[156]: ParmNr=2 ParmLow=520 ParmHigh=521
[A] DECL: (standard_getfoldername)            DECLARE {REF STRINGBLOCK $result,CONST REF STRINGBLOCK path} AS SCALL(14) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):304:52: "syscall<fileexists>     bool fileexists(string path)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(fileexists) op(>) ty(bool) id(fileexists) pu(() ty(string) id(path) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<fileexists>     bool fileexists(string path)
[Y] Store OFUN[157]: name=fileexists Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=15 InstCode=-1 DlName= DlFunction=
[D] FUN[302]: name=fileexists kind=SysCall returns=bool void=no nested=no scope={Pub:main} syscallnr=15
[Y] Store OPAR[522]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=157
[D] PAR[711]: function=fileexists name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[523]: name=path TypIndex=6 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=157
[D] PAR[712]: function=fileexists name=path type=string order=1 const=yes ref=yes
[I] FUN: name=standard.fileexists(string) index=302 searchindex=190, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.fileexists($cvstr) index=302 searchindex=33, scope={Pub:main}, scope={Pub:main}
[D] FID[302]: name=fileexists kind=3 fullname=standard.fileexists(string) id=standard_fileexists
[Y] Update OFUN[157]: ParmNr=2 ParmLow=522 ParmHigh=523
[A] DECL: (standard_fileexists)               DECLARE {REF BOOLEAN $result,CONST REF STRINGBLOCK path} AS SCALL(15) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):305:51: "syscall<direxists>      bool direxists(string path)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(direxists) op(>) ty(bool) id(direxists) pu(() ty(string) id(path) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<direxists>      bool direxists(string path)
[Y] Store OFUN[158]: name=direxists Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=16 InstCode=-1 DlName= DlFunction=
[D] FUN[303]: name=direxists kind=SysCall returns=bool void=no nested=no scope={Pub:main} syscallnr=16
[Y] Store OPAR[524]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=158
[D] PAR[713]: function=direxists name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[525]: name=path TypIndex=6 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=158
[D] PAR[714]: function=direxists name=path type=string order=1 const=yes ref=yes
[I] FUN: name=standard.direxists(string) index=303 searchindex=189, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.direxists($cvstr) index=303 searchindex=33, scope={Pub:main}, scope={Pub:main}
[D] FID[303]: name=direxists kind=3 fullname=standard.direxists(string) id=standard_direxists
[Y] Update OFUN[158]: ParmNr=2 ParmLow=524 ParmHigh=525
[A] DECL: (standard_direxists)                DECLARE {REF BOOLEAN $result,CONST REF STRINGBLOCK path} AS SCALL(16) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):308:48: "syscall<gethandler>     bool newhnd(ref int hnd)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(gethandler) op(>) ty(bool) id(newhnd) pu(() kw(ref) ty(int) id(hnd) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<gethandler>     bool newhnd(ref int hnd)
[Y] Store OFUN[159]: name=newhnd Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=17 InstCode=-1 DlName= DlFunction=
[D] FUN[304]: name=newhnd kind=SysCall returns=bool void=no nested=no scope={Pub:main} syscallnr=17
[Y] Store OPAR[526]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=159
[D] PAR[715]: function=newhnd name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[527]: name=hnd TypIndex=3 IsConst=0 IsReference=1 ParmOrder=1 FunIndex=159
[D] PAR[716]: function=newhnd name=hnd type=int order=1 const=no ref=yes
[I] FUN: name=standard.newhnd(int) index=304 searchindex=207, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.newhnd($cvint) index=304 searchindex=44, scope={Pub:main}, scope={Pub:main}
[D] FID[304]: name=newhnd kind=3 fullname=standard.newhnd(int) id=standard_newhnd
[Y] Update OFUN[159]: ParmNr=2 ParmLow=526 ParmHigh=527
[A] DECL: (standard_newhnd)                   DECLARE {REF BOOLEAN $result,REF INTEGER hnd} AS SCALL(17) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):309:45: "syscall<freehandler>    void freehnd(int hnd)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(freehandler) op(>) kw(void) id(freehnd) pu(() ty(int) id(hnd) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<freehandler>    void freehnd(int hnd)
[Y] Store OFUN[160]: name=freehnd Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=-1 IsVoid=1 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=18 InstCode=-1 DlName= DlFunction=
[D] FUN[305]: name=freehnd kind=SysCall returns=undefined void=yes nested=no scope={Pub:main} syscallnr=18
[Y] Store OPAR[528]: name=hnd TypIndex=3 IsConst=0 IsReference=0 ParmOrder=0 FunIndex=160
[D] PAR[717]: function=freehnd name=hnd type=int order=0 const=no ref=no
[I] FUN: name=standard.freehnd(int) index=305 searchindex=192, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.freehnd($cvint) index=305 searchindex=35, scope={Pub:main}, scope={Pub:main}
[D] FID[305]: name=freehnd kind=3 fullname=standard.freehnd(int) id=standard_freehnd
[Y] Update OFUN[160]: ParmNr=1 ParmLow=528 ParmHigh=528
[A] DECL: (standard_freehnd)                  DECLARE {INTEGER hnd} AS SCALL(18) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):310:76: "syscall<openforread>    bool openread(int hnd,string filename,filemode mode)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(openforread) op(>) ty(bool) id(openread) pu(() ty(int) id(hnd) pu(,) ty(string) id(filename) pu(,) ty(filemode) id(mode) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<openforread>    bool openread(int hnd,string filename,filemode mode)
[Y] Store OFUN[161]: name=openread Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=19 InstCode=-1 DlName= DlFunction=
[D] FUN[306]: name=openread kind=SysCall returns=bool void=no nested=no scope={Pub:main} syscallnr=19
[Y] Store OPAR[529]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=161
[D] PAR[718]: function=openread name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[530]: name=hnd TypIndex=3 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=161
[D] PAR[719]: function=openread name=hnd type=int order=1 const=no ref=no
[Y] Store OPAR[531]: name=filename TypIndex=6 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=161
[D] PAR[720]: function=openread name=filename type=string order=2 const=yes ref=yes
[Y] Store OPAR[532]: name=mode TypIndex=11 IsConst=0 IsReference=0 ParmOrder=3 FunIndex=161
[D] PAR[721]: function=openread name=mode type=filemode order=3 const=no ref=no
[I] FUN: name=standard.openread(int,string,filemode) index=306 searchindex=209, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.openread($cvint,$cvstr,filemode) index=306 searchindex=46, scope={Pub:main}, scope={Pub:main}
[D] FID[306]: name=openread kind=3 fullname=standard.openread(int,string,filemode) id=standard_openread
[Y] Update OFUN[161]: ParmNr=4 ParmLow=529 ParmHigh=532
[A] DECL: (standard_openread)                 DECLARE {REF BOOLEAN $result,INTEGER hnd,CONST REF STRINGBLOCK filename,INTEGER mode} AS SCALL(19) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):311:77: "syscall<openforwrite>   bool openwrite(int hnd,string filename,filemode mode)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(openforwrite) op(>) ty(bool) id(openwrite) pu(() ty(int) id(hnd) pu(,) ty(string) id(filename) pu(,) ty(filemode) id(mode) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<openforwrite>   bool openwrite(int hnd,string filename,filemode mode)
[Y] Store OFUN[162]: name=openwrite Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=20 InstCode=-1 DlName= DlFunction=
[D] FUN[307]: name=openwrite kind=SysCall returns=bool void=no nested=no scope={Pub:main} syscallnr=20
[Y] Store OPAR[533]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=162
[D] PAR[722]: function=openwrite name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[534]: name=hnd TypIndex=3 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=162
[D] PAR[723]: function=openwrite name=hnd type=int order=1 const=no ref=no
[Y] Store OPAR[535]: name=filename TypIndex=6 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=162
[D] PAR[724]: function=openwrite name=filename type=string order=2 const=yes ref=yes
[Y] Store OPAR[536]: name=mode TypIndex=11 IsConst=0 IsReference=0 ParmOrder=3 FunIndex=162
[D] PAR[725]: function=openwrite name=mode type=filemode order=3 const=no ref=no
[I] FUN: name=standard.openwrite(int,string,filemode) index=307 searchindex=210, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.openwrite($cvint,$cvstr,filemode) index=307 searchindex=47, scope={Pub:main}, scope={Pub:main}
[D] FID[307]: name=openwrite kind=3 fullname=standard.openwrite(int,string,filemode) id=standard_openwrite
[Y] Update OFUN[162]: ParmNr=4 ParmLow=533 ParmHigh=536
[A] DECL: (standard_openwrite)                DECLARE {REF BOOLEAN $result,INTEGER hnd,CONST REF STRINGBLOCK filename,INTEGER mode} AS SCALL(20) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):312:72: "syscall<read>           bool read(int hnd,ref char[] buffer,long length)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(read) op(>) ty(bool) id(read) pu(() ty(int) id(hnd) pu(,) kw(ref) ty(char) pu([) pu(]) id(buffer) pu(,) ty(long) id(length) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<read>           bool read(int hnd,ref char[] buffer,long length)
[Y] Store OFUN[163]: name=read Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=21 InstCode=-1 DlName= DlFunction=
[D] FUN[308]: name=read kind=SysCall returns=bool void=no nested=no scope={Pub:main} syscallnr=21
[Y] Store OPAR[537]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=163
[D] PAR[726]: function=read name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[538]: name=hnd TypIndex=3 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=163
[D] PAR[727]: function=read name=hnd type=int order=1 const=no ref=no
[Y] Store OPAR[539]: name=buffer TypIndex=7 IsConst=0 IsReference=1 ParmOrder=2 FunIndex=163
[D] PAR[728]: function=read name=buffer type=char[] order=2 const=no ref=yes
[Y] Store OPAR[540]: name=length TypIndex=4 IsConst=0 IsReference=0 ParmOrder=3 FunIndex=163
[D] PAR[729]: function=read name=length type=long order=3 const=no ref=no
[I] FUN: name=standard.read(int,char[],long) index=308 searchindex=214, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.read($cvint,char[],$cvint) index=308 searchindex=51, scope={Pub:main}, scope={Pub:main}
[D] FID[308]: name=read kind=3 fullname=standard.read(int,char[],long) id=standard_read
[Y] Update OFUN[163]: ParmNr=4 ParmLow=537 ParmHigh=540
[A] DECL: (standard_read)                     DECLARE {REF BOOLEAN $result,INTEGER hnd,REF ARRAYBLOCK buffer,LONG length} AS SCALL(21) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):313:69: "syscall<write>          bool write(int hnd,char[] buffer,long length)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(write) op(>) ty(bool) id(write) pu(() ty(int) id(hnd) pu(,) ty(char) pu([) pu(]) id(buffer) pu(,) ty(long) id(length) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<write>          bool write(int hnd,char[] buffer,long length)
[Y] Store OFUN[164]: name=write Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=22 InstCode=-1 DlName= DlFunction=
[D] FUN[309]: name=write kind=SysCall returns=bool void=no nested=no scope={Pub:main} syscallnr=22
[Y] Store OPAR[541]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=164
[D] PAR[730]: function=write name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[542]: name=hnd TypIndex=3 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=164
[D] PAR[731]: function=write name=hnd type=int order=1 const=no ref=no
[Y] Store OPAR[543]: name=buffer TypIndex=7 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=164
[D] PAR[732]: function=write name=buffer type=char[] order=2 const=yes ref=yes
[Y] Store OPAR[544]: name=length TypIndex=4 IsConst=0 IsReference=0 ParmOrder=3 FunIndex=164
[D] PAR[733]: function=write name=length type=long order=3 const=no ref=no
[I] FUN: name=standard.write(int,char[],long) index=309 searchindex=271, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.write($cvint,char[],$cvint) index=309 searchindex=85, scope={Pub:main}, scope={Pub:main}
[D] FID[309]: name=write kind=3 fullname=standard.write(int,char[],long) id=standard_write
[Y] Update OFUN[164]: ParmNr=4 ParmLow=541 ParmHigh=544
[A] DECL: (standard_write)                    DECLARE {REF BOOLEAN $result,INTEGER hnd,CONST REF ARRAYBLOCK buffer,LONG length} AS SCALL(22) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):314:60: "syscall<readall>        bool read(int hnd,ref char[] buffer)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(readall) op(>) ty(bool) id(read) pu(() ty(int) id(hnd) pu(,) kw(ref) ty(char) pu([) pu(]) id(buffer) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<readall>        bool read(int hnd,ref char[] buffer)
[Y] Store OFUN[165]: name=read Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=23 InstCode=-1 DlName= DlFunction=
[D] FUN[310]: name=read kind=SysCall returns=bool void=no nested=no scope={Pub:main} syscallnr=23
[Y] Store OPAR[545]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=165
[D] PAR[734]: function=read name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[546]: name=hnd TypIndex=3 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=165
[D] PAR[735]: function=read name=hnd type=int order=1 const=no ref=no
[Y] Store OPAR[547]: name=buffer TypIndex=7 IsConst=0 IsReference=1 ParmOrder=2 FunIndex=165
[D] PAR[736]: function=read name=buffer type=char[] order=2 const=no ref=yes
[I] FUN: name=standard.read(int,char[]) index=310 searchindex=214, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.read($cvint,char[]) index=310 searchindex=51, scope={Pub:main}, scope={Pub:main}
[D] FID[310]: name=read kind=3 fullname=standard.read(int,char[]) id=standard_read2
[Y] Update OFUN[165]: ParmNr=3 ParmLow=545 ParmHigh=547
[A] DECL: (standard_read2)                    DECLARE {REF BOOLEAN $result,INTEGER hnd,REF ARRAYBLOCK buffer} AS SCALL(23) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):315:57: "syscall<writeall>       bool write(int hnd,char[] buffer)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(writeall) op(>) ty(bool) id(write) pu(() ty(int) id(hnd) pu(,) ty(char) pu([) pu(]) id(buffer) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<writeall>       bool write(int hnd,char[] buffer)
[Y] Store OFUN[166]: name=write Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=24 InstCode=-1 DlName= DlFunction=
[D] FUN[311]: name=write kind=SysCall returns=bool void=no nested=no scope={Pub:main} syscallnr=24
[Y] Store OPAR[548]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=166
[D] PAR[737]: function=write name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[549]: name=hnd TypIndex=3 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=166
[D] PAR[738]: function=write name=hnd type=int order=1 const=no ref=no
[Y] Store OPAR[550]: name=buffer TypIndex=7 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=166
[D] PAR[739]: function=write name=buffer type=char[] order=2 const=yes ref=yes
[I] FUN: name=standard.write(int,char[]) index=311 searchindex=272, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.write($cvint,char[]) index=311 searchindex=86, scope={Pub:main}, scope={Pub:main}
[D] FID[311]: name=write kind=3 fullname=standard.write(int,char[]) id=standard_write2
[Y] Update OFUN[166]: ParmNr=3 ParmLow=548 ParmHigh=550
[A] DECL: (standard_write2)                   DECLARE {REF BOOLEAN $result,INTEGER hnd,CONST REF ARRAYBLOCK buffer} AS SCALL(24) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):316:58: "syscall<readstr>        bool read(int hnd,ref string line)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(readstr) op(>) ty(bool) id(read) pu(() ty(int) id(hnd) pu(,) kw(ref) ty(string) id(line) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<readstr>        bool read(int hnd,ref string line)
[Y] Store OFUN[167]: name=read Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=25 InstCode=-1 DlName= DlFunction=
[D] FUN[312]: name=read kind=SysCall returns=bool void=no nested=no scope={Pub:main} syscallnr=25
[Y] Store OPAR[551]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=167
[D] PAR[740]: function=read name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[552]: name=hnd TypIndex=3 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=167
[D] PAR[741]: function=read name=hnd type=int order=1 const=no ref=no
[Y] Store OPAR[553]: name=line TypIndex=6 IsConst=0 IsReference=1 ParmOrder=2 FunIndex=167
[D] PAR[742]: function=read name=line type=string order=2 const=no ref=yes
[I] FUN: name=standard.read(int,string) index=312 searchindex=216, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.read($cvint,$cvstr) index=312 searchindex=51, scope={Pub:main}, scope={Pub:main}
[D] FID[312]: name=read kind=3 fullname=standard.read(int,string) id=standard_read3
[Y] Update OFUN[167]: ParmNr=3 ParmLow=551 ParmHigh=553
[A] DECL: (standard_read3)                    DECLARE {REF BOOLEAN $result,INTEGER hnd,REF STRINGBLOCK line} AS SCALL(25) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):317:55: "syscall<writestr>       bool write(int hnd,string line)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(writestr) op(>) ty(bool) id(write) pu(() ty(int) id(hnd) pu(,) ty(string) id(line) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<writestr>       bool write(int hnd,string line)
[Y] Store OFUN[168]: name=write Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=26 InstCode=-1 DlName= DlFunction=
[D] FUN[313]: name=write kind=SysCall returns=bool void=no nested=no scope={Pub:main} syscallnr=26
[Y] Store OPAR[554]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=168
[D] PAR[743]: function=write name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[555]: name=hnd TypIndex=3 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=168
[D] PAR[744]: function=write name=hnd type=int order=1 const=no ref=no
[Y] Store OPAR[556]: name=line TypIndex=6 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=168
[D] PAR[745]: function=write name=line type=string order=2 const=yes ref=yes
[I] FUN: name=standard.write(int,string) index=313 searchindex=275, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.write($cvint,$cvstr) index=313 searchindex=87, scope={Pub:main}, scope={Pub:main}
[D] FID[313]: name=write kind=3 fullname=standard.write(int,string) id=standard_write3
[Y] Update OFUN[168]: ParmNr=3 ParmLow=554 ParmHigh=556
[A] DECL: (standard_write3)                   DECLARE {REF BOOLEAN $result,INTEGER hnd,CONST REF STRINGBLOCK line} AS SCALL(26) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):318:60: "syscall<readstrall>     bool read(int hnd,ref string[] line)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(readstrall) op(>) ty(bool) id(read) pu(() ty(int) id(hnd) pu(,) kw(ref) ty(string) pu([) pu(]) id(line) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<readstrall>     bool read(int hnd,ref string[] line)
[Y] Store OFUN[169]: name=read Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=27 InstCode=-1 DlName= DlFunction=
[D] FUN[314]: name=read kind=SysCall returns=bool void=no nested=no scope={Pub:main} syscallnr=27
[Y] Store OPAR[557]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=169
[D] PAR[746]: function=read name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[558]: name=hnd TypIndex=3 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=169
[D] PAR[747]: function=read name=hnd type=int order=1 const=no ref=no
[Y] Store OPAR[559]: name=line TypIndex=8 IsConst=0 IsReference=1 ParmOrder=2 FunIndex=169
[D] PAR[748]: function=read name=line type=string[] order=2 const=no ref=yes
[I] FUN: name=standard.read(int,string[]) index=314 searchindex=217, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.read($cvint,string[]) index=314 searchindex=54, scope={Pub:main}, scope={Pub:main}
[D] FID[314]: name=read kind=3 fullname=standard.read(int,string[]) id=standard_read4
[Y] Update OFUN[169]: ParmNr=3 ParmLow=557 ParmHigh=559
[A] DECL: (standard_read4)                    DECLARE {REF BOOLEAN $result,INTEGER hnd,REF ARRAYBLOCK line} AS SCALL(27) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):319:57: "syscall<writestrall>    bool write(int hnd,string[] line)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(writestrall) op(>) ty(bool) id(write) pu(() ty(int) id(hnd) pu(,) ty(string) pu([) pu(]) id(line) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<writestrall>    bool write(int hnd,string[] line)
[Y] Store OFUN[170]: name=write Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=28 InstCode=-1 DlName= DlFunction=
[D] FUN[315]: name=write kind=SysCall returns=bool void=no nested=no scope={Pub:main} syscallnr=28
[Y] Store OPAR[560]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=170
[D] PAR[749]: function=write name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[561]: name=hnd TypIndex=3 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=170
[D] PAR[750]: function=write name=hnd type=int order=1 const=no ref=no
[Y] Store OPAR[562]: name=line TypIndex=8 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=170
[D] PAR[751]: function=write name=line type=string[] order=2 const=yes ref=yes
[I] FUN: name=standard.write(int,string[]) index=315 searchindex=277, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.write($cvint,string[]) index=315 searchindex=91, scope={Pub:main}, scope={Pub:main}
[D] FID[315]: name=write kind=3 fullname=standard.write(int,string[]) id=standard_write4
[Y] Update OFUN[170]: ParmNr=3 ParmLow=560 ParmHigh=562
[A] DECL: (standard_write4)                   DECLARE {REF BOOLEAN $result,INTEGER hnd,CONST REF ARRAYBLOCK line} AS SCALL(28) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):320:47: "syscall<endoffile>      bool endoffile(int hnd)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(endoffile) op(>) ty(bool) id(endoffile) pu(() ty(int) id(hnd) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<endoffile>      bool endoffile(int hnd)
[Y] Store OFUN[171]: name=endoffile Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=29 InstCode=-1 DlName= DlFunction=
[D] FUN[316]: name=endoffile kind=SysCall returns=bool void=no nested=no scope={Pub:main} syscallnr=29
[Y] Store OPAR[563]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=171
[D] PAR[752]: function=endoffile name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[564]: name=hnd TypIndex=3 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=171
[D] PAR[753]: function=endoffile name=hnd type=int order=1 const=no ref=no
[I] FUN: name=standard.endoffile(int) index=316 searchindex=190, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.endoffile($cvint) index=316 searchindex=34, scope={Pub:main}, scope={Pub:main}
[D] FID[316]: name=endoffile kind=3 fullname=standard.endoffile(int) id=standard_endoffile
[Y] Update OFUN[171]: ParmNr=2 ParmLow=563 ParmHigh=564
[A] DECL: (standard_endoffile)                DECLARE {REF BOOLEAN $result,INTEGER hnd} AS SCALL(29) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):321:47: "syscall<closefile>      bool closefile(int hnd)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(closefile) op(>) ty(bool) id(closefile) pu(() ty(int) id(hnd) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<closefile>      bool closefile(int hnd)
[Y] Store OFUN[172]: name=closefile Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=30 InstCode=-1 DlName= DlFunction=
[D] FUN[317]: name=closefile kind=SysCall returns=bool void=no nested=no scope={Pub:main} syscallnr=30
[Y] Store OPAR[565]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=172
[D] PAR[754]: function=closefile name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[566]: name=hnd TypIndex=3 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=172
[D] PAR[755]: function=closefile name=hnd type=int order=1 const=no ref=no
[I] FUN: name=standard.closefile(int) index=317 searchindex=143, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.closefile($cvint) index=317 searchindex=7, scope={Pub:main}, scope={Pub:main}
[D] FID[317]: name=closefile kind=3 fullname=standard.closefile(int) id=standard_closefile
[Y] Update OFUN[172]: ParmNr=2 ParmLow=565 ParmHigh=566
[A] DECL: (standard_closefile)                DECLARE {REF BOOLEAN $result,INTEGER hnd} AS SCALL(30) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):322:51: "syscall<filename>       string hndfilename(int hnd)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(filename) op(>) ty(string) id(hndfilename) pu(() ty(int) id(hnd) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<filename>       string hndfilename(int hnd)
[Y] Store OFUN[173]: name=hndfilename Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=6 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=31 InstCode=-1 DlName= DlFunction=
[D] FUN[318]: name=hndfilename kind=SysCall returns=string void=no nested=no scope={Pub:main} syscallnr=31
[Y] Store OPAR[567]: name=$result TypIndex=6 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=173
[D] PAR[756]: function=hndfilename name=$result type=string order=0 const=no ref=yes
[Y] Store OPAR[568]: name=hnd TypIndex=3 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=173
[D] PAR[757]: function=hndfilename name=hnd type=int order=1 const=no ref=no
[I] FUN: name=standard.hndfilename(int) index=318 searchindex=205, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.hndfilename($cvint) index=318 searchindex=42, scope={Pub:main}, scope={Pub:main}
[D] FID[318]: name=hndfilename kind=3 fullname=standard.hndfilename(int) id=standard_hndfilename
[Y] Update OFUN[173]: ParmNr=2 ParmLow=567 ParmHigh=568
[A] DECL: (standard_hndfilename)              DECLARE {REF STRINGBLOCK $result,INTEGER hnd} AS SCALL(31) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):323:68: "                        bool read(string filename,ref char[] buffer)"
[P] Parsed sentence: [FunDecl] ty(bool) id(read) pu(() ty(string) id(filename) pu(,) kw(ref) ty(char) pu([) pu(]) id(buffer) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;bool read(string filename,ref char[] buffer)
[Y] Store OFUN[174]: name=read Kind=0 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[319]: name=read kind=Function returns=bool void=no nested=no scope={Pub:main}
[Y] Store OPAR[569]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=174
[D] PAR[758]: function=read name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[570]: name=filename TypIndex=6 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=174
[D] PAR[759]: function=read name=filename type=string order=1 const=yes ref=yes
[Y] Store OPAR[571]: name=buffer TypIndex=7 IsConst=0 IsReference=1 ParmOrder=2 FunIndex=174
[D] PAR[760]: function=read name=buffer type=char[] order=2 const=no ref=yes
[I] FUN: name=standard.read(string,char[]) index=319 searchindex=221, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.read($cvstr,char[]) index=319 searchindex=58, scope={Pub:main}, scope={Pub:main}
[D] FID[319]: name=read kind=0 fullname=standard.read(string,char[]) id=standard_read5
[Y] Update OFUN[174]: ParmNr=3 ParmLow=569 ParmHigh=571
[A] DECL: (standard_read5)                    DECLARE {REF BOOLEAN $result,CONST REF STRINGBLOCK filename,REF ARRAYBLOCK buffer} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):324:65: "                        bool write(string filename,char[] buffer)"
[P] Parsed sentence: [FunDecl] ty(bool) id(write) pu(() ty(string) id(filename) pu(,) ty(char) pu([) pu(]) id(buffer) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;bool write(string filename,char[] buffer)
[Y] Store OFUN[175]: name=write Kind=0 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[320]: name=write kind=Function returns=bool void=no nested=no scope={Pub:main}
[Y] Store OPAR[572]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=175
[D] PAR[761]: function=write name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[573]: name=filename TypIndex=6 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=175
[D] PAR[762]: function=write name=filename type=string order=1 const=yes ref=yes
[Y] Store OPAR[574]: name=buffer TypIndex=7 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=175
[D] PAR[763]: function=write name=buffer type=char[] order=2 const=yes ref=yes
[I] FUN: name=standard.write(string,char[]) index=320 searchindex=282, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.write($cvstr,char[]) index=320 searchindex=96, scope={Pub:main}, scope={Pub:main}
[D] FID[320]: name=write kind=0 fullname=standard.write(string,char[]) id=standard_write5
[Y] Update OFUN[175]: ParmNr=3 ParmLow=572 ParmHigh=574
[A] DECL: (standard_write5)                   DECLARE {REF BOOLEAN $result,CONST REF STRINGBLOCK filename,CONST REF ARRAYBLOCK buffer} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):325:66: "                        bool read(string filename,ref string line)"
[P] Parsed sentence: [FunDecl] ty(bool) id(read) pu(() ty(string) id(filename) pu(,) kw(ref) ty(string) id(line) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;bool read(string filename,ref string line)
[Y] Store OFUN[176]: name=read Kind=0 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[321]: name=read kind=Function returns=bool void=no nested=no scope={Pub:main}
[Y] Store OPAR[575]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=176
[D] PAR[764]: function=read name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[576]: name=filename TypIndex=6 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=176
[D] PAR[765]: function=read name=filename type=string order=1 const=yes ref=yes
[Y] Store OPAR[577]: name=line TypIndex=6 IsConst=0 IsReference=1 ParmOrder=2 FunIndex=176
[D] PAR[766]: function=read name=line type=string order=2 const=no ref=yes
[I] FUN: name=standard.read(string,string) index=321 searchindex=222, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.read($cvstr,$cvstr) index=321 searchindex=58, scope={Pub:main}, scope={Pub:main}
[D] FID[321]: name=read kind=0 fullname=standard.read(string,string) id=standard_read6
[Y] Update OFUN[176]: ParmNr=3 ParmLow=575 ParmHigh=577
[A] DECL: (standard_read6)                    DECLARE {REF BOOLEAN $result,CONST REF STRINGBLOCK filename,REF STRINGBLOCK line} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):326:63: "                        bool write(string filename,string line)"
[P] Parsed sentence: [FunDecl] ty(bool) id(write) pu(() ty(string) id(filename) pu(,) ty(string) id(line) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;bool write(string filename,string line)
[Y] Store OFUN[177]: name=write Kind=0 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[322]: name=write kind=Function returns=bool void=no nested=no scope={Pub:main}
[Y] Store OPAR[578]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=177
[D] PAR[767]: function=write name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[579]: name=filename TypIndex=6 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=177
[D] PAR[768]: function=write name=filename type=string order=1 const=yes ref=yes
[Y] Store OPAR[580]: name=line TypIndex=6 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=177
[D] PAR[769]: function=write name=line type=string order=2 const=yes ref=yes
[I] FUN: name=standard.write(string,string) index=322 searchindex=284, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.write($cvstr,$cvstr) index=322 searchindex=97, scope={Pub:main}, scope={Pub:main}
[D] FID[322]: name=write kind=0 fullname=standard.write(string,string) id=standard_write6
[Y] Update OFUN[177]: ParmNr=3 ParmLow=578 ParmHigh=580
[A] DECL: (standard_write6)                   DECLARE {REF BOOLEAN $result,CONST REF STRINGBLOCK filename,CONST REF STRINGBLOCK line} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):327:68: "                        bool read(string filename,ref string[] line)"
[P] Parsed sentence: [FunDecl] ty(bool) id(read) pu(() ty(string) id(filename) pu(,) kw(ref) ty(string) pu([) pu(]) id(line) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;bool read(string filename,ref string[] line)
[Y] Store OFUN[178]: name=read Kind=0 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[323]: name=read kind=Function returns=bool void=no nested=no scope={Pub:main}
[Y] Store OPAR[581]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=178
[D] PAR[770]: function=read name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[582]: name=filename TypIndex=6 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=178
[D] PAR[771]: function=read name=filename type=string order=1 const=yes ref=yes
[Y] Store OPAR[583]: name=line TypIndex=8 IsConst=0 IsReference=1 ParmOrder=2 FunIndex=178
[D] PAR[772]: function=read name=line type=string[] order=2 const=no ref=yes
[I] FUN: name=standard.read(string,string[]) index=323 searchindex=223, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.read($cvstr,string[]) index=323 searchindex=60, scope={Pub:main}, scope={Pub:main}
[D] FID[323]: name=read kind=0 fullname=standard.read(string,string[]) id=standard_read7
[Y] Update OFUN[178]: ParmNr=3 ParmLow=581 ParmHigh=583
[A] DECL: (standard_read7)                    DECLARE {REF BOOLEAN $result,CONST REF STRINGBLOCK filename,REF ARRAYBLOCK line} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):328:65: "                        bool write(string filename,string[] line)"
[P] Parsed sentence: [FunDecl] ty(bool) id(write) pu(() ty(string) id(filename) pu(,) ty(string) pu([) pu(]) id(line) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;bool write(string filename,string[] line)
[Y] Store OFUN[179]: name=write Kind=0 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[324]: name=write kind=Function returns=bool void=no nested=no scope={Pub:main}
[Y] Store OPAR[584]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=179
[D] PAR[773]: function=write name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[585]: name=filename TypIndex=6 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=179
[D] PAR[774]: function=write name=filename type=string order=1 const=yes ref=yes
[Y] Store OPAR[586]: name=line TypIndex=8 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=179
[D] PAR[775]: function=write name=line type=string[] order=2 const=yes ref=yes
[I] FUN: name=standard.write(string,string[]) index=324 searchindex=286, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.write($cvstr,string[]) index=324 searchindex=100, scope={Pub:main}, scope={Pub:main}
[D] FID[324]: name=write kind=0 fullname=standard.write(string,string[]) id=standard_write7
[Y] Update OFUN[179]: ParmNr=3 ParmLow=584 ParmHigh=586
[A] DECL: (standard_write7)                   DECLARE {REF BOOLEAN $result,CONST REF STRINGBLOCK filename,CONST REF ARRAYBLOCK line} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):331:40: "syscall<abschr>         char abs(char a)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(abschr) op(>) ty(char) id(abs) pu(() ty(char) id(a) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<abschr>         char abs(char a)
[Y] Store OFUN[180]: name=abs Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=1 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=32 InstCode=-1 DlName= DlFunction=
[D] FUN[325]: name=abs kind=SysCall returns=char void=no nested=no scope={Pub:main} syscallnr=32
[Y] Store OPAR[587]: name=$result TypIndex=1 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=180
[D] PAR[776]: function=abs name=$result type=char order=0 const=no ref=yes
[Y] Store OPAR[588]: name=a TypIndex=1 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=180
[D] PAR[777]: function=abs name=a type=char order=1 const=no ref=no
[I] FUN: name=standard.abs(char) index=325 searchindex=142, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.abs($cvint) index=325 searchindex=7, scope={Pub:main}, scope={Pub:main}
[D] FID[325]: name=abs kind=3 fullname=standard.abs(char) id=standard_abs
[Y] Update OFUN[180]: ParmNr=2 ParmLow=587 ParmHigh=588
[A] DECL: (standard_abs)                      DECLARE {REF CHAR $result,CHAR a} AS SCALL(32) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):332:42: "syscall<absshr>         short abs(short a)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(absshr) op(>) ty(short) id(abs) pu(() ty(short) id(a) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<absshr>         short abs(short a)
[Y] Store OFUN[181]: name=abs Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=2 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=33 InstCode=-1 DlName= DlFunction=
[D] FUN[326]: name=abs kind=SysCall returns=short void=no nested=no scope={Pub:main} syscallnr=33
[Y] Store OPAR[589]: name=$result TypIndex=2 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=181
[D] PAR[778]: function=abs name=$result type=short order=0 const=no ref=yes
[Y] Store OPAR[590]: name=a TypIndex=2 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=181
[D] PAR[779]: function=abs name=a type=short order=1 const=no ref=no
[I] FUN: name=standard.abs(short) index=326 searchindex=143, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.abs($cvint) index=326 searchindex=7, scope={Pub:main}, scope={Pub:main}
[D] FID[326]: name=abs kind=3 fullname=standard.abs(short) id=standard_abs2
[Y] Update OFUN[181]: ParmNr=2 ParmLow=589 ParmHigh=590
[A] DECL: (standard_abs2)                     DECLARE {REF SHORT $result,SHORT a} AS SCALL(33) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):333:38: "syscall<absint>         int abs(int a)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(absint) op(>) ty(int) id(abs) pu(() ty(int) id(a) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<absint>         int abs(int a)
[Y] Store OFUN[182]: name=abs Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=3 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=34 InstCode=-1 DlName= DlFunction=
[D] FUN[327]: name=abs kind=SysCall returns=int void=no nested=no scope={Pub:main} syscallnr=34
[Y] Store OPAR[591]: name=$result TypIndex=3 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=182
[D] PAR[780]: function=abs name=$result type=int order=0 const=no ref=yes
[Y] Store OPAR[592]: name=a TypIndex=3 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=182
[D] PAR[781]: function=abs name=a type=int order=1 const=no ref=no
[I] FUN: name=standard.abs(int) index=327 searchindex=143, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.abs($cvint) index=327 searchindex=8, scope={Pub:main}, scope={Pub:main}
[D] FID[327]: name=abs kind=3 fullname=standard.abs(int) id=standard_abs3
[Y] Update OFUN[182]: ParmNr=2 ParmLow=591 ParmHigh=592
[A] DECL: (standard_abs3)                     DECLARE {REF INTEGER $result,INTEGER a} AS SCALL(34) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):334:40: "syscall<abslon>         long abs(long a)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(abslon) op(>) ty(long) id(abs) pu(() ty(long) id(a) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<abslon>         long abs(long a)
[Y] Store OFUN[183]: name=abs Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=4 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=35 InstCode=-1 DlName= DlFunction=
[D] FUN[328]: name=abs kind=SysCall returns=long void=no nested=no scope={Pub:main} syscallnr=35
[Y] Store OPAR[593]: name=$result TypIndex=4 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=183
[D] PAR[782]: function=abs name=$result type=long order=0 const=no ref=yes
[Y] Store OPAR[594]: name=a TypIndex=4 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=183
[D] PAR[783]: function=abs name=a type=long order=1 const=no ref=no
[I] FUN: name=standard.abs(long) index=328 searchindex=144, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.abs($cvint) index=328 searchindex=8, scope={Pub:main}, scope={Pub:main}
[D] FID[328]: name=abs kind=3 fullname=standard.abs(long) id=standard_abs4
[Y] Update OFUN[183]: ParmNr=2 ParmLow=593 ParmHigh=594
[A] DECL: (standard_abs4)                     DECLARE {REF LONG $result,LONG a} AS SCALL(35) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):335:42: "syscall<absflo>         float abs(float a)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(absflo) op(>) ty(float) id(abs) pu(() ty(float) id(a) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<absflo>         float abs(float a)
[Y] Store OFUN[184]: name=abs Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=5 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=36 InstCode=-1 DlName= DlFunction=
[D] FUN[329]: name=abs kind=SysCall returns=float void=no nested=no scope={Pub:main} syscallnr=36
[Y] Store OPAR[595]: name=$result TypIndex=5 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=184
[D] PAR[784]: function=abs name=$result type=float order=0 const=no ref=yes
[Y] Store OPAR[596]: name=a TypIndex=5 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=184
[D] PAR[785]: function=abs name=a type=float order=1 const=no ref=no
[I] FUN: name=standard.abs(float) index=329 searchindex=143, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.abs($cvflo) index=329 searchindex=7, scope={Pub:main}, scope={Pub:main}
[D] FID[329]: name=abs kind=3 fullname=standard.abs(float) id=standard_abs5
[Y] Update OFUN[184]: ParmNr=2 ParmLow=595 ParmHigh=596
[A] DECL: (standard_abs5)                     DECLARE {REF FLOAT $result,FLOAT a} AS SCALL(36) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):336:47: "syscall<minchr>         char min(char a,char b)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(minchr) op(>) ty(char) id(min) pu(() ty(char) id(a) pu(,) ty(char) id(b) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<minchr>         char min(char a,char b)
[Y] Store OFUN[185]: name=min Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=1 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=37 InstCode=-1 DlName= DlFunction=
[D] FUN[330]: name=min kind=SysCall returns=char void=no nested=no scope={Pub:main} syscallnr=37
[Y] Store OPAR[597]: name=$result TypIndex=1 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=185
[D] PAR[786]: function=min name=$result type=char order=0 const=no ref=yes
[Y] Store OPAR[598]: name=a TypIndex=1 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=185
[D] PAR[787]: function=min name=a type=char order=1 const=no ref=no
[Y] Store OPAR[599]: name=b TypIndex=1 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=185
[D] PAR[788]: function=min name=b type=char order=2 const=no ref=no
[I] FUN: name=standard.min(char,char) index=330 searchindex=216, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.min($cvint,$cvint) index=330 searchindex=53, scope={Pub:main}, scope={Pub:main}
[D] FID[330]: name=min kind=3 fullname=standard.min(char,char) id=standard_min
[Y] Update OFUN[185]: ParmNr=3 ParmLow=597 ParmHigh=599
[A] DECL: (standard_min)                      DECLARE {REF CHAR $result,CHAR a,CHAR b} AS SCALL(37) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):337:50: "syscall<minshr>         short min(short a,short b)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(minshr) op(>) ty(short) id(min) pu(() ty(short) id(a) pu(,) ty(short) id(b) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<minshr>         short min(short a,short b)
[Y] Store OFUN[186]: name=min Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=2 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=38 InstCode=-1 DlName= DlFunction=
[D] FUN[331]: name=min kind=SysCall returns=short void=no nested=no scope={Pub:main} syscallnr=38
[Y] Store OPAR[600]: name=$result TypIndex=2 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=186
[D] PAR[789]: function=min name=$result type=short order=0 const=no ref=yes
[Y] Store OPAR[601]: name=a TypIndex=2 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=186
[D] PAR[790]: function=min name=a type=short order=1 const=no ref=no
[Y] Store OPAR[602]: name=b TypIndex=2 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=186
[D] PAR[791]: function=min name=b type=short order=2 const=no ref=no
[I] FUN: name=standard.min(short,short) index=331 searchindex=217, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.min($cvint,$cvint) index=331 searchindex=53, scope={Pub:main}, scope={Pub:main}
[D] FID[331]: name=min kind=3 fullname=standard.min(short,short) id=standard_min2
[Y] Update OFUN[186]: ParmNr=3 ParmLow=600 ParmHigh=602
[A] DECL: (standard_min2)                     DECLARE {REF SHORT $result,SHORT a,SHORT b} AS SCALL(38) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):338:44: "syscall<minint>         int min(int a,int b)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(minint) op(>) ty(int) id(min) pu(() ty(int) id(a) pu(,) ty(int) id(b) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<minint>         int min(int a,int b)
[Y] Store OFUN[187]: name=min Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=3 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=39 InstCode=-1 DlName= DlFunction=
[D] FUN[332]: name=min kind=SysCall returns=int void=no nested=no scope={Pub:main} syscallnr=39
[Y] Store OPAR[603]: name=$result TypIndex=3 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=187
[D] PAR[792]: function=min name=$result type=int order=0 const=no ref=yes
[Y] Store OPAR[604]: name=a TypIndex=3 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=187
[D] PAR[793]: function=min name=a type=int order=1 const=no ref=no
[Y] Store OPAR[605]: name=b TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=187
[D] PAR[794]: function=min name=b type=int order=2 const=no ref=no
[I] FUN: name=standard.min(int,int) index=332 searchindex=217, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.min($cvint,$cvint) index=332 searchindex=54, scope={Pub:main}, scope={Pub:main}
[D] FID[332]: name=min kind=3 fullname=standard.min(int,int) id=standard_min3
[Y] Update OFUN[187]: ParmNr=3 ParmLow=603 ParmHigh=605
[A] DECL: (standard_min3)                     DECLARE {REF INTEGER $result,INTEGER a,INTEGER b} AS SCALL(39) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):339:47: "syscall<minlon>         long min(long a,long b)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(minlon) op(>) ty(long) id(min) pu(() ty(long) id(a) pu(,) ty(long) id(b) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<minlon>         long min(long a,long b)
[Y] Store OFUN[188]: name=min Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=4 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=40 InstCode=-1 DlName= DlFunction=
[D] FUN[333]: name=min kind=SysCall returns=long void=no nested=no scope={Pub:main} syscallnr=40
[Y] Store OPAR[606]: name=$result TypIndex=4 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=188
[D] PAR[795]: function=min name=$result type=long order=0 const=no ref=yes
[Y] Store OPAR[607]: name=a TypIndex=4 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=188
[D] PAR[796]: function=min name=a type=long order=1 const=no ref=no
[Y] Store OPAR[608]: name=b TypIndex=4 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=188
[D] PAR[797]: function=min name=b type=long order=2 const=no ref=no
[I] FUN: name=standard.min(long,long) index=333 searchindex=218, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.min($cvint,$cvint) index=333 searchindex=54, scope={Pub:main}, scope={Pub:main}
[D] FID[333]: name=min kind=3 fullname=standard.min(long,long) id=standard_min4
[Y] Update OFUN[188]: ParmNr=3 ParmLow=606 ParmHigh=608
[A] DECL: (standard_min4)                     DECLARE {REF LONG $result,LONG a,LONG b} AS SCALL(40) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):340:50: "syscall<minflo>         float min(float a,float b)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(minflo) op(>) ty(float) id(min) pu(() ty(float) id(a) pu(,) ty(float) id(b) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<minflo>         float min(float a,float b)
[Y] Store OFUN[189]: name=min Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=5 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=41 InstCode=-1 DlName= DlFunction=
[D] FUN[334]: name=min kind=SysCall returns=float void=no nested=no scope={Pub:main} syscallnr=41
[Y] Store OPAR[609]: name=$result TypIndex=5 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=189
[D] PAR[798]: function=min name=$result type=float order=0 const=no ref=yes
[Y] Store OPAR[610]: name=a TypIndex=5 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=189
[D] PAR[799]: function=min name=a type=float order=1 const=no ref=no
[Y] Store OPAR[611]: name=b TypIndex=5 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=189
[D] PAR[800]: function=min name=b type=float order=2 const=no ref=no
[I] FUN: name=standard.min(float,float) index=334 searchindex=217, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.min($cvflo,$cvflo) index=334 searchindex=53, scope={Pub:main}, scope={Pub:main}
[D] FID[334]: name=min kind=3 fullname=standard.min(float,float) id=standard_min5
[Y] Update OFUN[189]: ParmNr=3 ParmLow=609 ParmHigh=611
[A] DECL: (standard_min5)                     DECLARE {REF FLOAT $result,FLOAT a,FLOAT b} AS SCALL(41) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):341:47: "syscall<maxchr>         char max(char a,char b)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(maxchr) op(>) ty(char) id(max) pu(() ty(char) id(a) pu(,) ty(char) id(b) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<maxchr>         char max(char a,char b)
[Y] Store OFUN[190]: name=max Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=1 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=42 InstCode=-1 DlName= DlFunction=
[D] FUN[335]: name=max kind=SysCall returns=char void=no nested=no scope={Pub:main} syscallnr=42
[Y] Store OPAR[612]: name=$result TypIndex=1 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=190
[D] PAR[801]: function=max name=$result type=char order=0 const=no ref=yes
[Y] Store OPAR[613]: name=a TypIndex=1 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=190
[D] PAR[802]: function=max name=a type=char order=1 const=no ref=no
[Y] Store OPAR[614]: name=b TypIndex=1 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=190
[D] PAR[803]: function=max name=b type=char order=2 const=no ref=no
[I] FUN: name=standard.max(char,char) index=335 searchindex=216, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.max($cvint,$cvint) index=335 searchindex=53, scope={Pub:main}, scope={Pub:main}
[D] FID[335]: name=max kind=3 fullname=standard.max(char,char) id=standard_max
[Y] Update OFUN[190]: ParmNr=3 ParmLow=612 ParmHigh=614
[A] DECL: (standard_max)                      DECLARE {REF CHAR $result,CHAR a,CHAR b} AS SCALL(42) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):342:50: "syscall<maxshr>         short max(short a,short b)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(maxshr) op(>) ty(short) id(max) pu(() ty(short) id(a) pu(,) ty(short) id(b) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<maxshr>         short max(short a,short b)
[Y] Store OFUN[191]: name=max Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=2 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=43 InstCode=-1 DlName= DlFunction=
[D] FUN[336]: name=max kind=SysCall returns=short void=no nested=no scope={Pub:main} syscallnr=43
[Y] Store OPAR[615]: name=$result TypIndex=2 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=191
[D] PAR[804]: function=max name=$result type=short order=0 const=no ref=yes
[Y] Store OPAR[616]: name=a TypIndex=2 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=191
[D] PAR[805]: function=max name=a type=short order=1 const=no ref=no
[Y] Store OPAR[617]: name=b TypIndex=2 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=191
[D] PAR[806]: function=max name=b type=short order=2 const=no ref=no
[I] FUN: name=standard.max(short,short) index=336 searchindex=217, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.max($cvint,$cvint) index=336 searchindex=53, scope={Pub:main}, scope={Pub:main}
[D] FID[336]: name=max kind=3 fullname=standard.max(short,short) id=standard_max2
[Y] Update OFUN[191]: ParmNr=3 ParmLow=615 ParmHigh=617
[A] DECL: (standard_max2)                     DECLARE {REF SHORT $result,SHORT a,SHORT b} AS SCALL(43) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):343:44: "syscall<maxint>         int max(int a,int b)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(maxint) op(>) ty(int) id(max) pu(() ty(int) id(a) pu(,) ty(int) id(b) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<maxint>         int max(int a,int b)
[Y] Store OFUN[192]: name=max Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=3 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=44 InstCode=-1 DlName= DlFunction=
[D] FUN[337]: name=max kind=SysCall returns=int void=no nested=no scope={Pub:main} syscallnr=44
[Y] Store OPAR[618]: name=$result TypIndex=3 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=192
[D] PAR[807]: function=max name=$result type=int order=0 const=no ref=yes
[Y] Store OPAR[619]: name=a TypIndex=3 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=192
[D] PAR[808]: function=max name=a type=int order=1 const=no ref=no
[Y] Store OPAR[620]: name=b TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=192
[D] PAR[809]: function=max name=b type=int order=2 const=no ref=no
[I] FUN: name=standard.max(int,int) index=337 searchindex=217, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.max($cvint,$cvint) index=337 searchindex=53, scope={Pub:main}, scope={Pub:main}
[D] FID[337]: name=max kind=3 fullname=standard.max(int,int) id=standard_max3
[Y] Update OFUN[192]: ParmNr=3 ParmLow=618 ParmHigh=620
[A] DECL: (standard_max3)                     DECLARE {REF INTEGER $result,INTEGER a,INTEGER b} AS SCALL(44) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):344:47: "syscall<maxlon>         long max(long a,long b)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(maxlon) op(>) ty(long) id(max) pu(() ty(long) id(a) pu(,) ty(long) id(b) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<maxlon>         long max(long a,long b)
[Y] Store OFUN[193]: name=max Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=4 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=45 InstCode=-1 DlName= DlFunction=
[D] FUN[338]: name=max kind=SysCall returns=long void=no nested=no scope={Pub:main} syscallnr=45
[Y] Store OPAR[621]: name=$result TypIndex=4 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=193
[D] PAR[810]: function=max name=$result type=long order=0 const=no ref=yes
[Y] Store OPAR[622]: name=a TypIndex=4 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=193
[D] PAR[811]: function=max name=a type=long order=1 const=no ref=no
[Y] Store OPAR[623]: name=b TypIndex=4 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=193
[D] PAR[812]: function=max name=b type=long order=2 const=no ref=no
[I] FUN: name=standard.max(long,long) index=338 searchindex=218, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.max($cvint,$cvint) index=338 searchindex=54, scope={Pub:main}, scope={Pub:main}
[D] FID[338]: name=max kind=3 fullname=standard.max(long,long) id=standard_max4
[Y] Update OFUN[193]: ParmNr=3 ParmLow=621 ParmHigh=623
[A] DECL: (standard_max4)                     DECLARE {REF LONG $result,LONG a,LONG b} AS SCALL(45) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):345:50: "syscall<maxflo>         float max(float a,float b)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(maxflo) op(>) ty(float) id(max) pu(() ty(float) id(a) pu(,) ty(float) id(b) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<maxflo>         float max(float a,float b)
[Y] Store OFUN[194]: name=max Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=5 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=46 InstCode=-1 DlName= DlFunction=
[D] FUN[339]: name=max kind=SysCall returns=float void=no nested=no scope={Pub:main} syscallnr=46
[Y] Store OPAR[624]: name=$result TypIndex=5 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=194
[D] PAR[813]: function=max name=$result type=float order=0 const=no ref=yes
[Y] Store OPAR[625]: name=a TypIndex=5 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=194
[D] PAR[814]: function=max name=a type=float order=1 const=no ref=no
[Y] Store OPAR[626]: name=b TypIndex=5 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=194
[D] PAR[815]: function=max name=b type=float order=2 const=no ref=no
[I] FUN: name=standard.max(float,float) index=339 searchindex=217, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.max($cvflo,$cvflo) index=339 searchindex=53, scope={Pub:main}, scope={Pub:main}
[D] FID[339]: name=max kind=3 fullname=standard.max(float,float) id=standard_max5
[Y] Update OFUN[194]: ParmNr=3 ParmLow=624 ParmHigh=626
[A] DECL: (standard_max5)                     DECLARE {REF FLOAT $result,FLOAT a,FLOAT b} AS SCALL(46) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):346:42: "syscall<exp>            float exp(float x)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(exp) op(>) ty(float) id(exp) pu(() ty(float) id(x) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<exp>            float exp(float x)
[Y] Store OFUN[195]: name=exp Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=5 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=47 InstCode=-1 DlName= DlFunction=
[D] FUN[340]: name=exp kind=SysCall returns=float void=no nested=no scope={Pub:main} syscallnr=47
[Y] Store OPAR[627]: name=$result TypIndex=5 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=195
[D] PAR[816]: function=exp name=$result type=float order=0 const=no ref=yes
[Y] Store OPAR[628]: name=x TypIndex=5 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=195
[D] PAR[817]: function=exp name=x type=float order=1 const=no ref=no
[I] FUN: name=standard.exp(float) index=340 searchindex=198, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.exp($cvflo) index=340 searchindex=41, scope={Pub:main}, scope={Pub:main}
[D] FID[340]: name=exp kind=3 fullname=standard.exp(float) id=standard_exp
[Y] Update OFUN[195]: ParmNr=2 ParmLow=627 ParmHigh=628
[A] DECL: (standard_exp)                      DECLARE {REF FLOAT $result,FLOAT x} AS SCALL(47) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):347:41: "syscall<ln>             float ln(float x)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(ln) op(>) ty(float) id(ln) pu(() ty(float) id(x) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<ln>             float ln(float x)
[Y] Store OFUN[196]: name=ln Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=5 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=48 InstCode=-1 DlName= DlFunction=
[D] FUN[341]: name=ln kind=SysCall returns=float void=no nested=no scope={Pub:main} syscallnr=48
[Y] Store OPAR[629]: name=$result TypIndex=5 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=196
[D] PAR[818]: function=ln name=$result type=float order=0 const=no ref=yes
[Y] Store OPAR[630]: name=x TypIndex=5 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=196
[D] PAR[819]: function=ln name=x type=float order=1 const=no ref=no
[I] FUN: name=standard.ln(float) index=341 searchindex=217, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.ln($cvflo) index=341 searchindex=54, scope={Pub:main}, scope={Pub:main}
[D] FID[341]: name=ln kind=3 fullname=standard.ln(float) id=standard_ln
[Y] Update OFUN[196]: ParmNr=2 ParmLow=629 ParmHigh=630
[A] DECL: (standard_ln)                       DECLARE {REF FLOAT $result,FLOAT x} AS SCALL(48) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):348:42: "syscall<log>            float log(float x)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(log) op(>) ty(float) id(log) pu(() ty(float) id(x) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<log>            float log(float x)
[Y] Store OFUN[197]: name=log Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=5 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=49 InstCode=-1 DlName= DlFunction=
[D] FUN[342]: name=log kind=SysCall returns=float void=no nested=no scope={Pub:main} syscallnr=49
[Y] Store OPAR[631]: name=$result TypIndex=5 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=197
[D] PAR[820]: function=log name=$result type=float order=0 const=no ref=yes
[Y] Store OPAR[632]: name=x TypIndex=5 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=197
[D] PAR[821]: function=log name=x type=float order=1 const=no ref=no
[I] FUN: name=standard.log(float) index=342 searchindex=218, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.log($cvflo) index=342 searchindex=55, scope={Pub:main}, scope={Pub:main}
[D] FID[342]: name=log kind=3 fullname=standard.log(float) id=standard_log
[Y] Update OFUN[197]: ParmNr=2 ParmLow=631 ParmHigh=632
[A] DECL: (standard_log)                      DECLARE {REF FLOAT $result,FLOAT x} AS SCALL(49) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):349:59: "syscall<logn>           float logn(float base,float number)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(logn) op(>) ty(float) id(logn) pu(() ty(float) id(base) pu(,) ty(float) id(number) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<logn>           float logn(float base,float number)
[Y] Store OFUN[198]: name=logn Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=5 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=50 InstCode=-1 DlName= DlFunction=
[D] FUN[343]: name=logn kind=SysCall returns=float void=no nested=no scope={Pub:main} syscallnr=50
[Y] Store OPAR[633]: name=$result TypIndex=5 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=198
[D] PAR[822]: function=logn name=$result type=float order=0 const=no ref=yes
[Y] Store OPAR[634]: name=base TypIndex=5 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=198
[D] PAR[823]: function=logn name=base type=float order=1 const=no ref=no
[Y] Store OPAR[635]: name=number TypIndex=5 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=198
[D] PAR[824]: function=logn name=number type=float order=2 const=no ref=no
[I] FUN: name=standard.logn(float,float) index=343 searchindex=219, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.logn($cvflo,$cvflo) index=343 searchindex=56, scope={Pub:main}, scope={Pub:main}
[D] FID[343]: name=logn kind=3 fullname=standard.logn(float,float) id=standard_logn
[Y] Update OFUN[198]: ParmNr=3 ParmLow=633 ParmHigh=635
[A] DECL: (standard_logn)                     DECLARE {REF FLOAT $result,FLOAT base,FLOAT number} AS SCALL(50) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):350:60: "syscall<pow>            float pow(float base,float exponent)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(pow) op(>) ty(float) id(pow) pu(() ty(float) id(base) pu(,) ty(float) id(exponent) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<pow>            float pow(float base,float exponent)
[Y] Store OFUN[199]: name=pow Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=5 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=51 InstCode=-1 DlName= DlFunction=
[D] FUN[344]: name=pow kind=SysCall returns=float void=no nested=no scope={Pub:main} syscallnr=51
[Y] Store OPAR[636]: name=$result TypIndex=5 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=199
[D] PAR[825]: function=pow name=$result type=float order=0 const=no ref=yes
[Y] Store OPAR[637]: name=base TypIndex=5 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=199
[D] PAR[826]: function=pow name=base type=float order=1 const=no ref=no
[Y] Store OPAR[638]: name=exponent TypIndex=5 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=199
[D] PAR[827]: function=pow name=exponent type=float order=2 const=no ref=no
[I] FUN: name=standard.pow(float,float) index=344 searchindex=234, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.pow($cvflo,$cvflo) index=344 searchindex=71, scope={Pub:main}, scope={Pub:main}
[D] FID[344]: name=pow kind=3 fullname=standard.pow(float,float) id=standard_pow
[Y] Update OFUN[199]: ParmNr=3 ParmLow=636 ParmHigh=638
[A] DECL: (standard_pow)                      DECLARE {REF FLOAT $result,FLOAT base,FLOAT exponent} AS SCALL(51) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):351:43: "syscall<sqrt>           float sqrt(float x)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(sqrt) op(>) ty(float) id(sqrt) pu(() ty(float) id(x) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<sqrt>           float sqrt(float x)
[Y] Store OFUN[200]: name=sqrt Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=5 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=52 InstCode=-1 DlName= DlFunction=
[D] FUN[345]: name=sqrt kind=SysCall returns=float void=no nested=no scope={Pub:main} syscallnr=52
[Y] Store OPAR[639]: name=$result TypIndex=5 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=200
[D] PAR[828]: function=sqrt name=$result type=float order=0 const=no ref=yes
[Y] Store OPAR[640]: name=x TypIndex=5 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=200
[D] PAR[829]: function=sqrt name=x type=float order=1 const=no ref=no
[I] FUN: name=standard.sqrt(float) index=345 searchindex=244, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.sqrt($cvflo) index=345 searchindex=81, scope={Pub:main}, scope={Pub:main}
[D] FID[345]: name=sqrt kind=3 fullname=standard.sqrt(float) id=standard_sqrt
[Y] Update OFUN[200]: ParmNr=2 ParmLow=639 ParmHigh=640
[A] DECL: (standard_sqrt)                     DECLARE {REF FLOAT $result,FLOAT x} AS SCALL(52) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):352:43: "syscall<cbrt>           float cbrt(float x)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(cbrt) op(>) ty(float) id(cbrt) pu(() ty(float) id(x) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<cbrt>           float cbrt(float x)
[Y] Store OFUN[201]: name=cbrt Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=5 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=53 InstCode=-1 DlName= DlFunction=
[D] FUN[346]: name=cbrt kind=SysCall returns=float void=no nested=no scope={Pub:main} syscallnr=53
[Y] Store OPAR[641]: name=$result TypIndex=5 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=201
[D] PAR[830]: function=cbrt name=$result type=float order=0 const=no ref=yes
[Y] Store OPAR[642]: name=x TypIndex=5 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=201
[D] PAR[831]: function=cbrt name=x type=float order=1 const=no ref=no
[I] FUN: name=standard.cbrt(float) index=346 searchindex=148, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.cbrt($cvflo) index=346 searchindex=12, scope={Pub:main}, scope={Pub:main}
[D] FID[346]: name=cbrt kind=3 fullname=standard.cbrt(float) id=standard_cbrt
[Y] Update OFUN[201]: ParmNr=2 ParmLow=641 ParmHigh=642
[A] DECL: (standard_cbrt)                     DECLARE {REF FLOAT $result,FLOAT x} AS SCALL(53) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):353:42: "syscall<sin>            float sin(float x)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(sin) op(>) ty(float) id(sin) pu(() ty(float) id(x) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<sin>            float sin(float x)
[Y] Store OFUN[202]: name=sin Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=5 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=54 InstCode=-1 DlName= DlFunction=
[D] FUN[347]: name=sin kind=SysCall returns=float void=no nested=no scope={Pub:main} syscallnr=54
[Y] Store OPAR[643]: name=$result TypIndex=5 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=202
[D] PAR[832]: function=sin name=$result type=float order=0 const=no ref=yes
[Y] Store OPAR[644]: name=x TypIndex=5 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=202
[D] PAR[833]: function=sin name=x type=float order=1 const=no ref=no
[I] FUN: name=standard.sin(float) index=347 searchindex=245, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.sin($cvflo) index=347 searchindex=82, scope={Pub:main}, scope={Pub:main}
[D] FID[347]: name=sin kind=3 fullname=standard.sin(float) id=standard_sin
[Y] Update OFUN[202]: ParmNr=2 ParmLow=643 ParmHigh=644
[A] DECL: (standard_sin)                      DECLARE {REF FLOAT $result,FLOAT x} AS SCALL(54) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):354:42: "syscall<cos>            float cos(float x)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(cos) op(>) ty(float) id(cos) pu(() ty(float) id(x) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<cos>            float cos(float x)
[Y] Store OFUN[203]: name=cos Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=5 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=55 InstCode=-1 DlName= DlFunction=
[D] FUN[348]: name=cos kind=SysCall returns=float void=no nested=no scope={Pub:main} syscallnr=55
[Y] Store OPAR[645]: name=$result TypIndex=5 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=203
[D] PAR[834]: function=cos name=$result type=float order=0 const=no ref=yes
[Y] Store OPAR[646]: name=x TypIndex=5 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=203
[D] PAR[835]: function=cos name=x type=float order=1 const=no ref=no
[I] FUN: name=standard.cos(float) index=348 searchindex=150, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.cos($cvflo) index=348 searchindex=14, scope={Pub:main}, scope={Pub:main}
[D] FID[348]: name=cos kind=3 fullname=standard.cos(float) id=standard_cos
[Y] Update OFUN[203]: ParmNr=2 ParmLow=645 ParmHigh=646
[A] DECL: (standard_cos)                      DECLARE {REF FLOAT $result,FLOAT x} AS SCALL(55) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):355:42: "syscall<tan>            float tan(float x)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(tan) op(>) ty(float) id(tan) pu(() ty(float) id(x) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<tan>            float tan(float x)
[Y] Store OFUN[204]: name=tan Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=5 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=56 InstCode=-1 DlName= DlFunction=
[D] FUN[349]: name=tan kind=SysCall returns=float void=no nested=no scope={Pub:main} syscallnr=56
[Y] Store OPAR[647]: name=$result TypIndex=5 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=204
[D] PAR[836]: function=tan name=$result type=float order=0 const=no ref=yes
[Y] Store OPAR[648]: name=x TypIndex=5 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=204
[D] PAR[837]: function=tan name=x type=float order=1 const=no ref=no
[I] FUN: name=standard.tan(float) index=349 searchindex=248, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.tan($cvflo) index=349 searchindex=85, scope={Pub:main}, scope={Pub:main}
[D] FID[349]: name=tan kind=3 fullname=standard.tan(float) id=standard_tan
[Y] Update OFUN[204]: ParmNr=2 ParmLow=647 ParmHigh=648
[A] DECL: (standard_tan)                      DECLARE {REF FLOAT $result,FLOAT x} AS SCALL(56) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):356:43: "syscall<asin>           float asin(float x)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(asin) op(>) ty(float) id(asin) pu(() ty(float) id(x) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<asin>           float asin(float x)
[Y] Store OFUN[205]: name=asin Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=5 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=57 InstCode=-1 DlName= DlFunction=
[D] FUN[350]: name=asin kind=SysCall returns=float void=no nested=no scope={Pub:main} syscallnr=57
[Y] Store OPAR[649]: name=$result TypIndex=5 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=205
[D] PAR[838]: function=asin name=$result type=float order=0 const=no ref=yes
[Y] Store OPAR[650]: name=x TypIndex=5 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=205
[D] PAR[839]: function=asin name=x type=float order=1 const=no ref=no
[I] FUN: name=standard.asin(float) index=350 searchindex=148, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.asin($cvflo) index=350 searchindex=12, scope={Pub:main}, scope={Pub:main}
[D] FID[350]: name=asin kind=3 fullname=standard.asin(float) id=standard_asin
[Y] Update OFUN[205]: ParmNr=2 ParmLow=649 ParmHigh=650
[A] DECL: (standard_asin)                     DECLARE {REF FLOAT $result,FLOAT x} AS SCALL(57) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):357:43: "syscall<acos>           float acos(float x)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(acos) op(>) ty(float) id(acos) pu(() ty(float) id(x) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<acos>           float acos(float x)
[Y] Store OFUN[206]: name=acos Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=5 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=58 InstCode=-1 DlName= DlFunction=
[D] FUN[351]: name=acos kind=SysCall returns=float void=no nested=no scope={Pub:main} syscallnr=58
[Y] Store OPAR[651]: name=$result TypIndex=5 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=206
[D] PAR[840]: function=acos name=$result type=float order=0 const=no ref=yes
[Y] Store OPAR[652]: name=x TypIndex=5 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=206
[D] PAR[841]: function=acos name=x type=float order=1 const=no ref=no
[I] FUN: name=standard.acos(float) index=351 searchindex=147, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.acos($cvflo) index=351 searchindex=12, scope={Pub:main}, scope={Pub:main}
[D] FID[351]: name=acos kind=3 fullname=standard.acos(float) id=standard_acos
[Y] Update OFUN[206]: ParmNr=2 ParmLow=651 ParmHigh=652
[A] DECL: (standard_acos)                     DECLARE {REF FLOAT $result,FLOAT x} AS SCALL(58) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):358:43: "syscall<atan>           float atan(float x)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(atan) op(>) ty(float) id(atan) pu(() ty(float) id(x) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<atan>           float atan(float x)
[Y] Store OFUN[207]: name=atan Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=5 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=59 InstCode=-1 DlName= DlFunction=
[D] FUN[352]: name=atan kind=SysCall returns=float void=no nested=no scope={Pub:main} syscallnr=59
[Y] Store OPAR[653]: name=$result TypIndex=5 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=207
[D] PAR[842]: function=atan name=$result type=float order=0 const=no ref=yes
[Y] Store OPAR[654]: name=x TypIndex=5 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=207
[D] PAR[843]: function=atan name=x type=float order=1 const=no ref=no
[I] FUN: name=standard.atan(float) index=352 searchindex=150, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.atan($cvflo) index=352 searchindex=14, scope={Pub:main}, scope={Pub:main}
[D] FID[352]: name=atan kind=3 fullname=standard.atan(float) id=standard_atan
[Y] Update OFUN[207]: ParmNr=2 ParmLow=653 ParmHigh=654
[A] DECL: (standard_atan)                     DECLARE {REF FLOAT $result,FLOAT x} AS SCALL(59) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):359:43: "syscall<sinh>           float sinh(float x)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(sinh) op(>) ty(float) id(sinh) pu(() ty(float) id(x) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<sinh>           float sinh(float x)
[Y] Store OFUN[208]: name=sinh Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=5 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=60 InstCode=-1 DlName= DlFunction=
[D] FUN[353]: name=sinh kind=SysCall returns=float void=no nested=no scope={Pub:main} syscallnr=60
[Y] Store OPAR[655]: name=$result TypIndex=5 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=208
[D] PAR[844]: function=sinh name=$result type=float order=0 const=no ref=yes
[Y] Store OPAR[656]: name=x TypIndex=5 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=208
[D] PAR[845]: function=sinh name=x type=float order=1 const=no ref=no
[I] FUN: name=standard.sinh(float) index=353 searchindex=250, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.sinh($cvflo) index=353 searchindex=87, scope={Pub:main}, scope={Pub:main}
[D] FID[353]: name=sinh kind=3 fullname=standard.sinh(float) id=standard_sinh
[Y] Update OFUN[208]: ParmNr=2 ParmLow=655 ParmHigh=656
[A] DECL: (standard_sinh)                     DECLARE {REF FLOAT $result,FLOAT x} AS SCALL(60) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):360:43: "syscall<cosh>           float cosh(float x)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(cosh) op(>) ty(float) id(cosh) pu(() ty(float) id(x) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<cosh>           float cosh(float x)
[Y] Store OFUN[209]: name=cosh Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=5 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=61 InstCode=-1 DlName= DlFunction=
[D] FUN[354]: name=cosh kind=SysCall returns=float void=no nested=no scope={Pub:main} syscallnr=61
[Y] Store OPAR[657]: name=$result TypIndex=5 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=209
[D] PAR[846]: function=cosh name=$result type=float order=0 const=no ref=yes
[Y] Store OPAR[658]: name=x TypIndex=5 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=209
[D] PAR[847]: function=cosh name=x type=float order=1 const=no ref=no
[I] FUN: name=standard.cosh(float) index=354 searchindex=154, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.cosh($cvflo) index=354 searchindex=18, scope={Pub:main}, scope={Pub:main}
[D] FID[354]: name=cosh kind=3 fullname=standard.cosh(float) id=standard_cosh
[Y] Update OFUN[209]: ParmNr=2 ParmLow=657 ParmHigh=658
[A] DECL: (standard_cosh)                     DECLARE {REF FLOAT $result,FLOAT x} AS SCALL(61) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):361:43: "syscall<tanh>           float tanh(float x)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(tanh) op(>) ty(float) id(tanh) pu(() ty(float) id(x) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<tanh>           float tanh(float x)
[Y] Store OFUN[210]: name=tanh Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=5 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=62 InstCode=-1 DlName= DlFunction=
[D] FUN[355]: name=tanh kind=SysCall returns=float void=no nested=no scope={Pub:main} syscallnr=62
[Y] Store OPAR[659]: name=$result TypIndex=5 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=210
[D] PAR[848]: function=tanh name=$result type=float order=0 const=no ref=yes
[Y] Store OPAR[660]: name=x TypIndex=5 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=210
[D] PAR[849]: function=tanh name=x type=float order=1 const=no ref=no
[I] FUN: name=standard.tanh(float) index=355 searchindex=254, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.tanh($cvflo) index=355 searchindex=91, scope={Pub:main}, scope={Pub:main}
[D] FID[355]: name=tanh kind=3 fullname=standard.tanh(float) id=standard_tanh
[Y] Update OFUN[210]: ParmNr=2 ParmLow=659 ParmHigh=660
[A] DECL: (standard_tanh)                     DECLARE {REF FLOAT $result,FLOAT x} AS SCALL(62) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):362:44: "syscall<asinh>          float asinh(float x)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(asinh) op(>) ty(float) id(asinh) pu(() ty(float) id(x) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<asinh>          float asinh(float x)
[Y] Store OFUN[211]: name=asinh Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=5 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=63 InstCode=-1 DlName= DlFunction=
[D] FUN[356]: name=asinh kind=SysCall returns=float void=no nested=no scope={Pub:main} syscallnr=63
[Y] Store OPAR[661]: name=$result TypIndex=5 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=211
[D] PAR[850]: function=asinh name=$result type=float order=0 const=no ref=yes
[Y] Store OPAR[662]: name=x TypIndex=5 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=211
[D] PAR[851]: function=asinh name=x type=float order=1 const=no ref=no
[I] FUN: name=standard.asinh(float) index=356 searchindex=150, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.asinh($cvflo) index=356 searchindex=14, scope={Pub:main}, scope={Pub:main}
[D] FID[356]: name=asinh kind=3 fullname=standard.asinh(float) id=standard_asinh
[Y] Update OFUN[211]: ParmNr=2 ParmLow=661 ParmHigh=662
[A] DECL: (standard_asinh)                    DECLARE {REF FLOAT $result,FLOAT x} AS SCALL(63) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):363:44: "syscall<acosh>          float acosh(float x)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(acosh) op(>) ty(float) id(acosh) pu(() ty(float) id(x) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<acosh>          float acosh(float x)
[Y] Store OFUN[212]: name=acosh Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=5 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=64 InstCode=-1 DlName= DlFunction=
[D] FUN[357]: name=acosh kind=SysCall returns=float void=no nested=no scope={Pub:main} syscallnr=64
[Y] Store OPAR[663]: name=$result TypIndex=5 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=212
[D] PAR[852]: function=acosh name=$result type=float order=0 const=no ref=yes
[Y] Store OPAR[664]: name=x TypIndex=5 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=212
[D] PAR[853]: function=acosh name=x type=float order=1 const=no ref=no
[I] FUN: name=standard.acosh(float) index=357 searchindex=148, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.acosh($cvflo) index=357 searchindex=13, scope={Pub:main}, scope={Pub:main}
[D] FID[357]: name=acosh kind=3 fullname=standard.acosh(float) id=standard_acosh
[Y] Update OFUN[212]: ParmNr=2 ParmLow=663 ParmHigh=664
[A] DECL: (standard_acosh)                    DECLARE {REF FLOAT $result,FLOAT x} AS SCALL(64) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):364:44: "syscall<atanh>          float atanh(float x)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(atanh) op(>) ty(float) id(atanh) pu(() ty(float) id(x) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<atanh>          float atanh(float x)
[Y] Store OFUN[213]: name=atanh Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=5 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=65 InstCode=-1 DlName= DlFunction=
[D] FUN[358]: name=atanh kind=SysCall returns=float void=no nested=no scope={Pub:main} syscallnr=65
[Y] Store OPAR[665]: name=$result TypIndex=5 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=213
[D] PAR[854]: function=atanh name=$result type=float order=0 const=no ref=yes
[Y] Store OPAR[666]: name=x TypIndex=5 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=213
[D] PAR[855]: function=atanh name=x type=float order=1 const=no ref=no
[I] FUN: name=standard.atanh(float) index=358 searchindex=153, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.atanh($cvflo) index=358 searchindex=17, scope={Pub:main}, scope={Pub:main}
[D] FID[358]: name=atanh kind=3 fullname=standard.atanh(float) id=standard_atanh
[Y] Update OFUN[213]: ParmNr=2 ParmLow=665 ParmHigh=666
[A] DECL: (standard_atanh)                    DECLARE {REF FLOAT $result,FLOAT x} AS SCALL(65) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):365:42: "syscall<ceil>           long ceil(float x)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(ceil) op(>) ty(long) id(ceil) pu(() ty(float) id(x) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<ceil>           long ceil(float x)
[Y] Store OFUN[214]: name=ceil Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=4 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=66 InstCode=-1 DlName= DlFunction=
[D] FUN[359]: name=ceil kind=SysCall returns=long void=no nested=no scope={Pub:main} syscallnr=66
[Y] Store OPAR[667]: name=$result TypIndex=4 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=214
[D] PAR[856]: function=ceil name=$result type=long order=0 const=no ref=yes
[Y] Store OPAR[668]: name=x TypIndex=5 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=214
[D] PAR[857]: function=ceil name=x type=float order=1 const=no ref=no
[I] FUN: name=standard.ceil(float) index=359 searchindex=155, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.ceil($cvflo) index=359 searchindex=19, scope={Pub:main}, scope={Pub:main}
[D] FID[359]: name=ceil kind=3 fullname=standard.ceil(float) id=standard_ceil
[Y] Update OFUN[214]: ParmNr=2 ParmLow=667 ParmHigh=668
[A] DECL: (standard_ceil)                     DECLARE {REF LONG $result,FLOAT x} AS SCALL(66) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):366:43: "syscall<floor>          long floor(float x)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(floor) op(>) ty(long) id(floor) pu(() ty(float) id(x) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<floor>          long floor(float x)
[Y] Store OFUN[215]: name=floor Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=4 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=67 InstCode=-1 DlName= DlFunction=
[D] FUN[360]: name=floor kind=SysCall returns=long void=no nested=no scope={Pub:main} syscallnr=67
[Y] Store OPAR[669]: name=$result TypIndex=4 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=215
[D] PAR[858]: function=floor name=$result type=long order=0 const=no ref=yes
[Y] Store OPAR[670]: name=x TypIndex=5 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=215
[D] PAR[859]: function=floor name=x type=float order=1 const=no ref=no
[I] FUN: name=standard.floor(float) index=360 searchindex=210, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.floor($cvflo) index=360 searchindex=53, scope={Pub:main}, scope={Pub:main}
[D] FID[360]: name=floor kind=3 fullname=standard.floor(float) id=standard_floor
[Y] Update OFUN[215]: ParmNr=2 ParmLow=669 ParmHigh=670
[A] DECL: (standard_floor)                    DECLARE {REF LONG $result,FLOAT x} AS SCALL(67) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):367:61: "syscall<round>          long round(float number,int decimals)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(round) op(>) ty(long) id(round) pu(() ty(float) id(number) pu(,) ty(int) id(decimals) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<round>          long round(float number,int decimals)
[Y] Store OFUN[216]: name=round Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=4 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=68 InstCode=-1 DlName= DlFunction=
[D] FUN[361]: name=round kind=SysCall returns=long void=no nested=no scope={Pub:main} syscallnr=68
[Y] Store OPAR[671]: name=$result TypIndex=4 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=216
[D] PAR[860]: function=round name=$result type=long order=0 const=no ref=yes
[Y] Store OPAR[672]: name=number TypIndex=5 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=216
[D] PAR[861]: function=round name=number type=float order=1 const=no ref=no
[Y] Store OPAR[673]: name=decimals TypIndex=3 IsConst=0 IsReference=0 ParmOrder=2 FunIndex=216
[D] PAR[862]: function=round name=decimals type=int order=2 const=no ref=no
[I] FUN: name=standard.round(float,int) index=361 searchindex=255, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.round($cvflo,$cvint) index=361 searchindex=92, scope={Pub:main}, scope={Pub:main}
[D] FID[361]: name=round kind=3 fullname=standard.round(float,int) id=standard_round
[Y] Update OFUN[216]: ParmNr=3 ParmLow=671 ParmHigh=673
[A] DECL: (standard_round)                    DECLARE {REF LONG $result,FLOAT number,INTEGER decimals} AS SCALL(68) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):368:47: "syscall<seed>           void seed(float number)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(seed) op(>) kw(void) id(seed) pu(() ty(float) id(number) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<seed>           void seed(float number)
[Y] Store OFUN[217]: name=seed Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=-1 IsVoid=1 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=69 InstCode=-1 DlName= DlFunction=
[D] FUN[362]: name=seed kind=SysCall returns=undefined void=yes nested=no scope={Pub:main} syscallnr=69
[Y] Store OPAR[674]: name=number TypIndex=5 IsConst=0 IsReference=0 ParmOrder=0 FunIndex=217
[D] PAR[863]: function=seed name=number type=float order=0 const=no ref=no
[I] FUN: name=standard.seed(float) index=362 searchindex=256, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.seed($cvflo) index=362 searchindex=93, scope={Pub:main}, scope={Pub:main}
[D] FID[362]: name=seed kind=3 fullname=standard.seed(float) id=standard_seed
[Y] Update OFUN[217]: ParmNr=1 ParmLow=674 ParmHigh=674
[A] DECL: (standard_seed)                     DECLARE {FLOAT number} AS SCALL(69) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):369:36: "syscall<rand>           float rand()"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(rand) op(>) ty(float) id(rand) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<rand>           float rand()
[Y] Store OFUN[218]: name=rand Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=5 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=70 InstCode=-1 DlName= DlFunction=
[D] FUN[363]: name=rand kind=SysCall returns=float void=no nested=no scope={Pub:main} syscallnr=70
[Y] Store OPAR[675]: name=$result TypIndex=5 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=218
[D] PAR[864]: function=rand name=$result type=float order=0 const=no ref=yes
[I] FUN: name=standard.rand() index=363 searchindex=248, scope={Pub:main}, scope={Pub:main}
[D] FID[363]: name=rand kind=3 fullname=standard.rand() id=standard_rand
[Y] Update OFUN[218]: ParmNr=1 ParmLow=675 ParmHigh=675
[A] DECL: (standard_rand)                     DECLARE {REF FLOAT $result} AS SCALL(70) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):372:49: "syscall<delay>          void delay(int millisecs)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(delay) op(>) kw(void) id(delay) pu(() ty(int) id(millisecs) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<delay>          void delay(int millisecs)
[Y] Store OFUN[219]: name=delay Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=-1 IsVoid=1 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=1 InstCode=-1 DlName= DlFunction=
[D] FUN[364]: name=delay kind=SysCall returns=undefined void=yes nested=no scope={Pub:main} syscallnr=1
[Y] Store OPAR[676]: name=millisecs TypIndex=3 IsConst=0 IsReference=0 ParmOrder=0 FunIndex=219
[D] PAR[865]: function=delay name=millisecs type=int order=0 const=no ref=no
[I] FUN: name=standard.delay(int) index=364 searchindex=205, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.delay($cvint) index=364 searchindex=49, scope={Pub:main}, scope={Pub:main}
[D] FID[364]: name=delay kind=3 fullname=standard.delay(int) id=standard_delay
[Y] Update OFUN[219]: ParmNr=1 ParmLow=676 ParmHigh=676
[A] DECL: (standard_delay)                    DECLARE {INTEGER millisecs} AS SCALL(1) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):373:41: "syscall<error>          errorcode error()"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(error) op(>) ty(errorcode) id(error) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<error>          errorcode error()
[Y] Store OFUN[220]: name=error Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=12 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=4 InstCode=-1 DlName= DlFunction=
[D] FUN[365]: name=error kind=SysCall returns=errorcode void=no nested=no scope={Pub:main} syscallnr=4
[Y] Store OPAR[677]: name=$result TypIndex=12 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=220
[D] PAR[866]: function=error name=$result type=errorcode order=0 const=no ref=yes
[I] FUN: name=standard.error() index=365 searchindex=208, scope={Pub:main}, scope={Pub:main}
[D] FID[365]: name=error kind=3 fullname=standard.error() id=standard_error
[Y] Update OFUN[220]: ParmNr=1 ParmLow=677 ParmHigh=677
[A] DECL: (standard_error)                    DECLARE {REF INTEGER $result} AS SCALL(4) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):374:56: "syscall<errortext>      string errortext(errorcode code)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(errortext) op(>) ty(string) id(errortext) pu(() ty(errorcode) id(code) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<errortext>      string errortext(errorcode code)
[Y] Store OFUN[221]: name=errortext Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=6 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=5 InstCode=-1 DlName= DlFunction=
[D] FUN[366]: name=errortext kind=SysCall returns=string void=no nested=no scope={Pub:main} syscallnr=5
[Y] Store OPAR[678]: name=$result TypIndex=6 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=221
[D] PAR[867]: function=errortext name=$result type=string order=0 const=no ref=yes
[Y] Store OPAR[679]: name=code TypIndex=12 IsConst=0 IsReference=0 ParmOrder=1 FunIndex=221
[D] PAR[868]: function=errortext name=code type=errorcode order=1 const=no ref=no
[I] FUN: name=standard.errortext(errorcode) index=366 searchindex=209, scope={Pub:main}, scope={Pub:main}
[D] FID[366]: name=errortext kind=3 fullname=standard.errortext(errorcode) id=standard_errortext
[Y] Update OFUN[221]: ParmNr=2 ParmLow=678 ParmHigh=679
[A] DECL: (standard_errortext)                DECLARE {REF STRINGBLOCK $result,INTEGER code} AS SCALL(5) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):375:42: "syscall<lasterror>      string lasterror()"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(lasterror) op(>) ty(string) id(lasterror) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<lasterror>      string lasterror()
[Y] Store OFUN[222]: name=lasterror Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=6 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=6 InstCode=-1 DlName= DlFunction=
[D] FUN[367]: name=lasterror kind=SysCall returns=string void=no nested=no scope={Pub:main} syscallnr=6
[Y] Store OPAR[680]: name=$result TypIndex=6 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=222
[D] PAR[869]: function=lasterror name=$result type=string order=0 const=no ref=yes
[I] FUN: name=standard.lasterror() index=367 searchindex=231, scope={Pub:main}, scope={Pub:main}
[D] FID[367]: name=lasterror kind=3 fullname=standard.lasterror() id=standard_lasterror
[Y] Update OFUN[222]: ParmNr=1 ParmLow=680 ParmHigh=680
[A] DECL: (standard_lasterror)                DECLARE {REF STRINGBLOCK $result} AS SCALL(6) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):376:118: "syscall<execute1>       bool execute(string execfile,string arg,ref string[] stdout,ref string[] stderr,bool redirect)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(execute1) op(>) ty(bool) id(execute) pu(() ty(string) id(execfile) pu(,) ty(string) id(arg) pu(,) kw(ref) ty(string) pu([) pu(]) id(stdout) pu(,) kw(ref) ty(string) pu([) pu(]) id(stderr) pu(,) ty(bool) id(redirect) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<execute1>       bool execute(string execfile,string arg,ref string[] stdout,ref string[] stderr,bool redirect)
[Y] Store OFUN[223]: name=execute Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=2 InstCode=-1 DlName= DlFunction=
[D] FUN[368]: name=execute kind=SysCall returns=bool void=no nested=no scope={Pub:main} syscallnr=2
[Y] Store OPAR[681]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=223
[D] PAR[870]: function=execute name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[682]: name=execfile TypIndex=6 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=223
[D] PAR[871]: function=execute name=execfile type=string order=1 const=yes ref=yes
[Y] Store OPAR[683]: name=arg TypIndex=6 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=223
[D] PAR[872]: function=execute name=arg type=string order=2 const=yes ref=yes
[Y] Store OPAR[684]: name=stdout TypIndex=8 IsConst=0 IsReference=1 ParmOrder=3 FunIndex=223
[D] PAR[873]: function=execute name=stdout type=string[] order=3 const=no ref=yes
[Y] Store OPAR[685]: name=stderr TypIndex=8 IsConst=0 IsReference=1 ParmOrder=4 FunIndex=223
[D] PAR[874]: function=execute name=stderr type=string[] order=4 const=no ref=yes
[Y] Store OPAR[686]: name=redirect TypIndex=0 IsConst=0 IsReference=0 ParmOrder=5 FunIndex=223
[D] PAR[875]: function=execute name=redirect type=bool order=5 const=no ref=no
[I] FUN: name=standard.execute(string,string,string[],string[],bool) index=368 searchindex=210, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.execute($cvstr,$cvstr,string[],string[],bool) index=368 searchindex=52, scope={Pub:main}, scope={Pub:main}
[D] FID[368]: name=execute kind=3 fullname=standard.execute(string,string,string[],string[],bool) id=standard_execute
[Y] Update OFUN[223]: ParmNr=6 ParmLow=681 ParmHigh=686
[A] DECL: (standard_execute)                  DECLARE {REF BOOLEAN $result,CONST REF STRINGBLOCK execfile,CONST REF STRINGBLOCK arg,REF ARRAYBLOCK stdout,REF ARRAYBLOCK stderr,BOOLEAN redirect} AS SCALL(2) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):377:104: "                        bool execute(string execfile,string arg,ref string[] stdout,ref string[] stderr)"
[P] Parsed sentence: [FunDecl] ty(bool) id(execute) pu(() ty(string) id(execfile) pu(,) ty(string) id(arg) pu(,) kw(ref) ty(string) pu([) pu(]) id(stdout) pu(,) kw(ref) ty(string) pu([) pu(]) id(stderr) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;bool execute(string execfile,string arg,ref string[] stdout,ref string[] stderr)
[Y] Store OFUN[224]: name=execute Kind=0 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[369]: name=execute kind=Function returns=bool void=no nested=no scope={Pub:main}
[Y] Store OPAR[687]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=224
[D] PAR[876]: function=execute name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[688]: name=execfile TypIndex=6 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=224
[D] PAR[877]: function=execute name=execfile type=string order=1 const=yes ref=yes
[Y] Store OPAR[689]: name=arg TypIndex=6 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=224
[D] PAR[878]: function=execute name=arg type=string order=2 const=yes ref=yes
[Y] Store OPAR[690]: name=stdout TypIndex=8 IsConst=0 IsReference=1 ParmOrder=3 FunIndex=224
[D] PAR[879]: function=execute name=stdout type=string[] order=3 const=no ref=yes
[Y] Store OPAR[691]: name=stderr TypIndex=8 IsConst=0 IsReference=1 ParmOrder=4 FunIndex=224
[D] PAR[880]: function=execute name=stderr type=string[] order=4 const=no ref=yes
[I] FUN: name=standard.execute(string,string,string[],string[]) index=369 searchindex=210, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.execute($cvstr,$cvstr,string[],string[]) index=369 searchindex=52, scope={Pub:main}, scope={Pub:main}
[D] FID[369]: name=execute kind=0 fullname=standard.execute(string,string,string[],string[]) id=standard_execute2
[Y] Update OFUN[224]: ParmNr=5 ParmLow=687 ParmHigh=691
[A] DECL: (standard_execute2)                 DECLARE {REF BOOLEAN $result,CONST REF STRINGBLOCK execfile,CONST REF STRINGBLOCK arg,REF ARRAYBLOCK stdout,REF ARRAYBLOCK stderr} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):378:84: "                        bool execute(string execfile,string arg,ref string[] output)"
[P] Parsed sentence: [FunDecl] ty(bool) id(execute) pu(() ty(string) id(execfile) pu(,) ty(string) id(arg) pu(,) kw(ref) ty(string) pu([) pu(]) id(output) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;bool execute(string execfile,string arg,ref string[] output)
[Y] Store OFUN[225]: name=execute Kind=0 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[370]: name=execute kind=Function returns=bool void=no nested=no scope={Pub:main}
[Y] Store OPAR[692]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=225
[D] PAR[881]: function=execute name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[693]: name=execfile TypIndex=6 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=225
[D] PAR[882]: function=execute name=execfile type=string order=1 const=yes ref=yes
[Y] Store OPAR[694]: name=arg TypIndex=6 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=225
[D] PAR[883]: function=execute name=arg type=string order=2 const=yes ref=yes
[Y] Store OPAR[695]: name=output TypIndex=8 IsConst=0 IsReference=1 ParmOrder=3 FunIndex=225
[D] PAR[884]: function=execute name=output type=string[] order=3 const=no ref=yes
[I] FUN: name=standard.execute(string,string,string[]) index=370 searchindex=210, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.execute($cvstr,$cvstr,string[]) index=370 searchindex=52, scope={Pub:main}, scope={Pub:main}
[D] FID[370]: name=execute kind=0 fullname=standard.execute(string,string,string[]) id=standard_execute3
[Y] Update OFUN[225]: ParmNr=4 ParmLow=692 ParmHigh=695
[A] DECL: (standard_execute3)                 DECLARE {REF BOOLEAN $result,CONST REF STRINGBLOCK execfile,CONST REF STRINGBLOCK arg,REF ARRAYBLOCK output} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):379:120: "syscall<execute2>       bool execute(string execfile,string[] arg,ref string[] stdout,ref string[] stderr,bool redirect)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(execute2) op(>) ty(bool) id(execute) pu(() ty(string) id(execfile) pu(,) ty(string) pu([) pu(]) id(arg) pu(,) kw(ref) ty(string) pu([) pu(]) id(stdout) pu(,) kw(ref) ty(string) pu([) pu(]) id(stderr) pu(,) ty(bool) id(redirect) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<execute2>       bool execute(string execfile,string[] arg,ref string[] stdout,ref string[] stderr,bool redirect)
[Y] Store OFUN[226]: name=execute Kind=3 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=3 InstCode=-1 DlName= DlFunction=
[D] FUN[371]: name=execute kind=SysCall returns=bool void=no nested=no scope={Pub:main} syscallnr=3
[Y] Store OPAR[696]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=226
[D] PAR[885]: function=execute name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[697]: name=execfile TypIndex=6 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=226
[D] PAR[886]: function=execute name=execfile type=string order=1 const=yes ref=yes
[Y] Store OPAR[698]: name=arg TypIndex=8 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=226
[D] PAR[887]: function=execute name=arg type=string[] order=2 const=yes ref=yes
[Y] Store OPAR[699]: name=stdout TypIndex=8 IsConst=0 IsReference=1 ParmOrder=3 FunIndex=226
[D] PAR[888]: function=execute name=stdout type=string[] order=3 const=no ref=yes
[Y] Store OPAR[700]: name=stderr TypIndex=8 IsConst=0 IsReference=1 ParmOrder=4 FunIndex=226
[D] PAR[889]: function=execute name=stderr type=string[] order=4 const=no ref=yes
[Y] Store OPAR[701]: name=redirect TypIndex=0 IsConst=0 IsReference=0 ParmOrder=5 FunIndex=226
[D] PAR[890]: function=execute name=redirect type=bool order=5 const=no ref=no
[I] FUN: name=standard.execute(string,string[],string[],string[],bool) index=371 searchindex=213, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.execute($cvstr,string[],string[],string[],bool) index=371 searchindex=55, scope={Pub:main}, scope={Pub:main}
[D] FID[371]: name=execute kind=3 fullname=standard.execute(string,string[],string[],string[],bool) id=standard_execute4
[Y] Update OFUN[226]: ParmNr=6 ParmLow=696 ParmHigh=701
[A] DECL: (standard_execute4)                 DECLARE {REF BOOLEAN $result,CONST REF STRINGBLOCK execfile,CONST REF ARRAYBLOCK arg,REF ARRAYBLOCK stdout,REF ARRAYBLOCK stderr,BOOLEAN redirect} AS SCALL(3) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):380:106: "                        bool execute(string execfile,string[] arg,ref string[] stdout,ref string[] stderr)"
[P] Parsed sentence: [FunDecl] ty(bool) id(execute) pu(() ty(string) id(execfile) pu(,) ty(string) pu([) pu(]) id(arg) pu(,) kw(ref) ty(string) pu([) pu(]) id(stdout) pu(,) kw(ref) ty(string) pu([) pu(]) id(stderr) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;bool execute(string execfile,string[] arg,ref string[] stdout,ref string[] stderr)
[Y] Store OFUN[227]: name=execute Kind=0 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[372]: name=execute kind=Function returns=bool void=no nested=no scope={Pub:main}
[Y] Store OPAR[702]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=227
[D] PAR[891]: function=execute name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[703]: name=execfile TypIndex=6 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=227
[D] PAR[892]: function=execute name=execfile type=string order=1 const=yes ref=yes
[Y] Store OPAR[704]: name=arg TypIndex=8 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=227
[D] PAR[893]: function=execute name=arg type=string[] order=2 const=yes ref=yes
[Y] Store OPAR[705]: name=stdout TypIndex=8 IsConst=0 IsReference=1 ParmOrder=3 FunIndex=227
[D] PAR[894]: function=execute name=stdout type=string[] order=3 const=no ref=yes
[Y] Store OPAR[706]: name=stderr TypIndex=8 IsConst=0 IsReference=1 ParmOrder=4 FunIndex=227
[D] PAR[895]: function=execute name=stderr type=string[] order=4 const=no ref=yes
[I] FUN: name=standard.execute(string,string[],string[],string[]) index=372 searchindex=213, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.execute($cvstr,string[],string[],string[]) index=372 searchindex=55, scope={Pub:main}, scope={Pub:main}
[D] FID[372]: name=execute kind=0 fullname=standard.execute(string,string[],string[],string[]) id=standard_execute5
[Y] Update OFUN[227]: ParmNr=5 ParmLow=702 ParmHigh=706
[A] DECL: (standard_execute5)                 DECLARE {REF BOOLEAN $result,CONST REF STRINGBLOCK execfile,CONST REF ARRAYBLOCK arg,REF ARRAYBLOCK stdout,REF ARRAYBLOCK stderr} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):381:86: "                        bool execute(string execfile,string[] arg,ref string[] output)"
[P] Parsed sentence: [FunDecl] ty(bool) id(execute) pu(() ty(string) id(execfile) pu(,) ty(string) pu([) pu(]) id(arg) pu(,) kw(ref) ty(string) pu([) pu(]) id(output) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;bool execute(string execfile,string[] arg,ref string[] output)
[Y] Store OFUN[228]: name=execute Kind=0 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=0 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[373]: name=execute kind=Function returns=bool void=no nested=no scope={Pub:main}
[Y] Store OPAR[707]: name=$result TypIndex=0 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=228
[D] PAR[896]: function=execute name=$result type=bool order=0 const=no ref=yes
[Y] Store OPAR[708]: name=execfile TypIndex=6 IsConst=1 IsReference=1 ParmOrder=1 FunIndex=228
[D] PAR[897]: function=execute name=execfile type=string order=1 const=yes ref=yes
[Y] Store OPAR[709]: name=arg TypIndex=8 IsConst=1 IsReference=1 ParmOrder=2 FunIndex=228
[D] PAR[898]: function=execute name=arg type=string[] order=2 const=yes ref=yes
[Y] Store OPAR[710]: name=output TypIndex=8 IsConst=0 IsReference=1 ParmOrder=3 FunIndex=228
[D] PAR[899]: function=execute name=output type=string[] order=3 const=no ref=yes
[I] FUN: name=standard.execute(string,string[],string[]) index=373 searchindex=213, scope={Pub:main}, scope={Pub:main}
[I] FNC: name=standard.execute($cvstr,string[],string[]) index=373 searchindex=55, scope={Pub:main}, scope={Pub:main}
[D] FID[373]: name=execute kind=0 fullname=standard.execute(string,string[],string[]) id=standard_execute6
[Y] Update OFUN[228]: ParmNr=4 ParmLow=707 ParmHigh=710
[A] DECL: (standard_execute6)                 DECLARE {REF BOOLEAN $result,CONST REF STRINGBLOCK execfile,CONST REF ARRAYBLOCK arg,REF ARRAYBLOCK output} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):384:23: "hostsys gethostsystem()"
[P] Parsed sentence: [FunDecl] ty(hostsys) id(gethostsystem) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;hostsys gethostsystem()
[Y] Store OFUN[229]: name=gethostsystem Kind=0 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=10 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[374]: name=gethostsystem kind=Function returns=hostsys void=no nested=no scope={Pub:main}
[Y] Store OPAR[711]: name=$result TypIndex=10 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=229
[D] PAR[900]: function=gethostsystem name=$result type=hostsys order=0 const=no ref=yes
[I] FUN: name=standard.gethostsystem() index=374 searchindex=227, scope={Pub:main}, scope={Pub:main}
[D] FID[374]: name=gethostsystem kind=0 fullname=standard.gethostsystem() id=standard_gethostsystem
[Y] Update OFUN[229]: ParmNr=1 ParmLow=711 ParmHigh=711
[A] DECL: (standard_gethostsystem)            DECLARE {REF INTEGER $result} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):385:26: "string gethostsystemname()"
[P] Parsed sentence: [FunDecl] ty(string) id(gethostsystemname) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;string gethostsystemname()
[Y] Store OFUN[230]: name=gethostsystemname Kind=0 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=6 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[375]: name=gethostsystemname kind=Function returns=string void=no nested=no scope={Pub:main}
[Y] Store OPAR[712]: name=$result TypIndex=6 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=230
[D] PAR[901]: function=gethostsystemname name=$result type=string order=0 const=no ref=yes
[I] FUN: name=standard.gethostsystemname() index=375 searchindex=228, scope={Pub:main}, scope={Pub:main}
[D] FID[375]: name=gethostsystemname kind=0 fullname=standard.gethostsystemname() id=standard_gethostsystemname
[Y] Update OFUN[230]: ParmNr=1 ParmLow=712 ParmHigh=712
[A] DECL: (standard_gethostsystemname)        DECLARE {REF STRINGBLOCK $result} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):386:21: "int getarchitecture()"
[P] Parsed sentence: [FunDecl] ty(int) id(getarchitecture) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;int getarchitecture()
[Y] Store OFUN[231]: name=getarchitecture Kind=0 SupTypIndex=-1 SubScope=0 Address=0 TypIndex=3 IsVoid=0 ParmNr=0 ParmLow=-1 ParmHigh=-1 MstType=-1 MstMethod=-1 SysCallNr=-1 InstCode=-1 DlName= DlFunction=
[D] FUN[376]: name=getarchitecture kind=Function returns=int void=no nested=no scope={Pub:main}
[Y] Store OPAR[713]: name=$result TypIndex=3 IsConst=0 IsReference=1 ParmOrder=0 FunIndex=231
[D] PAR[902]: function=getarchitecture name=$result type=int order=0 const=no ref=yes
[I] FUN: name=standard.getarchitecture() index=376 searchindex=221, scope={Pub:main}, scope={Pub:main}
[D] FID[376]: name=getarchitecture kind=0 fullname=standard.getarchitecture() id=standard_getarchitecture
[Y] Update OFUN[231]: ParmNr=1 ParmLow=713 ParmHigh=713
[A] DECL: (standard_getarchitecture)          DECLARE {REF INTEGER $result} 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):389:8: ".private"
[P] Parsed sentence: [Private] kw(.private)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[S] Scope open: {Pri:main}
[S] Current scope: {Pri:main}, StackLength=2
[P] -------------------------------------------------------------------------------------
[L] Read line (src):392:12: "enum dtpart:"
[P] Parsed sentence: [DefEnum] kw(enum) id(dtpart) pu(:)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[O] Relocation added: Type=BlkInsideGlo, LocAdr=00000000000000E8h
[A] DATA:                                     STORE "dtpart"                                                  ;Address=[00000000000000E8h]
[D] TYP[17]: name=dtpart msttype=enum scope={Pri:main} typedef=no systemdef=no length=4
[I] TYP: name=standard.dtpart index=17 searchindex=0, scope={Pri:main}
[S] Subscope begin: {Pub:dtpart}
[P] Updated parser type list: dtpart,bool,char,date,datetime,errorcode,filemode,float,hostsys,int,long,short,string,time,timespan,word
[P] -------------------------------------------------------------------------------------
[L] Read line (src):393:8: "  year=1"
[P] Parsed sentence: [EnumField] id(year) op(=) ch(1R)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[E] ExprComputer input: [EnumField] ch(1R)
[E] Tokenizer ouput: {K}1C
[E] RPN ouput: {K}1C
[E] Token {K}1C --> Operand stack {{K}1C}
[E] Result token: {K}1C
[D] FLD[25]: type=int name=year subscope={Pub:dtpart} offset=0 static=no enumvalue=1
[P] -------------------------------------------------------------------------------------
[L] Read line (src):394:9: "  month=2"
[P] Parsed sentence: [EnumField] id(month) op(=) ch(2R)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[E] ExprComputer input: [EnumField] ch(2R)
[E] Tokenizer ouput: {K}2C
[E] RPN ouput: {K}2C
[E] Token {K}2C --> Operand stack {{K}2C}
[E] Result token: {K}2C
[D] FLD[26]: type=int name=month subscope={Pub:dtpart} offset=4 static=no enumvalue=2
[P] -------------------------------------------------------------------------------------
[L] Read line (src):395:7: "  day=3"
[P] Parsed sentence: [EnumField] id(day) op(=) ch(3R)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[E] ExprComputer input: [EnumField] ch(3R)
[E] Tokenizer ouput: {K}3C
[E] RPN ouput: {K}3C
[E] Token {K}3C --> Operand stack {{K}3C}
[E] Result token: {K}3C
[D] FLD[27]: type=int name=day subscope={Pub:dtpart} offset=8 static=no enumvalue=3
[P] -------------------------------------------------------------------------------------
[L] Read line (src):396:5: ":enum"
[P] Parsed sentence: [EndEnum] kw(:enum)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000000h, LocBlk=00000060h
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000004h, LocBlk=00000060h
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000008h, LocBlk=00000060h
[O] Relocation added: Type=BlkInsideGlo, LocAdr=00000000000000ECh
[A] DATA:                                     STORE {"year"                                                   ;Address=[00000000000000ECh]
[A] DATA:                                     STORE  "month",
[A] DATA:                                     STORE  "day"}
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000000h, LocBlk=00000064h
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000004h, LocBlk=00000064h
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000008h, LocBlk=00000064h
[O] Relocation added: Type=BlkInsideGlo, LocAdr=00000000000000F0h
[A] DATA:                                     STORE {"int"                                                    ;Address=[00000000000000F0h]
[A] DATA:                                     STORE  "int",
[A] DATA:                                     STORE  "int"}
[S] Subscope end: {Pub:dtpart}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):399:12: "enum tmpart:"
[P] Parsed sentence: [DefEnum] kw(enum) id(tmpart) pu(:)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[O] Relocation added: Type=BlkInsideGlo, LocAdr=00000000000000F4h
[A] DATA:                                     STORE "tmpart"                                                  ;Address=[00000000000000F4h]
[D] TYP[18]: name=tmpart msttype=enum scope={Pri:main} typedef=no systemdef=no length=4
[I] TYP: name=standard.tmpart index=18 searchindex=1, scope={Pri:main}
[S] Subscope begin: {Pub:tmpart}
[P] Updated parser type list: dtpart,tmpart,bool,char,date,datetime,errorcode,filemode,float,hostsys,int,long,short,string,time,timespan,word
[P] -------------------------------------------------------------------------------------
[L] Read line (src):400:8: "  hour=1"
[P] Parsed sentence: [EnumField] id(hour) op(=) ch(1R)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[E] ExprComputer input: [EnumField] ch(1R)
[E] Tokenizer ouput: {K}1C
[E] RPN ouput: {K}1C
[E] Token {K}1C --> Operand stack {{K}1C}
[E] Result token: {K}1C
[D] FLD[28]: type=int name=hour subscope={Pub:tmpart} offset=0 static=no enumvalue=1
[P] -------------------------------------------------------------------------------------
[L] Read line (src):401:10: "  minute=2"
[P] Parsed sentence: [EnumField] id(minute) op(=) ch(2R)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[E] ExprComputer input: [EnumField] ch(2R)
[E] Tokenizer ouput: {K}2C
[E] RPN ouput: {K}2C
[E] Token {K}2C --> Operand stack {{K}2C}
[E] Result token: {K}2C
[D] FLD[29]: type=int name=minute subscope={Pub:tmpart} offset=4 static=no enumvalue=2
[P] -------------------------------------------------------------------------------------
[L] Read line (src):402:10: "  second=3"
[P] Parsed sentence: [EnumField] id(second) op(=) ch(3R)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[E] ExprComputer input: [EnumField] ch(3R)
[E] Tokenizer ouput: {K}3C
[E] RPN ouput: {K}3C
[E] Token {K}3C --> Operand stack {{K}3C}
[E] Result token: {K}3C
[D] FLD[30]: type=int name=second subscope={Pub:tmpart} offset=8 static=no enumvalue=3
[P] -------------------------------------------------------------------------------------
[L] Read line (src):403:11: "  nanosec=4"
[P] Parsed sentence: [EnumField] id(nanosec) op(=) ch(4R)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[E] ExprComputer input: [EnumField] ch(4R)
[E] Tokenizer ouput: {K}4C
[E] RPN ouput: {K}4C
[E] Token {K}4C --> Operand stack {{K}4C}
[E] Result token: {K}4C
[D] FLD[31]: type=int name=nanosec subscope={Pub:tmpart} offset=12 static=no enumvalue=4
[P] -------------------------------------------------------------------------------------
[L] Read line (src):404:5: ":enum"
[P] Parsed sentence: [EndEnum] kw(:enum)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000000h, LocBlk=0000006Ah
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000004h, LocBlk=0000006Ah
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000008h, LocBlk=0000006Ah
[O] Relocation added: Type=BlkInsideBlk, LocAdr=000000000000000Ch, LocBlk=0000006Ah
[O] Relocation added: Type=BlkInsideGlo, LocAdr=00000000000000F8h
[A] DATA:                                     STORE {"hour"                                                   ;Address=[00000000000000F8h]
[A] DATA:                                     STORE  "minute",
[A] DATA:                                     STORE  "second",
[A] DATA:                                     STORE  "nanosec"}
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000000h, LocBlk=0000006Fh
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000004h, LocBlk=0000006Fh
[O] Relocation added: Type=BlkInsideBlk, LocAdr=0000000000000008h, LocBlk=0000006Fh
[O] Relocation added: Type=BlkInsideBlk, LocAdr=000000000000000Ch, LocBlk=0000006Fh
[O] Relocation added: Type=BlkInsideGlo, LocAdr=00000000000000FCh
[A] DATA:                                     STORE {"int"                                                    ;Address=[00000000000000FCh]
[A] DATA:                                     STORE  "int",
[A] DATA:                                     STORE  "int",
[A] DATA:                                     STORE  "int"}
[S] Subscope end: {Pub:tmpart}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):407:63: "syscall<datevalid>  bool _datevalid(int year,int month,int day)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(datevalid) op(>) ty(bool) id(_datevalid) pu(() ty(int) id(year) pu(,) ty(int) id(month) pu(,) ty(int) id(day) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<datevalid>  bool _datevalid(int year,int month,int day)
[D] FUN[377]: name=_datevalid kind=SysCall returns=bool void=no nested=no scope={Pri:main} syscallnr=71
[D] PAR[903]: function=_datevalid name=$result type=bool order=0 const=no ref=yes
[D] PAR[904]: function=_datevalid name=year type=int order=1 const=no ref=no
[D] PAR[905]: function=_datevalid name=month type=int order=2 const=no ref=no
[D] PAR[906]: function=_datevalid name=day type=int order=3 const=no ref=no
[I] FUN: name=standard._datevalid(int,int,int) index=377 searchindex=0, scope={Pri:main}, scope={Pri:main}
[I] FNC: name=standard._datevalid($cvint,$cvint,$cvint) index=377 searchindex=0, scope={Pri:main}, scope={Pri:main}
[D] FID[377]: name=_datevalid kind=3 fullname=standard._datevalid(int,int,int) id=standard__datevalid
[A] DECL: (standard__datevalid)               DECLARE {REF BOOLEAN $result,INTEGER year,INTEGER month,INTEGER day} AS SCALL(71) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):408:62: "syscall<datevalue>  int _datevalue(int year,int month,int day)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(datevalue) op(>) ty(int) id(_datevalue) pu(() ty(int) id(year) pu(,) ty(int) id(month) pu(,) ty(int) id(day) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<datevalue>  int _datevalue(int year,int month,int day)
[D] FUN[378]: name=_datevalue kind=SysCall returns=int void=no nested=no scope={Pri:main} syscallnr=72
[D] PAR[907]: function=_datevalue name=$result type=int order=0 const=no ref=yes
[D] PAR[908]: function=_datevalue name=year type=int order=1 const=no ref=no
[D] PAR[909]: function=_datevalue name=month type=int order=2 const=no ref=no
[D] PAR[910]: function=_datevalue name=day type=int order=3 const=no ref=no
[I] FUN: name=standard._datevalue(int,int,int) index=378 searchindex=1, scope={Pri:main}, scope={Pri:main}
[I] FNC: name=standard._datevalue($cvint,$cvint,$cvint) index=378 searchindex=1, scope={Pri:main}, scope={Pri:main}
[D] FID[378]: name=_datevalue kind=3 fullname=standard._datevalue(int,int,int) id=standard__datevalue
[A] DECL: (standard__datevalue)               DECLARE {REF INTEGER $result,INTEGER year,INTEGER month,INTEGER day} AS SCALL(72) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):409:43: "syscall<begofmonth> int _begofmonth(int dt)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(begofmonth) op(>) ty(int) id(_begofmonth) pu(() ty(int) id(dt) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<begofmonth> int _begofmonth(int dt)
[D] FUN[379]: name=_begofmonth kind=SysCall returns=int void=no nested=no scope={Pri:main} syscallnr=73
[D] PAR[911]: function=_begofmonth name=$result type=int order=0 const=no ref=yes
[D] PAR[912]: function=_begofmonth name=dt type=int order=1 const=no ref=no
[I] FUN: name=standard._begofmonth(int) index=379 searchindex=0, scope={Pri:main}, scope={Pri:main}
[I] FNC: name=standard._begofmonth($cvint) index=379 searchindex=0, scope={Pri:main}, scope={Pri:main}
[D] FID[379]: name=_begofmonth kind=3 fullname=standard._begofmonth(int) id=standard__begofmonth
[A] DECL: (standard__begofmonth)              DECLARE {REF INTEGER $result,INTEGER dt} AS SCALL(73) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):410:43: "syscall<endofmonth> int _endofmonth(int dt)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(endofmonth) op(>) ty(int) id(_endofmonth) pu(() ty(int) id(dt) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<endofmonth> int _endofmonth(int dt)
[D] FUN[380]: name=_endofmonth kind=SysCall returns=int void=no nested=no scope={Pri:main} syscallnr=74
[D] PAR[913]: function=_endofmonth name=$result type=int order=0 const=no ref=yes
[D] PAR[914]: function=_endofmonth name=dt type=int order=1 const=no ref=no
[I] FUN: name=standard._endofmonth(int) index=380 searchindex=3, scope={Pri:main}, scope={Pri:main}
[I] FNC: name=standard._endofmonth($cvint) index=380 searchindex=3, scope={Pri:main}, scope={Pri:main}
[D] FID[380]: name=_endofmonth kind=3 fullname=standard._endofmonth(int) id=standard__endofmonth
[A] DECL: (standard__endofmonth)              DECLARE {REF INTEGER $result,INTEGER dt} AS SCALL(74) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):411:53: "syscall<datepart>   int _datepart(int dt,dtpart part)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(datepart) op(>) ty(int) id(_datepart) pu(() ty(int) id(dt) pu(,) ty(dtpart) id(part) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<datepart>   int _datepart(int dt,dtpart part)
[D] FUN[381]: name=_datepart kind=SysCall returns=int void=no nested=no scope={Pri:main} syscallnr=75
[D] PAR[915]: function=_datepart name=$result type=int order=0 const=no ref=yes
[D] PAR[916]: function=_datepart name=dt type=int order=1 const=no ref=no
[D] PAR[917]: function=_datepart name=part type=dtpart order=2 const=no ref=no
[I] FUN: name=standard._datepart(int,dtpart) index=381 searchindex=1, scope={Pri:main}, scope={Pri:main}
[I] FNC: name=standard._datepart($cvint,dtpart) index=381 searchindex=1, scope={Pri:main}, scope={Pri:main}
[D] FID[381]: name=_datepart kind=3 fullname=standard._datepart(int,dtpart) id=standard__datepart
[A] DECL: (standard__datepart)                DECLARE {REF INTEGER $result,INTEGER dt,INTEGER part} AS SCALL(75) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):412:62: "syscall<dateadd>    int _dateadd(int dt,dtpart part,int units)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(dateadd) op(>) ty(int) id(_dateadd) pu(() ty(int) id(dt) pu(,) ty(dtpart) id(part) pu(,) ty(int) id(units) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<dateadd>    int _dateadd(int dt,dtpart part,int units)
[D] FUN[382]: name=_dateadd kind=SysCall returns=int void=no nested=no scope={Pri:main} syscallnr=76
[D] PAR[918]: function=_dateadd name=$result type=int order=0 const=no ref=yes
[D] PAR[919]: function=_dateadd name=dt type=int order=1 const=no ref=no
[D] PAR[920]: function=_dateadd name=part type=dtpart order=2 const=no ref=no
[D] PAR[921]: function=_dateadd name=units type=int order=3 const=no ref=no
[I] FUN: name=standard._dateadd(int,dtpart,int) index=382 searchindex=1, scope={Pri:main}, scope={Pri:main}
[I] FNC: name=standard._dateadd($cvint,dtpart,$cvint) index=382 searchindex=1, scope={Pri:main}, scope={Pri:main}
[D] FID[382]: name=_dateadd kind=3 fullname=standard._dateadd(int,dtpart,int) id=standard__dateadd
[A] DECL: (standard__dateadd)                 DECLARE {REF INTEGER $result,INTEGER dt,INTEGER part,INTEGER units} AS SCALL(76) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):413:80: "syscall<timevalid>  bool _timevalid(int hour,int minute,int second,long nanosec)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(timevalid) op(>) ty(bool) id(_timevalid) pu(() ty(int) id(hour) pu(,) ty(int) id(minute) pu(,) ty(int) id(second) pu(,) ty(long) id(nanosec) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<timevalid>  bool _timevalid(int hour,int minute,int second,long nanosec)
[D] FUN[383]: name=_timevalid kind=SysCall returns=bool void=no nested=no scope={Pri:main} syscallnr=77
[D] PAR[922]: function=_timevalid name=$result type=bool order=0 const=no ref=yes
[D] PAR[923]: function=_timevalid name=hour type=int order=1 const=no ref=no
[D] PAR[924]: function=_timevalid name=minute type=int order=2 const=no ref=no
[D] PAR[925]: function=_timevalid name=second type=int order=3 const=no ref=no
[D] PAR[926]: function=_timevalid name=nanosec type=long order=4 const=no ref=no
[I] FUN: name=standard._timevalid(int,int,int,long) index=383 searchindex=6, scope={Pri:main}, scope={Pri:main}
[I] FNC: name=standard._timevalid($cvint,$cvint,$cvint,$cvint) index=383 searchindex=6, scope={Pri:main}, scope={Pri:main}
[D] FID[383]: name=_timevalid kind=3 fullname=standard._timevalid(int,int,int,long) id=standard__timevalid
[A] DECL: (standard__timevalid)               DECLARE {REF BOOLEAN $result,INTEGER hour,INTEGER minute,INTEGER second,LONG nanosec} AS SCALL(77) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):414:80: "syscall<timevalue>  long _timevalue(int hour,int minute,int second,long nanosec)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(timevalue) op(>) ty(long) id(_timevalue) pu(() ty(int) id(hour) pu(,) ty(int) id(minute) pu(,) ty(int) id(second) pu(,) ty(long) id(nanosec) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<timevalue>  long _timevalue(int hour,int minute,int second,long nanosec)
[D] FUN[384]: name=_timevalue kind=SysCall returns=long void=no nested=no scope={Pri:main} syscallnr=78
[D] PAR[927]: function=_timevalue name=$result type=long order=0 const=no ref=yes
[D] PAR[928]: function=_timevalue name=hour type=int order=1 const=no ref=no
[D] PAR[929]: function=_timevalue name=minute type=int order=2 const=no ref=no
[D] PAR[930]: function=_timevalue name=second type=int order=3 const=no ref=no
[D] PAR[931]: function=_timevalue name=nanosec type=long order=4 const=no ref=no
[I] FUN: name=standard._timevalue(int,int,int,long) index=384 searchindex=7, scope={Pri:main}, scope={Pri:main}
[I] FNC: name=standard._timevalue($cvint,$cvint,$cvint,$cvint) index=384 searchindex=7, scope={Pri:main}, scope={Pri:main}
[D] FID[384]: name=_timevalue kind=3 fullname=standard._timevalue(int,int,int,long) id=standard__timevalue
[A] DECL: (standard__timevalue)               DECLARE {REF LONG $result,INTEGER hour,INTEGER minute,INTEGER second,LONG nanosec} AS SCALL(78) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):415:55: "syscall<timepart>   long _timepart(long tm,tmpart part)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(timepart) op(>) ty(long) id(_timepart) pu(() ty(long) id(tm) pu(,) ty(tmpart) id(part) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<timepart>   long _timepart(long tm,tmpart part)
[D] FUN[385]: name=_timepart kind=SysCall returns=long void=no nested=no scope={Pri:main} syscallnr=79
[D] PAR[932]: function=_timepart name=$result type=long order=0 const=no ref=yes
[D] PAR[933]: function=_timepart name=tm type=long order=1 const=no ref=no
[D] PAR[934]: function=_timepart name=part type=tmpart order=2 const=no ref=no
[I] FUN: name=standard._timepart(long,tmpart) index=385 searchindex=6, scope={Pri:main}, scope={Pri:main}
[I] FNC: name=standard._timepart($cvint,tmpart) index=385 searchindex=6, scope={Pri:main}, scope={Pri:main}
[D] FID[385]: name=_timepart kind=3 fullname=standard._timepart(long,tmpart) id=standard__timepart
[A] DECL: (standard__timepart)                DECLARE {REF LONG $result,LONG tm,INTEGER part} AS SCALL(79) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):416:81: "syscall<timeadd>    long _timeadd(long tm,tmpart part,long units,ref int dayrest)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(timeadd) op(>) ty(long) id(_timeadd) pu(() ty(long) id(tm) pu(,) ty(tmpart) id(part) pu(,) ty(long) id(units) pu(,) kw(ref) ty(int) id(dayrest) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<timeadd>    long _timeadd(long tm,tmpart part,long units,ref int dayrest)
[D] FUN[386]: name=_timeadd kind=SysCall returns=long void=no nested=no scope={Pri:main} syscallnr=80
[D] PAR[935]: function=_timeadd name=$result type=long order=0 const=no ref=yes
[D] PAR[936]: function=_timeadd name=tm type=long order=1 const=no ref=no
[D] PAR[937]: function=_timeadd name=part type=tmpart order=2 const=no ref=no
[D] PAR[938]: function=_timeadd name=units type=long order=3 const=no ref=no
[D] PAR[939]: function=_timeadd name=dayrest type=int order=4 const=no ref=yes
[I] FUN: name=standard._timeadd(long,tmpart,long,int) index=386 searchindex=6, scope={Pri:main}, scope={Pri:main}
[I] FNC: name=standard._timeadd($cvint,tmpart,$cvint,$cvint) index=386 searchindex=6, scope={Pri:main}, scope={Pri:main}
[D] FID[386]: name=_timeadd kind=3 fullname=standard._timeadd(long,tmpart,long,int) id=standard__timeadd
[A] DECL: (standard__timeadd)                 DECLARE {REF LONG $result,LONG tm,INTEGER part,LONG units,REF INTEGER dayrest} AS SCALL(80) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):417:83: "syscall<nsecadd>    long _nsecadd(long nsec,tmpart part,long units,ref int dayrest)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(nsecadd) op(>) ty(long) id(_nsecadd) pu(() ty(long) id(nsec) pu(,) ty(tmpart) id(part) pu(,) ty(long) id(units) pu(,) kw(ref) ty(int) id(dayrest) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<nsecadd>    long _nsecadd(long nsec,tmpart part,long units,ref int dayrest)
[D] FUN[387]: name=_nsecadd kind=SysCall returns=long void=no nested=no scope={Pri:main} syscallnr=81
[D] PAR[940]: function=_nsecadd name=$result type=long order=0 const=no ref=yes
[D] PAR[941]: function=_nsecadd name=nsec type=long order=1 const=no ref=no
[D] PAR[942]: function=_nsecadd name=part type=tmpart order=2 const=no ref=no
[D] PAR[943]: function=_nsecadd name=units type=long order=3 const=no ref=no
[D] PAR[944]: function=_nsecadd name=dayrest type=int order=4 const=no ref=yes
[I] FUN: name=standard._nsecadd(long,tmpart,long,int) index=387 searchindex=6, scope={Pri:main}, scope={Pri:main}
[I] FNC: name=standard._nsecadd($cvint,tmpart,$cvint,$cvint) index=387 searchindex=6, scope={Pri:main}, scope={Pri:main}
[D] FID[387]: name=_nsecadd kind=3 fullname=standard._nsecadd(long,tmpart,long,int) id=standard__nsecadd
[A] DECL: (standard__nsecadd)                 DECLARE {REF LONG $result,LONG nsec,INTEGER part,LONG units,REF INTEGER dayrest} AS SCALL(81) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):418:42: "syscall<getdate>    int _getdate(bool utc)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(getdate) op(>) ty(int) id(_getdate) pu(() ty(bool) id(utc) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<getdate>    int _getdate(bool utc)
[D] FUN[388]: name=_getdate kind=SysCall returns=int void=no nested=no scope={Pri:main} syscallnr=82
[D] PAR[945]: function=_getdate name=$result type=int order=0 const=no ref=yes
[D] PAR[946]: function=_getdate name=utc type=bool order=1 const=no ref=no
[I] FUN: name=standard._getdate(bool) index=388 searchindex=6, scope={Pri:main}, scope={Pri:main}
[D] FID[388]: name=_getdate kind=3 fullname=standard._getdate(bool) id=standard__getdate
[A] DECL: (standard__getdate)                 DECLARE {REF INTEGER $result,BOOLEAN utc} AS SCALL(82) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):419:43: "syscall<gettime>    long _gettime(bool utc)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(gettime) op(>) ty(long) id(_gettime) pu(() ty(bool) id(utc) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<gettime>    long _gettime(bool utc)
[D] FUN[389]: name=_gettime kind=SysCall returns=long void=no nested=no scope={Pri:main} syscallnr=83
[D] PAR[947]: function=_gettime name=$result type=long order=0 const=no ref=yes
[D] PAR[948]: function=_gettime name=utc type=bool order=1 const=no ref=no
[I] FUN: name=standard._gettime(bool) index=389 searchindex=7, scope={Pri:main}, scope={Pri:main}
[D] FID[389]: name=_gettime kind=3 fullname=standard._gettime(bool) id=standard__gettime
[A] DECL: (standard__gettime)                 DECLARE {REF LONG $result,BOOLEAN utc} AS SCALL(83) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):420:50: "syscall<datediff>   int _datediff(int dt1,int dt2)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(datediff) op(>) ty(int) id(_datediff) pu(() ty(int) id(dt1) pu(,) ty(int) id(dt2) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<datediff>   int _datediff(int dt1,int dt2)
[D] FUN[390]: name=_datediff kind=SysCall returns=int void=no nested=no scope={Pri:main} syscallnr=84
[D] PAR[949]: function=_datediff name=$result type=int order=0 const=no ref=yes
[D] PAR[950]: function=_datediff name=dt1 type=int order=1 const=no ref=no
[D] PAR[951]: function=_datediff name=dt2 type=int order=2 const=no ref=no
[I] FUN: name=standard._datediff(int,int) index=390 searchindex=2, scope={Pri:main}, scope={Pri:main}
[I] FNC: name=standard._datediff($cvint,$cvint) index=390 searchindex=2, scope={Pri:main}, scope={Pri:main}
[D] FID[390]: name=_datediff kind=3 fullname=standard._datediff(int,int) id=standard__datediff
[A] DECL: (standard__datediff)                DECLARE {REF INTEGER $result,INTEGER dt1,INTEGER dt2} AS SCALL(84) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):421:53: "syscall<timediff>   long _timediff(long tm1,long tm2)"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(timediff) op(>) ty(long) id(_timediff) pu(() ty(long) id(tm1) pu(,) ty(long) id(tm2) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<timediff>   long _timediff(long tm1,long tm2)
[D] FUN[391]: name=_timediff kind=SysCall returns=long void=no nested=no scope={Pri:main} syscallnr=85
[D] PAR[952]: function=_timediff name=$result type=long order=0 const=no ref=yes
[D] PAR[953]: function=_timediff name=tm1 type=long order=1 const=no ref=no
[D] PAR[954]: function=_timediff name=tm2 type=long order=2 const=no ref=no
[I] FUN: name=standard._timediff(long,long) index=391 searchindex=11, scope={Pri:main}, scope={Pri:main}
[I] FNC: name=standard._timediff($cvint,$cvint) index=391 searchindex=9, scope={Pri:main}, scope={Pri:main}
[D] FID[391]: name=_timediff kind=3 fullname=standard._timediff(long,long) id=standard__timediff
[A] DECL: (standard__timediff)                DECLARE {REF LONG $result,LONG tm1,LONG tm2} AS SCALL(85) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):424:40: "syscall<hostsystem> int _gethostsystem()"
[P] Parsed sentence: [SystemCall] kw(syscall) op(<) id(hostsystem) op(>) ty(int) id(_gethostsystem) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;syscall<hostsystem> int _gethostsystem()
[D] FUN[392]: name=_gethostsystem kind=SysCall returns=int void=no nested=no scope={Pri:main} syscallnr=8
[D] PAR[955]: function=_gethostsystem name=$result type=int order=0 const=no ref=yes
[I] FUN: name=standard._gethostsystem() index=392 searchindex=8, scope={Pri:main}, scope={Pri:main}
[D] FID[392]: name=_gethostsystem kind=3 fullname=standard._gethostsystem() id=standard__gethostsystem
[A] DECL: (standard__gethostsystem)           DECLARE {REF INTEGER $result} AS SCALL(8) 
[P] -------------------------------------------------------------------------------------
[L] Read line (src):427:7: ".implem"
[P] Parsed sentence: [Implem] kw(.implem)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     RET                                                             ;[0000000000000015h] 00E6
[N] Init routine list append: module=standard name=$initstandard address=0000000000000002h, scopedepth=1
[F] Stored function address: id=standard_$initstandard fullname=standard.$initstandard() address=0000000000000002h scopedepth=1
[N] Init routine list append: module=standard name=$delayedinitstandard address=unresolved, scopedepth=1
[D] FUN[393]: name=$delayedinitstandard kind=Function returns=undefined void=yes nested=no scope={Pri:main}
[I] FUN: name=standard.$delayedinitstandard() index=393 searchindex=0, scope={Pri:main}, scope={Pri:main}
[D] FID[393]: name=$delayedinitstandard kind=0 fullname=standard.$delayedinitstandard() id=standard_$delayedinitstandard
[K] Queued first (add): func void $delayedinitstandard():
[A] CODE: 
[A] CODE: ($initsuper)                        FUNCTION
[N] Solved super init routine address to 0000000000000017h
[F] Stored function address: id=standard_$initsuper fullname=standard.$initsuper() address=0000000000000017h scopedepth=0
[O] Relocation added: Type=FunctionAddr, LocAdr=000000000000001Ah
[A] CODE:                                     CALL (standard_$initstandard)                                   ;[0000000000000017h] 00E5 80 (standard_$initstandard)
[N] Added call to init routine $initstandard on address 0000000000000002h (scopedepth=1)
[F] Stored forward call: id=standard_$delayedinitstandard fullname=standard.$delayedinitstandard() at=0000000000000025h scopedepth=1
[O] Relocation added: Type=FunctionAddr, LocAdr=0000000000000025h
[A] CODE:                                     CALL (standard_$delayedinitstandard)                            ;[0000000000000022h] 00E5 80 (standard_$delayedinitstandard)
[N] Added call to init routine $delayedinitstandard on address 0000000000000000h (scopedepth=1)
[A] CODE:                                     RET                                                             ;[000000000000002Dh] 00E6
[P] -------------------------------------------------------------------------------------
[L] Read line (src):430:29: "func hostsys gethostsystem():"
[P] Parsed sentence: [Function] kw(func) ty(hostsys) id(gethostsystem) pu(() pu()) pu(:)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[J] Jump event: BlockBeg GlobalBaseLabel=0
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0}  
[A] HEAD: 
[A] HEAD: ;---------------------------------------------------------------------------------------------------
[A] HEAD: ; func hostsys gethostsystem():
[A] HEAD: ;---------------------------------------------------------------------------------------------------
[A] HEAD: 
[F] Stored function address: id=standard_gethostsystem fullname=standard.gethostsystem() address=000000000000002Fh scopedepth=0
[Y] Update OFUN[229]: Address=47
[A] CODE:                                     ;Reserve function stack size
[A] CODE:                                     STACK %TEXTARG0%                                                ;[000000000000002Fh] 00BB 80 %HEXARG0%
[S] Scope open: {Loc:gethostsystem}
[A] DECL:                                     ;Parameters
[D] VAR[10]: name=$result type=hostsys scope={Loc:gethostsystem} address=0 const=no static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.$result index=10 searchindex=0, scope={Loc:gethostsystem}
[A] DECL: <$result>                           PARM REFERENCE                                                  ;Address=<0000000000000000h>
[A] DECL: 
[S] Current scope: {Loc:gethostsystem}, StackLength=3
[P] -------------------------------------------------------------------------------------
[L] Read line (src):431:17: "  hostsys hsystem"
[P] Parsed sentence: [VarDecl] ty(hostsys) id(hsystem)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;hostsys hsystem
[O] Relocation added: Type=BlkInsideGlo, LocAdr=0000000000000100h
[A] DATA:                                     STORE "hsystem"                                                 ;Address=[0000000000000100h]
[D] VAR[11]: name=hsystem type=hostsys scope={Loc:gethostsystem} address=16 const=no static=no parameter=no ref=no temp=no buffstore=yes length=4
[I] VAR: name=standard.hsystem index=11 searchindex=1, scope={Loc:gethostsystem}
[A] DECL: <hsystem>                           VAR INTEGER                                                     ;Address=<0000000000000010h> { hostsys hsystem }
[P] -------------------------------------------------------------------------------------
[L] Read line (src):432:27: "  switch(_gethostsystem()):"
[P] Parsed sentence: [Switch] kw(switch) pu(() id(_gethostsystem) pu(() pu()) pu()) pu(:)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={swi} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;switch(_gethostsystem()):
[P] -------------------------------------------------------------------------------------
[W] Queued (spl):  hsystem=hostsys.linux;
[W] Queued (spl):    break
[L] Read line (src):433:12: "    when(1):"
[P] Parsed sentence: [When] kw(when) pu(() ch(1R) pu()) pu(:)
[J] Sentence labels: BaseLabel=1 SubLabel=0 BlockId={swi} LoopLabel=-1 LoopId={}
[J] Jump event: FirstCase GlobalBaseLabel=1
[B] Code block stack updated: Replace --> {Implementation:0:0 Local:0:0 FirstCase:1:0}  
[A] CODE: 
[A] CODE:                                     ;when(1):
[J] Stored jump destination: scopedepth=2 label=000001swi-cond0 address=000000000000003Ah
[E] ExprCompiler input: [Switch] id(_gethostsystem) pu(() pu()) op(==) ch(1R)
[E] Release all temp variables
[E] Tokenizer ouput: func(standard._gethostsystem,0) ( ) opr== {K}1C
[E] RPN ouput: func(standard._gethostsystem,0) {K}1C opr==
[E] .......... Processing token func(standard._gethostsystem,0) ..........
[E] Requested new temp variable for type=int reference=false kind=regular
[D] VAR[12]: name=$Int000t type=int scope={Loc:gethostsystem} address=20 const=no static=no parameter=no ref=no temp=yes buffstore=yes length=4
[I] VAR: name=standard.$Int000t index=12 searchindex=0, scope={Loc:gethostsystem}
[E] New temp variable $Int000t created (type=int reference=false kind=regular)
[A] TEMP: <$Int000t>                          VAR INTEGER                                                     ;Address=<0000000000000014h>
[A] CODE: {000001swi-cond0}:                  REFPU <$Int000t>                                                ;[000000000000003Ah] 00D6 00 0000000000000014
[A] CODE:                                     SCALL (I)8                                                      ;[0000000000000045h] 00E9 80 00000008
[E] Token func(standard._gethostsystem,0) --> Operand stack {var:(int)$Int000t}
[E] .......... Processing token {K}1C ..........
[E] Token {K}1C --> Operand stack {var:(int)$Int000t {K}1C}
[E] .......... Processing token opr== ..........
[E] Temp variable $Int000t released
[E] Source used flag set on variable $Int000t in scope {Loc:gethostsystem}
[E] Requested new temp variable for type=bool reference=false kind=regular
[D] VAR[13]: name=$Bol000t type=bool scope={Loc:gethostsystem} address=24 const=no static=no parameter=no ref=no temp=yes buffstore=yes length=1
[I] VAR: name=standard.$Bol000t index=13 searchindex=0, scope={Loc:gethostsystem}
[E] New temp variable $Bol000t created (type=bool reference=false kind=regular)
[A] TEMP: <$Bol000t>                          VAR BOOLEAN                                                     ;Address=<0000000000000018h>
[A] CODE:                                     EQUi <$Bol000t>,<$Int000t>,(I)1                                 ;[000000000000004Ch] 006B 08 0000000000000018 0000000000000014 00000001
[E] Token opr== --> Operand stack {var:(bool)$Bol000t}
[E] Source used flag set on variable $Bol000t in scope {Loc:gethostsystem}
[E] Result token: var:(bool)$Bol000t
[J] Stored jump origin: scopedepth=2 label=000001swi-cond1 codeadr=000000000000006Eh instadr=0000000000000063h
[A] CODE:                                     JMPFL <$Bol000t>,{000001swi-cond1}                              ;[0000000000000063h] 0135 20 0000000000000018 {000001swi-cond1}
[P] -------------------------------------------------------------------------------------
[L] Read line (spl):433:35: " hsystem=hostsys.linux;"
[P] Parsed sentence: [Expression] id(hsystem) op(=) ty(hostsys) op(.) id(linux)
[J] Sentence labels: BaseLabel=1 SubLabel=0 BlockId={swi} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;hsystem=hostsys.linux;
[E] ExprCompiler input: [Expression] id(hsystem) op(=) ty(hostsys) op(.) id(linux)
[E] Release all temp variables
[E] Temp variable $Int000t released
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: var:(hostsys)hsystem opr= {K}Enu:hostsys:0
[E] RPN ouput: var:(hostsys)hsystem {K}Enu:hostsys:0 opr=
[E] .......... Processing token var:(hostsys)hsystem ..........
[E] Token var:(hostsys)hsystem --> Operand stack {var:(hostsys)hsystem}
[E] .......... Processing token {K}Enu:hostsys:0 ..........
[E] Token {K}Enu:hostsys:0 --> Operand stack {var:(hostsys)hsystem {K}Enu:hostsys:0}
[E] .......... Processing token opr= ..........
[A] CODE:                                     MVi <hsystem>,(I)0                                              ;[0000000000000076h] 0079 20 0000000000000010 00000000
[E] Token opr= --> Operand stack {var:(hostsys)hsystem}
[P] -------------------------------------------------------------------------------------
[L] Read line (spl):433:43: "   break"
[P] Parsed sentence: [Break] kw(break)
[J] Sentence labels: BaseLabel=1 SubLabel=0 BlockId={swi} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;break
[J] Stored jump origin: scopedepth=2 label=000001swi-exit codeadr=0000000000000088h instadr=0000000000000085h
[A] CODE:                                     JMP {000001swi-exit}                                            ;[0000000000000085h] 0136 80 {000001swi-exit}
[P] -------------------------------------------------------------------------------------
[W] Queued (spl):  hsystem=hostsys.windows;
[W] Queued (spl):  break
[L] Read line (src):434:12: "    when(2):"
[P] Parsed sentence: [When] kw(when) pu(() ch(2R) pu()) pu(:)
[J] Sentence labels: BaseLabel=1 SubLabel=1 BlockId={swi} LoopLabel=-1 LoopId={}
[J] Jump event: NextCase GlobalBaseLabel=1
[B] Code block stack updated: Replace --> {Implementation:0:0 Local:0:0 NextCase:1:1}  
[A] CODE: 
[A] CODE:                                     ;when(2):
[J] Stored jump destination: scopedepth=2 label=000001swi-cond1 address=0000000000000090h
[E] ExprCompiler input: [Switch] id(_gethostsystem) pu(() pu()) op(==) ch(2R)
[E] Release all temp variables
[E] Temp variable $Int000t released
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: func(standard._gethostsystem,0) ( ) opr== {K}2C
[E] RPN ouput: func(standard._gethostsystem,0) {K}2C opr==
[E] .......... Processing token func(standard._gethostsystem,0) ..........
[E] Requested new temp variable for type=int reference=false kind=regular
[E] Temp variable $Int000t reused (type=int reference=false kind=regular)
[A] CODE: {000001swi-cond1}:                  REFPU <$Int000t>                                                ;[0000000000000090h] 00D6 00 0000000000000014
[A] CODE:                                     SCALL (I)8                                                      ;[000000000000009Bh] 00E9 80 00000008
[E] Token func(standard._gethostsystem,0) --> Operand stack {var:(int)$Int000t}
[E] .......... Processing token {K}2C ..........
[E] Token {K}2C --> Operand stack {var:(int)$Int000t {K}2C}
[E] .......... Processing token opr== ..........
[E] Temp variable $Int000t released
[E] Source used flag set on variable $Int000t in scope {Loc:gethostsystem}
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[A] CODE:                                     EQUi <$Bol000t>,<$Int000t>,(I)2                                 ;[00000000000000A2h] 006B 08 0000000000000018 0000000000000014 00000002
[E] Token opr== --> Operand stack {var:(bool)$Bol000t}
[E] Source used flag set on variable $Bol000t in scope {Loc:gethostsystem}
[E] Result token: var:(bool)$Bol000t
[J] Stored jump origin: scopedepth=2 label=000001swi-cond2 codeadr=00000000000000C4h instadr=00000000000000B9h
[A] CODE:                                     JMPFL <$Bol000t>,{000001swi-cond2}                              ;[00000000000000B9h] 0135 20 0000000000000018 {000001swi-cond2}
[P] -------------------------------------------------------------------------------------
[L] Read line (spl):434:37: " hsystem=hostsys.windows;"
[P] Parsed sentence: [Expression] id(hsystem) op(=) ty(hostsys) op(.) id(windows)
[J] Sentence labels: BaseLabel=1 SubLabel=1 BlockId={swi} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;hsystem=hostsys.windows;
[E] ExprCompiler input: [Expression] id(hsystem) op(=) ty(hostsys) op(.) id(windows)
[E] Release all temp variables
[E] Temp variable $Int000t released
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: var:(hostsys)hsystem opr= {K}Enu:hostsys:1
[E] RPN ouput: var:(hostsys)hsystem {K}Enu:hostsys:1 opr=
[E] .......... Processing token var:(hostsys)hsystem ..........
[E] Token var:(hostsys)hsystem --> Operand stack {var:(hostsys)hsystem}
[E] .......... Processing token {K}Enu:hostsys:1 ..........
[E] Token {K}Enu:hostsys:1 --> Operand stack {var:(hostsys)hsystem {K}Enu:hostsys:1}
[E] .......... Processing token opr= ..........
[A] CODE:                                     MVi <hsystem>,(I)1                                              ;[00000000000000CCh] 0079 20 0000000000000010 00000001
[E] Token opr= --> Operand stack {var:(hostsys)hsystem}
[P] -------------------------------------------------------------------------------------
[L] Read line (spl):434:43: " break"
[P] Parsed sentence: [Break] kw(break)
[J] Sentence labels: BaseLabel=1 SubLabel=1 BlockId={swi} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;break
[J] Stored jump origin: scopedepth=2 label=000001swi-exit codeadr=00000000000000DEh instadr=00000000000000DBh
[A] CODE:                                     JMP {000001swi-exit}                                            ;[00000000000000DBh] 0136 80 {000001swi-exit}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):435:9: "  :switch"
[P] Parsed sentence: [EndSwitch] kw(:switch)
[J] Sentence labels: BaseLabel=1 SubLabel=1 BlockId={swi} LoopLabel=-1 LoopId={}
[J] Jump event: EndCase GlobalBaseLabel=1
[B] Code block stack updated: Pop --> {Implementation:0:0 Local:0:0}  
[A] CODE: 
[A] CODE:                                     ;:switch
[J] Stored jump destination: scopedepth=2 label=000001swi-cond2 address=00000000000000E6h
[J] Stored jump destination: scopedepth=2 label=000001swi-exit address=00000000000000E6h
[P] -------------------------------------------------------------------------------------
[L] Read line (src):436:16: "  return hsystem"
[P] Parsed sentence: [Return] kw(return) id(hsystem)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;return hsystem
[E] ExprCompiler input: [Return] id(hsystem)
[E] Release all temp variables
[E] Temp variable $Int000t released
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: var:(hostsys)hsystem
[E] RPN ouput: var:(hostsys)hsystem
[E] .......... Processing token var:(hostsys)hsystem ..........
[E] Token var:(hostsys)hsystem --> Operand stack {var:(hostsys)hsystem}
[E] Source used flag set on variable hsystem in scope {Loc:gethostsystem}
[E] Result token: var:(hostsys)hsystem
[A] CODE: {000001swi-exit}:                   
[A] CODE: {000001swi-cond2}:                  MVi *<$result>,<hsystem>                                        ;[00000000000000E6h] 0079 40 0000000000000000 0000000000000010
[A] CODE:                                     RET                                                             ;[00000000000000F9h] 00E6
[P] -------------------------------------------------------------------------------------
[L] Read line (src):437:5: ":func"
[P] Parsed sentence: [EndFunction] kw(:func)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[J] Jump event: BlockEnd GlobalBaseLabel=1
[B] Code block stack updated: Pop --> {Implementation:0:0}  
[S] Scope close: {Loc:gethostsystem}
[J] Solving jump labels for scope depth 2...
[J] Solved jump: scopedepth=2 codeadr=000000000000006Eh instadr=0000000000000063h destadr=0000000000000090h relative=000000000000002Dh label=000001swi-cond1
[J] Solved jump: scopedepth=2 codeadr=0000000000000088h instadr=0000000000000085h destadr=00000000000000E6h relative=0000000000000061h label=000001swi-exit
[J] Solved jump: scopedepth=2 codeadr=00000000000000C4h instadr=00000000000000B9h destadr=00000000000000E6h relative=000000000000002Dh label=000001swi-cond2
[J] Solved jump: scopedepth=2 codeadr=00000000000000DEh instadr=00000000000000DBh destadr=00000000000000E6h relative=000000000000000Bh label=000001swi-exit
[A] FOOT: 
[A] FOOT: ; Jump addresses on scope {Loc:gethostsystem} (depth=2):
[A] FOOT: ; [000000000000003Ah] = {000001swi-cond0}
[A] FOOT: ; [0000000000000090h] = {000001swi-cond1}
[A] FOOT: ; [00000000000000E6h] = {000001swi-cond2}
[A] FOOT: ; [00000000000000E6h] = {000001swi-exit}
[F] Solving forward calls for scope depth 2...
[F] Addr: ScopeDepth=0 Function=standard.$initsuper()
[F] Addr: ScopeDepth=0 Function=standard.gethostsystem()
[F] Addr: ScopeDepth=1 Function=standard.$initstandard()
[F] Call: ScopeDepth=1 Function=standard.$delayedinitstandard()
[S] Current scope: {Pri:main}, StackLength=2
[A] HEAD: (standard_gethostsystem)            FUNCTION
[A] CODE: 
[A] CODE:                                     ;End function
[A] CODE:                                     END
[P] -------------------------------------------------------------------------------------
[L] Read line (src):440:32: "func string gethostsystemname():"
[P] Parsed sentence: [Function] kw(func) ty(string) id(gethostsystemname) pu(() pu()) pu(:)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[J] Jump event: BlockBeg GlobalBaseLabel=0
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0}  
[A] HEAD: 
[A] HEAD: ;---------------------------------------------------------------------------------------------------
[A] HEAD: ; func string gethostsystemname():
[A] HEAD: ;---------------------------------------------------------------------------------------------------
[A] HEAD: 
[F] Stored function address: id=standard_gethostsystemname fullname=standard.gethostsystemname() address=00000000000000FBh scopedepth=0
[Y] Update OFUN[230]: Address=251
[A] CODE:                                     ;Reserve function stack size
[A] CODE:                                     STACK %TEXTARG0%                                                ;[00000000000000FBh] 00BB 80 %HEXARG0%
[S] Scope open: {Loc:gethostsystemname}
[A] DECL:                                     ;Parameters
[D] VAR[10]: name=$result type=string scope={Loc:gethostsystemname} address=0 const=no static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.$result index=10 searchindex=0, scope={Loc:gethostsystemname}
[A] DECL: <$result>                           PARM REFERENCE                                                  ;Address=<0000000000000000h>
[A] DECL: 
[S] Current scope: {Loc:gethostsystemname}, StackLength=3
[P] -------------------------------------------------------------------------------------
[L] Read line (src):441:13: "  string name"
[P] Parsed sentence: [VarDecl] ty(string) id(name)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;string name
[O] Relocation added: Type=BlkInsideGlo, LocAdr=0000000000000104h
[A] DATA:                                     STORE "name"                                                    ;Address=[0000000000000104h]
[D] VAR[11]: name=name type=string scope={Loc:gethostsystemname} address=16 const=no static=no parameter=no ref=no temp=no buffstore=yes length=4
[I] VAR: name=standard.name index=11 searchindex=1, scope={Loc:gethostsystemname}
[A] DECL: <name>                              VAR STRINGBLOCK                                                 ;Address=<0000000000000010h> { string name }
[P] -------------------------------------------------------------------------------------
[L] Read line (src):442:27: "  switch(_gethostsystem()):"
[P] Parsed sentence: [Switch] kw(switch) pu(() id(_gethostsystem) pu(() pu()) pu()) pu(:)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={swi} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;switch(_gethostsystem()):
[P] -------------------------------------------------------------------------------------
[W] Queued (spl):  name="linux";
[W] Queued (spl):    break
[L] Read line (src):443:12: "    when(1):"
[P] Parsed sentence: [When] kw(when) pu(() ch(1R) pu()) pu(:)
[J] Sentence labels: BaseLabel=1 SubLabel=0 BlockId={swi} LoopLabel=-1 LoopId={}
[J] Jump event: FirstCase GlobalBaseLabel=1
[B] Code block stack updated: Replace --> {Implementation:0:0 Local:0:0 FirstCase:1:0}  
[A] CODE: 
[A] CODE:                                     ;when(1):
[J] Stored jump destination: scopedepth=2 label=000001swi-cond0 address=0000000000000106h
[E] ExprCompiler input: [Switch] id(_gethostsystem) pu(() pu()) op(==) ch(1R)
[E] Release all temp variables
[E] Tokenizer ouput: func(standard._gethostsystem,0) ( ) opr== {K}1C
[E] RPN ouput: func(standard._gethostsystem,0) {K}1C opr==
[E] .......... Processing token func(standard._gethostsystem,0) ..........
[E] Requested new temp variable for type=int reference=false kind=regular
[D] VAR[12]: name=$Int000t type=int scope={Loc:gethostsystemname} address=20 const=no static=no parameter=no ref=no temp=yes buffstore=yes length=4
[I] VAR: name=standard.$Int000t index=12 searchindex=0, scope={Loc:gethostsystemname}
[E] New temp variable $Int000t created (type=int reference=false kind=regular)
[A] TEMP: <$Int000t>                          VAR INTEGER                                                     ;Address=<0000000000000014h>
[A] CODE: {000001swi-cond0}:                  REFPU <$Int000t>                                                ;[0000000000000106h] 00D6 00 0000000000000014
[A] CODE:                                     SCALL (I)8                                                      ;[0000000000000111h] 00E9 80 00000008
[E] Token func(standard._gethostsystem,0) --> Operand stack {var:(int)$Int000t}
[E] .......... Processing token {K}1C ..........
[E] Token {K}1C --> Operand stack {var:(int)$Int000t {K}1C}
[E] .......... Processing token opr== ..........
[E] Temp variable $Int000t released
[E] Source used flag set on variable $Int000t in scope {Loc:gethostsystemname}
[E] Requested new temp variable for type=bool reference=false kind=regular
[D] VAR[13]: name=$Bol000t type=bool scope={Loc:gethostsystemname} address=24 const=no static=no parameter=no ref=no temp=yes buffstore=yes length=1
[I] VAR: name=standard.$Bol000t index=13 searchindex=0, scope={Loc:gethostsystemname}
[E] New temp variable $Bol000t created (type=bool reference=false kind=regular)
[A] TEMP: <$Bol000t>                          VAR BOOLEAN                                                     ;Address=<0000000000000018h>
[A] CODE:                                     EQUi <$Bol000t>,<$Int000t>,(I)1                                 ;[0000000000000118h] 006B 08 0000000000000018 0000000000000014 00000001
[E] Token opr== --> Operand stack {var:(bool)$Bol000t}
[E] Source used flag set on variable $Bol000t in scope {Loc:gethostsystemname}
[E] Result token: var:(bool)$Bol000t
[J] Stored jump origin: scopedepth=2 label=000001swi-cond1 codeadr=000000000000013Ah instadr=000000000000012Fh
[A] CODE:                                     JMPFL <$Bol000t>,{000001swi-cond1}                              ;[000000000000012Fh] 0135 20 0000000000000018 {000001swi-cond1}
[P] -------------------------------------------------------------------------------------
[L] Read line (spl):443:26: " name="linux";"
[P] Parsed sentence: [Expression] id(name) op(=) st("linux")
[J] Sentence labels: BaseLabel=1 SubLabel=0 BlockId={swi} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;name="linux";
[E] ExprCompiler input: [Expression] id(name) op(=) st("linux")
[E] Release all temp variables
[E] Temp variable $Int000t released
[E] Temp variable $Bol000t released
[O] Relocation added: Type=BlkInsideGlo, LocAdr=0000000000000108h
[A] DATA:                                     STORE "linux"                                                   ;Address=[0000000000000108h]
[E] Tokenizer ouput: var:(string)name opr= {K}Str:264
[E] RPN ouput: var:(string)name {K}Str:264 opr=
[E] .......... Processing token var:(string)name ..........
[E] Token var:(string)name --> Operand stack {var:(string)name}
[E] .......... Processing token {K}Str:264 ..........
[E] Token {K}Str:264 --> Operand stack {var:(string)name {K}Str:264}
[E] .......... Processing token opr= ..........
[O] Relocation added: Type=GlobVarvAddr, LocAdr=000000000000014Dh
[A] CODE:                                     SCOPY <name>,[STR(0000000000000108h)]                           ;[0000000000000142h] 00B1 00 0000000000000010 8000000000000108
[E] Token opr= --> Operand stack {var:(string)name}
[P] -------------------------------------------------------------------------------------
[L] Read line (spl):443:34: "   break"
[P] Parsed sentence: [Break] kw(break)
[J] Sentence labels: BaseLabel=1 SubLabel=0 BlockId={swi} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;break
[J] Stored jump origin: scopedepth=2 label=000001swi-exit codeadr=0000000000000158h instadr=0000000000000155h
[A] CODE:                                     JMP {000001swi-exit}                                            ;[0000000000000155h] 0136 80 {000001swi-exit}
[P] -------------------------------------------------------------------------------------
[W] Queued (spl):  name="windows";
[W] Queued (spl):  break
[L] Read line (src):444:12: "    when(2):"
[P] Parsed sentence: [When] kw(when) pu(() ch(2R) pu()) pu(:)
[J] Sentence labels: BaseLabel=1 SubLabel=1 BlockId={swi} LoopLabel=-1 LoopId={}
[J] Jump event: NextCase GlobalBaseLabel=1
[B] Code block stack updated: Replace --> {Implementation:0:0 Local:0:0 NextCase:1:1}  
[A] CODE: 
[A] CODE:                                     ;when(2):
[J] Stored jump destination: scopedepth=2 label=000001swi-cond1 address=0000000000000160h
[E] ExprCompiler input: [Switch] id(_gethostsystem) pu(() pu()) op(==) ch(2R)
[E] Release all temp variables
[E] Temp variable $Int000t released
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: func(standard._gethostsystem,0) ( ) opr== {K}2C
[E] RPN ouput: func(standard._gethostsystem,0) {K}2C opr==
[E] .......... Processing token func(standard._gethostsystem,0) ..........
[E] Requested new temp variable for type=int reference=false kind=regular
[E] Temp variable $Int000t reused (type=int reference=false kind=regular)
[A] CODE: {000001swi-cond1}:                  REFPU <$Int000t>                                                ;[0000000000000160h] 00D6 00 0000000000000014
[A] CODE:                                     SCALL (I)8                                                      ;[000000000000016Bh] 00E9 80 00000008
[E] Token func(standard._gethostsystem,0) --> Operand stack {var:(int)$Int000t}
[E] .......... Processing token {K}2C ..........
[E] Token {K}2C --> Operand stack {var:(int)$Int000t {K}2C}
[E] .......... Processing token opr== ..........
[E] Temp variable $Int000t released
[E] Source used flag set on variable $Int000t in scope {Loc:gethostsystemname}
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[A] CODE:                                     EQUi <$Bol000t>,<$Int000t>,(I)2                                 ;[0000000000000172h] 006B 08 0000000000000018 0000000000000014 00000002
[E] Token opr== --> Operand stack {var:(bool)$Bol000t}
[E] Source used flag set on variable $Bol000t in scope {Loc:gethostsystemname}
[E] Result token: var:(bool)$Bol000t
[J] Stored jump origin: scopedepth=2 label=000001swi-cond2 codeadr=0000000000000194h instadr=0000000000000189h
[A] CODE:                                     JMPFL <$Bol000t>,{000001swi-cond2}                              ;[0000000000000189h] 0135 20 0000000000000018 {000001swi-cond2}
[P] -------------------------------------------------------------------------------------
[L] Read line (spl):444:28: " name="windows";"
[P] Parsed sentence: [Expression] id(name) op(=) st("windows")
[J] Sentence labels: BaseLabel=1 SubLabel=1 BlockId={swi} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;name="windows";
[E] ExprCompiler input: [Expression] id(name) op(=) st("windows")
[E] Release all temp variables
[E] Temp variable $Int000t released
[E] Temp variable $Bol000t released
[O] Relocation added: Type=BlkInsideGlo, LocAdr=000000000000010Ch
[A] DATA:                                     STORE "windows"                                                 ;Address=[000000000000010Ch]
[E] Tokenizer ouput: var:(string)name opr= {K}Str:268
[E] RPN ouput: var:(string)name {K}Str:268 opr=
[E] .......... Processing token var:(string)name ..........
[E] Token var:(string)name --> Operand stack {var:(string)name}
[E] .......... Processing token {K}Str:268 ..........
[E] Token {K}Str:268 --> Operand stack {var:(string)name {K}Str:268}
[E] .......... Processing token opr= ..........
[O] Relocation added: Type=GlobVarvAddr, LocAdr=00000000000001A7h
[A] CODE:                                     SCOPY <name>,[STR(000000000000010Ch)]                           ;[000000000000019Ch] 00B1 00 0000000000000010 800000000000010C
[E] Token opr= --> Operand stack {var:(string)name}
[P] -------------------------------------------------------------------------------------
[L] Read line (spl):444:34: " break"
[P] Parsed sentence: [Break] kw(break)
[J] Sentence labels: BaseLabel=1 SubLabel=1 BlockId={swi} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;break
[J] Stored jump origin: scopedepth=2 label=000001swi-exit codeadr=00000000000001B2h instadr=00000000000001AFh
[A] CODE:                                     JMP {000001swi-exit}                                            ;[00000000000001AFh] 0136 80 {000001swi-exit}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):445:9: "  :switch"
[P] Parsed sentence: [EndSwitch] kw(:switch)
[J] Sentence labels: BaseLabel=1 SubLabel=1 BlockId={swi} LoopLabel=-1 LoopId={}
[J] Jump event: EndCase GlobalBaseLabel=1
[B] Code block stack updated: Pop --> {Implementation:0:0 Local:0:0}  
[A] CODE: 
[A] CODE:                                     ;:switch
[J] Stored jump destination: scopedepth=2 label=000001swi-cond2 address=00000000000001BAh
[J] Stored jump destination: scopedepth=2 label=000001swi-exit address=00000000000001BAh
[P] -------------------------------------------------------------------------------------
[L] Read line (src):446:13: "  return name"
[P] Parsed sentence: [Return] kw(return) id(name)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;return name
[E] ExprCompiler input: [Return] id(name)
[E] Release all temp variables
[E] Temp variable $Int000t released
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: var:(string)name
[E] RPN ouput: var:(string)name
[E] .......... Processing token var:(string)name ..........
[E] Token var:(string)name --> Operand stack {var:(string)name}
[E] Source used flag set on variable name in scope {Loc:gethostsystemname}
[E] Result token: var:(string)name
[A] CODE: {000001swi-exit}:                   
[A] CODE: {000001swi-cond2}:                  SCOPY *<$result>,<name>                                         ;[00000000000001BAh] 00B1 40 0000000000000000 0000000000000010
[A] CODE:                                     RET                                                             ;[00000000000001CDh] 00E6
[P] -------------------------------------------------------------------------------------
[L] Read line (src):447:5: ":func"
[P] Parsed sentence: [EndFunction] kw(:func)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[J] Jump event: BlockEnd GlobalBaseLabel=1
[B] Code block stack updated: Pop --> {Implementation:0:0}  
[S] Scope close: {Loc:gethostsystemname}
[J] Solving jump labels for scope depth 2...
[J] Solved jump: scopedepth=2 codeadr=000000000000013Ah instadr=000000000000012Fh destadr=0000000000000160h relative=0000000000000031h label=000001swi-cond1
[J] Solved jump: scopedepth=2 codeadr=0000000000000158h instadr=0000000000000155h destadr=00000000000001BAh relative=0000000000000065h label=000001swi-exit
[J] Solved jump: scopedepth=2 codeadr=0000000000000194h instadr=0000000000000189h destadr=00000000000001BAh relative=0000000000000031h label=000001swi-cond2
[J] Solved jump: scopedepth=2 codeadr=00000000000001B2h instadr=00000000000001AFh destadr=00000000000001BAh relative=000000000000000Bh label=000001swi-exit
[A] FOOT: 
[A] FOOT: ; Jump addresses on scope {Loc:gethostsystemname} (depth=2):
[A] FOOT: ; [0000000000000106h] = {000001swi-cond0}
[A] FOOT: ; [0000000000000160h] = {000001swi-cond1}
[A] FOOT: ; [00000000000001BAh] = {000001swi-cond2}
[A] FOOT: ; [00000000000001BAh] = {000001swi-exit}
[F] Solving forward calls for scope depth 2...
[F] Addr: ScopeDepth=0 Function=standard.$initsuper()
[F] Addr: ScopeDepth=0 Function=standard.gethostsystem()
[F] Addr: ScopeDepth=0 Function=standard.gethostsystemname()
[F] Addr: ScopeDepth=1 Function=standard.$initstandard()
[F] Call: ScopeDepth=1 Function=standard.$delayedinitstandard()
[S] Current scope: {Pri:main}, StackLength=2
[A] HEAD: (standard_gethostsystemname)        FUNCTION
[A] CODE: 
[A] CODE:                                     ;End function
[A] CODE:                                     END
[P] -------------------------------------------------------------------------------------
[L] Read line (src):450:27: "func int getarchitecture():"
[P] Parsed sentence: [Function] kw(func) ty(int) id(getarchitecture) pu(() pu()) pu(:)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[J] Jump event: BlockBeg GlobalBaseLabel=0
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0}  
[A] HEAD: 
[A] HEAD: ;---------------------------------------------------------------------------------------------------
[A] HEAD: ; func int getarchitecture():
[A] HEAD: ;---------------------------------------------------------------------------------------------------
[A] HEAD: 
[F] Stored function address: id=standard_getarchitecture fullname=standard.getarchitecture() address=00000000000001CFh scopedepth=0
[Y] Update OFUN[231]: Address=463
[A] CODE:                                     ;Reserve function stack size
[A] CODE:                                     STACK %TEXTARG0%                                                ;[00000000000001CFh] 00BB 80 %HEXARG0%
[S] Scope open: {Loc:getarchitecture}
[A] DECL:                                     ;Parameters
[D] VAR[10]: name=$result type=int scope={Loc:getarchitecture} address=0 const=no static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.$result index=10 searchindex=0, scope={Loc:getarchitecture}
[A] DECL: <$result>                           PARM REFERENCE                                                  ;Address=<0000000000000000h>
[A] DECL: 
[S] Current scope: {Loc:getarchitecture}, StackLength=3
[P] -------------------------------------------------------------------------------------
[L] Read line (src):451:25: "  return __architecture__"
[P] Parsed sentence: [Return] kw(return) id(__architecture__)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;return __architecture__
[E] ExprCompiler input: [Return] id(__architecture__)
[E] Release all temp variables
[E] Tokenizer ouput: {K}0I{src=__architecture__}
[E] RPN ouput: {K}0I{src=__architecture__}
[E] Expression is computed, not compiled
[E] Token {K}0I{src=__architecture__} --> Operand stack {{K}0I{src=__architecture__}}
[E] Result token: {K}0I{src=__architecture__}
[A] CODE:                                     MVi *<$result>,(I)0                                             ;[00000000000001DAh] 0079 60 0000000000000000 00000000
[A] CODE:                                     RET                                                             ;[00000000000001E9h] 00E6
[P] -------------------------------------------------------------------------------------
[L] Read line (src):452:5: ":func"
[P] Parsed sentence: [EndFunction] kw(:func)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[J] Jump event: BlockEnd GlobalBaseLabel=0
[B] Code block stack updated: Pop --> {Implementation:0:0}  
[S] Scope close: {Loc:getarchitecture}
[J] Solving jump labels for scope depth 2...
[F] Solving forward calls for scope depth 2...
[F] Addr: ScopeDepth=0 Function=standard.$initsuper()
[F] Addr: ScopeDepth=0 Function=standard.getarchitecture()
[F] Addr: ScopeDepth=0 Function=standard.gethostsystem()
[F] Addr: ScopeDepth=0 Function=standard.gethostsystemname()
[F] Addr: ScopeDepth=1 Function=standard.$initstandard()
[F] Call: ScopeDepth=1 Function=standard.$delayedinitstandard()
[S] Current scope: {Pri:main}, StackLength=2
[A] HEAD: (standard_getarchitecture)          FUNCTION
[A] CODE: 
[A] CODE:                                     ;End function
[A] CODE:                                     END
[P] -------------------------------------------------------------------------------------
[L] Read line (src):455:32: "func void panic(string message):"
[P] Parsed sentence: [Function] kw(func) kw(void) id(panic) pu(() ty(string) id(message) pu()) pu(:)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[J] Jump event: BlockBeg GlobalBaseLabel=0
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0}  
[A] HEAD: 
[A] HEAD: ;---------------------------------------------------------------------------------------------------
[A] HEAD: ; func void panic(string message):
[A] HEAD: ;---------------------------------------------------------------------------------------------------
[A] HEAD: 
[F] Stored function address: id=standard_panic fullname=standard.panic(string) address=00000000000001EBh scopedepth=0
[Y] Update OFUN[149]: Address=491
[A] CODE:                                     ;Reserve function stack size
[A] CODE:                                     STACK %TEXTARG0%                                                ;[00000000000001EBh] 00BB 80 %HEXARG0%
[S] Scope open: {Loc:panic}
[A] DECL:                                     ;Parameters
[D] VAR[10]: name=message type=string scope={Loc:panic} address=0 const=yes static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.message index=10 searchindex=0, scope={Loc:panic}
[A] DECL: <message>                           PARM CONST REFERENCE                                            ;Address=<0000000000000000h>
[A] DECL: 
[S] Current scope: {Loc:panic}, StackLength=3
[P] -------------------------------------------------------------------------------------
[L] Read line (src):456:18: "  println(message)"
[P] Parsed sentence: [Expression] id(println) pu(() id(message) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;println(message)
[E] ExprCompiler input: [Expression] id(println) pu(() id(message) pu())
[E] Release all temp variables
[E] Tokenizer ouput: func(standard.println,1) ( {K}ind:(string)message )
[E] RPN ouput: {K}ind:(string)message func(standard.println,1)
[E] .......... Processing token {K}ind:(string)message ..........
[E] Token {K}ind:(string)message --> Operand stack {{K}ind:(string)message}
[E] .......... Processing token func(standard.println,1) ..........
[E] Source used flag set on variable message in scope {Loc:panic}
[A] CODE:                                     PUSHr <message>                                                 ;[00000000000001F6h] 00D5 00 0000000000000000
[A] CODE:                                     SCALL (I)10                                                     ;[0000000000000201h] 00E9 80 0000000A
[E] Token func(standard.println,1) --> Operand stack {}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):457:8: "  exit()"
[P] Parsed sentence: [Expression] id(exit) pu(() pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;exit()
[E] ExprCompiler input: [Expression] id(exit) pu(() pu())
[E] Release all temp variables
[E] Tokenizer ouput: func(standard.exit,0) ( )
[E] RPN ouput: func(standard.exit,0)
[E] .......... Processing token func(standard.exit,0) ..........
[A] CODE:                                     SCALL (I)0                                                      ;[0000000000000208h] 00E9 80 00000000
[E] Token func(standard.exit,0) --> Operand stack {}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):458:5: ":func"
[P] Parsed sentence: [EndFunction] kw(:func)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[J] Jump event: BlockEnd GlobalBaseLabel=0
[B] Code block stack updated: Pop --> {Implementation:0:0}  
[A] CODE:                                     RET                                                             ;[000000000000020Fh] 00E6
[S] Scope close: {Loc:panic}
[J] Solving jump labels for scope depth 2...
[F] Solving forward calls for scope depth 2...
[F] Addr: ScopeDepth=0 Function=standard.$initsuper()
[F] Addr: ScopeDepth=0 Function=standard.getarchitecture()
[F] Addr: ScopeDepth=0 Function=standard.gethostsystem()
[F] Addr: ScopeDepth=0 Function=standard.gethostsystemname()
[F] Addr: ScopeDepth=0 Function=standard.panic(string)
[F] Addr: ScopeDepth=1 Function=standard.$initstandard()
[F] Call: ScopeDepth=1 Function=standard.$delayedinitstandard()
[S] Current scope: {Pri:main}, StackLength=2
[A] HEAD: (standard_panic)                    FUNCTION
[A] CODE: 
[A] CODE:                                     ;End function
[A] CODE:                                     END
[P] -------------------------------------------------------------------------------------
[L] Read line (src):461:50: "func bool read(string filename,ref char[] buffer):"
[P] Parsed sentence: [Function] kw(func) ty(bool) id(read) pu(() ty(string) id(filename) pu(,) kw(ref) ty(char) pu([) pu(]) id(buffer) pu()) pu(:)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[J] Jump event: BlockBeg GlobalBaseLabel=0
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0}  
[A] HEAD: 
[A] HEAD: ;---------------------------------------------------------------------------------------------------
[A] HEAD: ; func bool read(string filename,ref char[] buffer):
[A] HEAD: ;---------------------------------------------------------------------------------------------------
[A] HEAD: 
[F] Stored function address: id=standard_read5 fullname=standard.read(string,char[]) address=0000000000000211h scopedepth=0
[Y] Update OFUN[174]: Address=529
[A] CODE:                                     ;Reserve function stack size
[A] CODE:                                     STACK %TEXTARG0%                                                ;[0000000000000211h] 00BB 80 %HEXARG0%
[S] Scope open: {Loc:read}
[A] DECL:                                     ;Parameters
[D] VAR[10]: name=$result type=bool scope={Loc:read} address=0 const=no static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.$result index=10 searchindex=0, scope={Loc:read}
[A] DECL: <$result>                           PARM REFERENCE                                                  ;Address=<0000000000000000h>
[D] VAR[11]: name=filename type=string scope={Loc:read} address=16 const=yes static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.filename index=11 searchindex=1, scope={Loc:read}
[A] DECL: <filename>                          PARM CONST REFERENCE                                            ;Address=<0000000000000010h>
[D] VAR[12]: name=buffer type=char[] scope={Loc:read} address=32 const=no static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.buffer index=12 searchindex=1, scope={Loc:read}
[A] DECL: <buffer>                            PARM REFERENCE                                                  ;Address=<0000000000000020h>
[A] DECL: 
[S] Current scope: {Loc:read}, StackLength=3
[P] -------------------------------------------------------------------------------------
[L] Read line (src):462:11: "  int hnd=0"
[P] Parsed sentence: [VarDecl] ty(int) id(hnd) op(=) ch(0R)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;int hnd=0
[O] Relocation added: Type=BlkInsideGlo, LocAdr=0000000000000110h
[A] DATA:                                     STORE "hnd"                                                     ;Address=[0000000000000110h]
[D] VAR[13]: name=hnd type=int scope={Loc:read} address=48 const=no static=no parameter=no ref=no temp=no buffstore=yes length=4
[I] VAR: name=standard.hnd index=13 searchindex=3, scope={Loc:read}
[A] CODE: 
[A] CODE:                                     ;int hnd=0
[E] ExprCompiler input: [VarDecl] ch(0R)
[E] Release all temp variables
[E] Tokenizer ouput: {K}0C
[E] RPN ouput: {K}0C
[E] Expression is computed, not compiled
[E] Token {K}0C --> Operand stack {{K}0C}
[E] Result token: {K}0C
[A] CODE:                                     MVi <hnd>,(I)0                                                  ;[000000000000021Ch] 0079 20 0000000000000030 00000000
[A] DECL: <hnd>                               VAR INTEGER                                                     ;Address=<0000000000000030h> = (I)0 { int hnd=0 }
[P] -------------------------------------------------------------------------------------
[L] Read line (src):463:19: "  if(!newhnd(hnd)):"
[P] Parsed sentence: [If] kw(if) pu(() op(!) id(newhnd) pu(() id(hnd) pu()) pu()) pu(:)
[J] Sentence labels: BaseLabel=1 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: FirstCase GlobalBaseLabel=1
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0 If:1:0}  
[A] CODE: 
[A] CODE:                                     ;if(!newhnd(hnd)):
[E] ExprCompiler input: [If] op(!) id(newhnd) pu(() id(hnd) pu())
[E] Release all temp variables
[E] Tokenizer ouput: opr! func(standard.newhnd,1) ( var:(int)hnd )
[E] RPN ouput: var:(int)hnd func(standard.newhnd,1) opr!
[E] .......... Processing token var:(int)hnd ..........
[E] Token var:(int)hnd --> Operand stack {var:(int)hnd}
[E] .......... Processing token func(standard.newhnd,1) ..........
[E] Requested new temp variable for type=bool reference=false kind=regular
[D] VAR[14]: name=$Bol000t type=bool scope={Loc:read} address=52 const=no static=no parameter=no ref=no temp=yes buffstore=yes length=1
[I] VAR: name=standard.$Bol000t index=14 searchindex=0, scope={Loc:read}
[E] New temp variable $Bol000t created (type=bool reference=false kind=regular)
[A] TEMP: <$Bol000t>                          VAR BOOLEAN                                                     ;Address=<0000000000000034h>
[E] Source used flag set on variable hnd in scope {Loc:read}
[A] CODE:                                     REFPU <$Bol000t>                                                ;[000000000000022Bh] 00D6 00 0000000000000034
[A] CODE:                                     REFPU <hnd>                                                     ;[0000000000000236h] 00D6 00 0000000000000030
[A] CODE:                                     SCALL (I)17                                                     ;[0000000000000241h] 00E9 80 00000011
[E] Token func(standard.newhnd,1) --> Operand stack {var:(bool)$Bol000t}
[E] .......... Processing token opr! ..........
[E] Temp variable $Bol000t released
[E] Source used flag set on variable $Bol000t in scope {Loc:read}
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[A] CODE:                                     LNOT <$Bol000t>,<$Bol000t>                                      ;[0000000000000248h] 0031 00 0000000000000034 0000000000000034
[E] Token opr! --> Operand stack {var:(bool)$Bol000t}
[E] Source used flag set on variable $Bol000t in scope {Loc:read}
[E] Result token: var:(bool)$Bol000t
[J] Stored jump origin: scopedepth=2 label=000001ifs-cond1 codeadr=0000000000000266h instadr=000000000000025Bh
[A] CODE:                                     JMPFL <$Bol000t>,{000001ifs-cond1}                              ;[000000000000025Bh] 0135 20 0000000000000034 {000001ifs-cond1}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):464:16: "    return false"
[P] Parsed sentence: [Return] kw(return) bo(false)
[J] Sentence labels: BaseLabel=1 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;return false
[E] ExprCompiler input: [Return] bo(false)
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: {K}0B
[E] RPN ouput: {K}0B
[E] Expression is computed, not compiled
[E] Token {K}0B --> Operand stack {{K}0B}
[E] Result token: {K}0B
[A] CODE:                                     MVb *<$result>,(B)false                                         ;[000000000000026Eh] 0076 60 0000000000000000 00
[A] CODE:                                     RET                                                             ;[000000000000027Ah] 00E6
[P] -------------------------------------------------------------------------------------
[L] Read line (src):465:5: "  :if"
[P] Parsed sentence: [EndIf] kw(:if)
[J] Sentence labels: BaseLabel=1 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: EndCase GlobalBaseLabel=1
[B] Code block stack updated: Pop --> {Implementation:0:0 Local:0:0}  
[A] CODE: 
[A] CODE:                                     ;:if
[J] Stored jump destination: scopedepth=2 label=000001ifs-cond1 address=000000000000027Ch
[J] Stored jump destination: scopedepth=2 label=000001ifs-exit address=000000000000027Ch
[P] -------------------------------------------------------------------------------------
[L] Read line (src):466:46: "  if(!openread(hnd,filename,filemode.binary)):"
[P] Parsed sentence: [If] kw(if) pu(() op(!) id(openread) pu(() id(hnd) pu(,) id(filename) pu(,) ty(filemode) op(.) id(binary) pu()) pu()) pu(:)
[J] Sentence labels: BaseLabel=2 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: FirstCase GlobalBaseLabel=2
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0 If:2:0}  
[A] CODE: 
[A] CODE:                                     ;if(!openread(hnd,filename,filemode.binary)):
[E] ExprCompiler input: [If] op(!) id(openread) pu(() id(hnd) pu(,) id(filename) pu(,) ty(filemode) op(.) id(binary) pu())
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: opr! func(standard.openread,3) ( var:(int)hnd , {K}ind:(string)filename , {K}Enu:filemode:1 )
[E] RPN ouput: var:(int)hnd {K}ind:(string)filename {K}Enu:filemode:1 func(standard.openread,3) opr!
[E] .......... Processing token var:(int)hnd ..........
[E] Token var:(int)hnd --> Operand stack {var:(int)hnd}
[E] .......... Processing token {K}ind:(string)filename ..........
[E] Token {K}ind:(string)filename --> Operand stack {var:(int)hnd {K}ind:(string)filename}
[E] .......... Processing token {K}Enu:filemode:1 ..........
[E] Token {K}Enu:filemode:1 --> Operand stack {var:(int)hnd {K}ind:(string)filename {K}Enu:filemode:1}
[E] .......... Processing token func(standard.openread,3) ..........
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[E] Source used flag set on variable hnd in scope {Loc:read}
[E] Source used flag set on variable filename in scope {Loc:read}
[A] CODE: {000001ifs-exit}:                   
[A] CODE: {000001ifs-cond1}:                  REFPU <$Bol000t>                                                ;[000000000000027Ch] 00D6 00 0000000000000034
[A] CODE:                                     PUSHi <hnd>                                                     ;[0000000000000287h] 00D2 00 0000000000000030
[A] CODE:                                     PUSHr <filename>                                                ;[0000000000000292h] 00D5 00 0000000000000010
[A] CODE:                                     PUSHi (I)1                                                      ;[000000000000029Dh] 00D2 80 00000001
[A] CODE:                                     SCALL (I)19                                                     ;[00000000000002A4h] 00E9 80 00000013
[E] Token func(standard.openread,3) --> Operand stack {var:(bool)$Bol000t}
[E] .......... Processing token opr! ..........
[E] Temp variable $Bol000t released
[E] Source used flag set on variable $Bol000t in scope {Loc:read}
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[A] CODE:                                     LNOT <$Bol000t>,<$Bol000t>                                      ;[00000000000002ABh] 0031 00 0000000000000034 0000000000000034
[E] Token opr! --> Operand stack {var:(bool)$Bol000t}
[E] Source used flag set on variable $Bol000t in scope {Loc:read}
[E] Result token: var:(bool)$Bol000t
[J] Stored jump origin: scopedepth=2 label=000002ifs-cond1 codeadr=00000000000002C9h instadr=00000000000002BEh
[A] CODE:                                     JMPFL <$Bol000t>,{000002ifs-cond1}                              ;[00000000000002BEh] 0135 20 0000000000000034 {000002ifs-cond1}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):467:16: "    return false"
[P] Parsed sentence: [Return] kw(return) bo(false)
[J] Sentence labels: BaseLabel=2 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;return false
[E] ExprCompiler input: [Return] bo(false)
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: {K}0B
[E] RPN ouput: {K}0B
[E] Expression is computed, not compiled
[E] Token {K}0B --> Operand stack {{K}0B}
[E] Result token: {K}0B
[A] CODE:                                     MVb *<$result>,(B)false                                         ;[00000000000002D1h] 0076 60 0000000000000000 00
[A] CODE:                                     RET                                                             ;[00000000000002DDh] 00E6
[P] -------------------------------------------------------------------------------------
[L] Read line (src):468:5: "  :if"
[P] Parsed sentence: [EndIf] kw(:if)
[J] Sentence labels: BaseLabel=2 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: EndCase GlobalBaseLabel=2
[B] Code block stack updated: Pop --> {Implementation:0:0 Local:0:0}  
[A] CODE: 
[A] CODE:                                     ;:if
[J] Stored jump destination: scopedepth=2 label=000002ifs-cond1 address=00000000000002DFh
[J] Stored jump destination: scopedepth=2 label=000002ifs-exit address=00000000000002DFh
[P] -------------------------------------------------------------------------------------
[L] Read line (src):469:24: "  if(!read(hnd,buffer)):"
[P] Parsed sentence: [If] kw(if) pu(() op(!) id(read) pu(() id(hnd) pu(,) id(buffer) pu()) pu()) pu(:)
[J] Sentence labels: BaseLabel=3 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: FirstCase GlobalBaseLabel=3
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0 If:3:0}  
[A] CODE: 
[A] CODE:                                     ;if(!read(hnd,buffer)):
[E] ExprCompiler input: [If] op(!) id(read) pu(() id(hnd) pu(,) id(buffer) pu())
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: opr! func(standard.read,2) ( var:(int)hnd , ind:(char[])buffer )
[E] RPN ouput: var:(int)hnd ind:(char[])buffer func(standard.read,2) opr!
[E] .......... Processing token var:(int)hnd ..........
[E] Token var:(int)hnd --> Operand stack {var:(int)hnd}
[E] .......... Processing token ind:(char[])buffer ..........
[E] Token ind:(char[])buffer --> Operand stack {var:(int)hnd ind:(char[])buffer}
[E] .......... Processing token func(standard.read,2) ..........
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[E] Source used flag set on variable hnd in scope {Loc:read}
[E] Source used flag set on variable buffer in scope {Loc:read}
[A] CODE: {000002ifs-exit}:                   
[A] CODE: {000002ifs-cond1}:                  REFPU <$Bol000t>                                                ;[00000000000002DFh] 00D6 00 0000000000000034
[A] CODE:                                     PUSHi <hnd>                                                     ;[00000000000002EAh] 00D2 00 0000000000000030
[A] CODE:                                     PUSHr <buffer>                                                  ;[00000000000002F5h] 00D5 00 0000000000000020
[A] CODE:                                     SCALL (I)23                                                     ;[0000000000000300h] 00E9 80 00000017
[E] Token func(standard.read,2) --> Operand stack {var:(bool)$Bol000t}
[E] .......... Processing token opr! ..........
[E] Temp variable $Bol000t released
[E] Source used flag set on variable $Bol000t in scope {Loc:read}
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[A] CODE:                                     LNOT <$Bol000t>,<$Bol000t>                                      ;[0000000000000307h] 0031 00 0000000000000034 0000000000000034
[E] Token opr! --> Operand stack {var:(bool)$Bol000t}
[E] Source used flag set on variable $Bol000t in scope {Loc:read}
[E] Result token: var:(bool)$Bol000t
[J] Stored jump origin: scopedepth=2 label=000003ifs-cond1 codeadr=0000000000000325h instadr=000000000000031Ah
[A] CODE:                                     JMPFL <$Bol000t>,{000003ifs-cond1}                              ;[000000000000031Ah] 0135 20 0000000000000034 {000003ifs-cond1}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):470:16: "    return false"
[P] Parsed sentence: [Return] kw(return) bo(false)
[J] Sentence labels: BaseLabel=3 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;return false
[E] ExprCompiler input: [Return] bo(false)
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: {K}0B
[E] RPN ouput: {K}0B
[E] Expression is computed, not compiled
[E] Token {K}0B --> Operand stack {{K}0B}
[E] Result token: {K}0B
[A] CODE:                                     MVb *<$result>,(B)false                                         ;[000000000000032Dh] 0076 60 0000000000000000 00
[A] CODE:                                     RET                                                             ;[0000000000000339h] 00E6
[P] -------------------------------------------------------------------------------------
[L] Read line (src):471:5: "  :if"
[P] Parsed sentence: [EndIf] kw(:if)
[J] Sentence labels: BaseLabel=3 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: EndCase GlobalBaseLabel=3
[B] Code block stack updated: Pop --> {Implementation:0:0 Local:0:0}  
[A] CODE: 
[A] CODE:                                     ;:if
[J] Stored jump destination: scopedepth=2 label=000003ifs-cond1 address=000000000000033Bh
[J] Stored jump destination: scopedepth=2 label=000003ifs-exit address=000000000000033Bh
[P] -------------------------------------------------------------------------------------
[L] Read line (src):472:22: "  if(!closefile(hnd)):"
[P] Parsed sentence: [If] kw(if) pu(() op(!) id(closefile) pu(() id(hnd) pu()) pu()) pu(:)
[J] Sentence labels: BaseLabel=4 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: FirstCase GlobalBaseLabel=4
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0 If:4:0}  
[A] CODE: 
[A] CODE:                                     ;if(!closefile(hnd)):
[E] ExprCompiler input: [If] op(!) id(closefile) pu(() id(hnd) pu())
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: opr! func(standard.closefile,1) ( var:(int)hnd )
[E] RPN ouput: var:(int)hnd func(standard.closefile,1) opr!
[E] .......... Processing token var:(int)hnd ..........
[E] Token var:(int)hnd --> Operand stack {var:(int)hnd}
[E] .......... Processing token func(standard.closefile,1) ..........
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[E] Source used flag set on variable hnd in scope {Loc:read}
[A] CODE: {000003ifs-exit}:                   
[A] CODE: {000003ifs-cond1}:                  REFPU <$Bol000t>                                                ;[000000000000033Bh] 00D6 00 0000000000000034
[A] CODE:                                     PUSHi <hnd>                                                     ;[0000000000000346h] 00D2 00 0000000000000030
[A] CODE:                                     SCALL (I)30                                                     ;[0000000000000351h] 00E9 80 0000001E
[E] Token func(standard.closefile,1) --> Operand stack {var:(bool)$Bol000t}
[E] .......... Processing token opr! ..........
[E] Temp variable $Bol000t released
[E] Source used flag set on variable $Bol000t in scope {Loc:read}
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[A] CODE:                                     LNOT <$Bol000t>,<$Bol000t>                                      ;[0000000000000358h] 0031 00 0000000000000034 0000000000000034
[E] Token opr! --> Operand stack {var:(bool)$Bol000t}
[E] Source used flag set on variable $Bol000t in scope {Loc:read}
[E] Result token: var:(bool)$Bol000t
[J] Stored jump origin: scopedepth=2 label=000004ifs-cond1 codeadr=0000000000000376h instadr=000000000000036Bh
[A] CODE:                                     JMPFL <$Bol000t>,{000004ifs-cond1}                              ;[000000000000036Bh] 0135 20 0000000000000034 {000004ifs-cond1}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):473:16: "    return false"
[P] Parsed sentence: [Return] kw(return) bo(false)
[J] Sentence labels: BaseLabel=4 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;return false
[E] ExprCompiler input: [Return] bo(false)
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: {K}0B
[E] RPN ouput: {K}0B
[E] Expression is computed, not compiled
[E] Token {K}0B --> Operand stack {{K}0B}
[E] Result token: {K}0B
[A] CODE:                                     MVb *<$result>,(B)false                                         ;[000000000000037Eh] 0076 60 0000000000000000 00
[A] CODE:                                     RET                                                             ;[000000000000038Ah] 00E6
[P] -------------------------------------------------------------------------------------
[L] Read line (src):474:5: "  :if"
[P] Parsed sentence: [EndIf] kw(:if)
[J] Sentence labels: BaseLabel=4 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: EndCase GlobalBaseLabel=4
[B] Code block stack updated: Pop --> {Implementation:0:0 Local:0:0}  
[A] CODE: 
[A] CODE:                                     ;:if
[J] Stored jump destination: scopedepth=2 label=000004ifs-cond1 address=000000000000038Ch
[J] Stored jump destination: scopedepth=2 label=000004ifs-exit address=000000000000038Ch
[P] -------------------------------------------------------------------------------------
[L] Read line (src):475:14: "  freehnd(hnd)"
[P] Parsed sentence: [Expression] id(freehnd) pu(() id(hnd) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;freehnd(hnd)
[E] ExprCompiler input: [Expression] id(freehnd) pu(() id(hnd) pu())
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: func(standard.freehnd,1) ( var:(int)hnd )
[E] RPN ouput: var:(int)hnd func(standard.freehnd,1)
[E] .......... Processing token var:(int)hnd ..........
[E] Token var:(int)hnd --> Operand stack {var:(int)hnd}
[E] .......... Processing token func(standard.freehnd,1) ..........
[E] Source used flag set on variable hnd in scope {Loc:read}
[A] CODE: {000004ifs-exit}:                   
[A] CODE: {000004ifs-cond1}:                  PUSHi <hnd>                                                     ;[000000000000038Ch] 00D2 00 0000000000000030
[A] CODE:                                     SCALL (I)18                                                     ;[0000000000000397h] 00E9 80 00000012
[E] Token func(standard.freehnd,1) --> Operand stack {}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):476:13: "  return true"
[P] Parsed sentence: [Return] kw(return) bo(true)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;return true
[E] ExprCompiler input: [Return] bo(true)
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: {K}1B
[E] RPN ouput: {K}1B
[E] Expression is computed, not compiled
[E] Token {K}1B --> Operand stack {{K}1B}
[E] Result token: {K}1B
[A] CODE:                                     MVb *<$result>,(B)true                                          ;[000000000000039Eh] 0076 60 0000000000000000 01
[A] CODE:                                     RET                                                             ;[00000000000003AAh] 00E6
[P] -------------------------------------------------------------------------------------
[L] Read line (src):477:5: ":func"
[P] Parsed sentence: [EndFunction] kw(:func)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[J] Jump event: BlockEnd GlobalBaseLabel=4
[B] Code block stack updated: Pop --> {Implementation:0:0}  
[S] Scope close: {Loc:read}
[J] Solving jump labels for scope depth 2...
[J] Solved jump: scopedepth=2 codeadr=0000000000000266h instadr=000000000000025Bh destadr=000000000000027Ch relative=0000000000000021h label=000001ifs-cond1
[J] Solved jump: scopedepth=2 codeadr=00000000000002C9h instadr=00000000000002BEh destadr=00000000000002DFh relative=0000000000000021h label=000002ifs-cond1
[J] Solved jump: scopedepth=2 codeadr=0000000000000325h instadr=000000000000031Ah destadr=000000000000033Bh relative=0000000000000021h label=000003ifs-cond1
[J] Solved jump: scopedepth=2 codeadr=0000000000000376h instadr=000000000000036Bh destadr=000000000000038Ch relative=0000000000000021h label=000004ifs-cond1
[A] FOOT: 
[A] FOOT: ; Jump addresses on scope {Loc:read} (depth=2):
[A] FOOT: ; [000000000000027Ch] = {000001ifs-cond1}
[A] FOOT: ; [000000000000027Ch] = {000001ifs-exit}
[A] FOOT: ; [00000000000002DFh] = {000002ifs-cond1}
[A] FOOT: ; [00000000000002DFh] = {000002ifs-exit}
[A] FOOT: ; [000000000000033Bh] = {000003ifs-cond1}
[A] FOOT: ; [000000000000033Bh] = {000003ifs-exit}
[A] FOOT: ; [000000000000038Ch] = {000004ifs-cond1}
[A] FOOT: ; [000000000000038Ch] = {000004ifs-exit}
[F] Solving forward calls for scope depth 2...
[F] Addr: ScopeDepth=0 Function=standard.$initsuper()
[F] Addr: ScopeDepth=0 Function=standard.getarchitecture()
[F] Addr: ScopeDepth=0 Function=standard.gethostsystem()
[F] Addr: ScopeDepth=0 Function=standard.gethostsystemname()
[F] Addr: ScopeDepth=0 Function=standard.panic(string)
[F] Addr: ScopeDepth=0 Function=standard.read(string,char[])
[F] Addr: ScopeDepth=1 Function=standard.$initstandard()
[F] Call: ScopeDepth=1 Function=standard.$delayedinitstandard()
[S] Current scope: {Pri:main}, StackLength=2
[A] HEAD: (standard_read5)                    FUNCTION
[A] CODE: 
[A] CODE:                                     ;End function
[A] CODE:                                     END
[P] -------------------------------------------------------------------------------------
[L] Read line (src):480:47: "func bool write(string filename,char[] buffer):"
[P] Parsed sentence: [Function] kw(func) ty(bool) id(write) pu(() ty(string) id(filename) pu(,) ty(char) pu([) pu(]) id(buffer) pu()) pu(:)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[J] Jump event: BlockBeg GlobalBaseLabel=0
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0}  
[A] HEAD: 
[A] HEAD: ;---------------------------------------------------------------------------------------------------
[A] HEAD: ; func bool write(string filename,char[] buffer):
[A] HEAD: ;---------------------------------------------------------------------------------------------------
[A] HEAD: 
[F] Stored function address: id=standard_write5 fullname=standard.write(string,char[]) address=00000000000003ACh scopedepth=0
[Y] Update OFUN[175]: Address=940
[A] CODE:                                     ;Reserve function stack size
[A] CODE:                                     STACK %TEXTARG0%                                                ;[00000000000003ACh] 00BB 80 %HEXARG0%
[S] Scope open: {Loc:write}
[A] DECL:                                     ;Parameters
[D] VAR[10]: name=$result type=bool scope={Loc:write} address=0 const=no static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.$result index=10 searchindex=0, scope={Loc:write}
[A] DECL: <$result>                           PARM REFERENCE                                                  ;Address=<0000000000000000h>
[D] VAR[11]: name=filename type=string scope={Loc:write} address=16 const=yes static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.filename index=11 searchindex=1, scope={Loc:write}
[A] DECL: <filename>                          PARM CONST REFERENCE                                            ;Address=<0000000000000010h>
[D] VAR[12]: name=buffer type=char[] scope={Loc:write} address=32 const=yes static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.buffer index=12 searchindex=1, scope={Loc:write}
[A] DECL: <buffer>                            PARM CONST REFERENCE                                            ;Address=<0000000000000020h>
[A] DECL: 
[S] Current scope: {Loc:write}, StackLength=3
[P] -------------------------------------------------------------------------------------
[L] Read line (src):481:11: "  int hnd=0"
[P] Parsed sentence: [VarDecl] ty(int) id(hnd) op(=) ch(0R)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;int hnd=0
[O] Relocation added: Type=BlkInsideGlo, LocAdr=0000000000000114h
[A] DATA:                                     STORE "hnd"                                                     ;Address=[0000000000000114h]
[D] VAR[13]: name=hnd type=int scope={Loc:write} address=48 const=no static=no parameter=no ref=no temp=no buffstore=yes length=4
[I] VAR: name=standard.hnd index=13 searchindex=3, scope={Loc:write}
[A] CODE: 
[A] CODE:                                     ;int hnd=0
[E] ExprCompiler input: [VarDecl] ch(0R)
[E] Release all temp variables
[E] Tokenizer ouput: {K}0C
[E] RPN ouput: {K}0C
[E] Expression is computed, not compiled
[E] Token {K}0C --> Operand stack {{K}0C}
[E] Result token: {K}0C
[A] CODE:                                     MVi <hnd>,(I)0                                                  ;[00000000000003B7h] 0079 20 0000000000000030 00000000
[A] DECL: <hnd>                               VAR INTEGER                                                     ;Address=<0000000000000030h> = (I)0 { int hnd=0 }
[P] -------------------------------------------------------------------------------------
[L] Read line (src):482:19: "  if(!newhnd(hnd)):"
[P] Parsed sentence: [If] kw(if) pu(() op(!) id(newhnd) pu(() id(hnd) pu()) pu()) pu(:)
[J] Sentence labels: BaseLabel=1 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: FirstCase GlobalBaseLabel=1
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0 If:1:0}  
[A] CODE: 
[A] CODE:                                     ;if(!newhnd(hnd)):
[E] ExprCompiler input: [If] op(!) id(newhnd) pu(() id(hnd) pu())
[E] Release all temp variables
[E] Tokenizer ouput: opr! func(standard.newhnd,1) ( var:(int)hnd )
[E] RPN ouput: var:(int)hnd func(standard.newhnd,1) opr!
[E] .......... Processing token var:(int)hnd ..........
[E] Token var:(int)hnd --> Operand stack {var:(int)hnd}
[E] .......... Processing token func(standard.newhnd,1) ..........
[E] Requested new temp variable for type=bool reference=false kind=regular
[D] VAR[14]: name=$Bol000t type=bool scope={Loc:write} address=52 const=no static=no parameter=no ref=no temp=yes buffstore=yes length=1
[I] VAR: name=standard.$Bol000t index=14 searchindex=0, scope={Loc:write}
[E] New temp variable $Bol000t created (type=bool reference=false kind=regular)
[A] TEMP: <$Bol000t>                          VAR BOOLEAN                                                     ;Address=<0000000000000034h>
[E] Source used flag set on variable hnd in scope {Loc:write}
[A] CODE:                                     REFPU <$Bol000t>                                                ;[00000000000003C6h] 00D6 00 0000000000000034
[A] CODE:                                     REFPU <hnd>                                                     ;[00000000000003D1h] 00D6 00 0000000000000030
[A] CODE:                                     SCALL (I)17                                                     ;[00000000000003DCh] 00E9 80 00000011
[E] Token func(standard.newhnd,1) --> Operand stack {var:(bool)$Bol000t}
[E] .......... Processing token opr! ..........
[E] Temp variable $Bol000t released
[E] Source used flag set on variable $Bol000t in scope {Loc:write}
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[A] CODE:                                     LNOT <$Bol000t>,<$Bol000t>                                      ;[00000000000003E3h] 0031 00 0000000000000034 0000000000000034
[E] Token opr! --> Operand stack {var:(bool)$Bol000t}
[E] Source used flag set on variable $Bol000t in scope {Loc:write}
[E] Result token: var:(bool)$Bol000t
[J] Stored jump origin: scopedepth=2 label=000001ifs-cond1 codeadr=0000000000000401h instadr=00000000000003F6h
[A] CODE:                                     JMPFL <$Bol000t>,{000001ifs-cond1}                              ;[00000000000003F6h] 0135 20 0000000000000034 {000001ifs-cond1}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):483:16: "    return false"
[P] Parsed sentence: [Return] kw(return) bo(false)
[J] Sentence labels: BaseLabel=1 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;return false
[E] ExprCompiler input: [Return] bo(false)
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: {K}0B
[E] RPN ouput: {K}0B
[E] Expression is computed, not compiled
[E] Token {K}0B --> Operand stack {{K}0B}
[E] Result token: {K}0B
[A] CODE:                                     MVb *<$result>,(B)false                                         ;[0000000000000409h] 0076 60 0000000000000000 00
[A] CODE:                                     RET                                                             ;[0000000000000415h] 00E6
[P] -------------------------------------------------------------------------------------
[L] Read line (src):484:5: "  :if"
[P] Parsed sentence: [EndIf] kw(:if)
[J] Sentence labels: BaseLabel=1 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: EndCase GlobalBaseLabel=1
[B] Code block stack updated: Pop --> {Implementation:0:0 Local:0:0}  
[A] CODE: 
[A] CODE:                                     ;:if
[J] Stored jump destination: scopedepth=2 label=000001ifs-cond1 address=0000000000000417h
[J] Stored jump destination: scopedepth=2 label=000001ifs-exit address=0000000000000417h
[P] -------------------------------------------------------------------------------------
[L] Read line (src):485:47: "  if(!openwrite(hnd,filename,filemode.binary)):"
[P] Parsed sentence: [If] kw(if) pu(() op(!) id(openwrite) pu(() id(hnd) pu(,) id(filename) pu(,) ty(filemode) op(.) id(binary) pu()) pu()) pu(:)
[J] Sentence labels: BaseLabel=2 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: FirstCase GlobalBaseLabel=2
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0 If:2:0}  
[A] CODE: 
[A] CODE:                                     ;if(!openwrite(hnd,filename,filemode.binary)):
[E] ExprCompiler input: [If] op(!) id(openwrite) pu(() id(hnd) pu(,) id(filename) pu(,) ty(filemode) op(.) id(binary) pu())
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: opr! func(standard.openwrite,3) ( var:(int)hnd , {K}ind:(string)filename , {K}Enu:filemode:1 )
[E] RPN ouput: var:(int)hnd {K}ind:(string)filename {K}Enu:filemode:1 func(standard.openwrite,3) opr!
[E] .......... Processing token var:(int)hnd ..........
[E] Token var:(int)hnd --> Operand stack {var:(int)hnd}
[E] .......... Processing token {K}ind:(string)filename ..........
[E] Token {K}ind:(string)filename --> Operand stack {var:(int)hnd {K}ind:(string)filename}
[E] .......... Processing token {K}Enu:filemode:1 ..........
[E] Token {K}Enu:filemode:1 --> Operand stack {var:(int)hnd {K}ind:(string)filename {K}Enu:filemode:1}
[E] .......... Processing token func(standard.openwrite,3) ..........
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[E] Source used flag set on variable hnd in scope {Loc:write}
[E] Source used flag set on variable filename in scope {Loc:write}
[A] CODE: {000001ifs-exit}:                   
[A] CODE: {000001ifs-cond1}:                  REFPU <$Bol000t>                                                ;[0000000000000417h] 00D6 00 0000000000000034
[A] CODE:                                     PUSHi <hnd>                                                     ;[0000000000000422h] 00D2 00 0000000000000030
[A] CODE:                                     PUSHr <filename>                                                ;[000000000000042Dh] 00D5 00 0000000000000010
[A] CODE:                                     PUSHi (I)1                                                      ;[0000000000000438h] 00D2 80 00000001
[A] CODE:                                     SCALL (I)20                                                     ;[000000000000043Fh] 00E9 80 00000014
[E] Token func(standard.openwrite,3) --> Operand stack {var:(bool)$Bol000t}
[E] .......... Processing token opr! ..........
[E] Temp variable $Bol000t released
[E] Source used flag set on variable $Bol000t in scope {Loc:write}
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[A] CODE:                                     LNOT <$Bol000t>,<$Bol000t>                                      ;[0000000000000446h] 0031 00 0000000000000034 0000000000000034
[E] Token opr! --> Operand stack {var:(bool)$Bol000t}
[E] Source used flag set on variable $Bol000t in scope {Loc:write}
[E] Result token: var:(bool)$Bol000t
[J] Stored jump origin: scopedepth=2 label=000002ifs-cond1 codeadr=0000000000000464h instadr=0000000000000459h
[A] CODE:                                     JMPFL <$Bol000t>,{000002ifs-cond1}                              ;[0000000000000459h] 0135 20 0000000000000034 {000002ifs-cond1}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):486:16: "    return false"
[P] Parsed sentence: [Return] kw(return) bo(false)
[J] Sentence labels: BaseLabel=2 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;return false
[E] ExprCompiler input: [Return] bo(false)
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: {K}0B
[E] RPN ouput: {K}0B
[E] Expression is computed, not compiled
[E] Token {K}0B --> Operand stack {{K}0B}
[E] Result token: {K}0B
[A] CODE:                                     MVb *<$result>,(B)false                                         ;[000000000000046Ch] 0076 60 0000000000000000 00
[A] CODE:                                     RET                                                             ;[0000000000000478h] 00E6
[P] -------------------------------------------------------------------------------------
[L] Read line (src):487:5: "  :if"
[P] Parsed sentence: [EndIf] kw(:if)
[J] Sentence labels: BaseLabel=2 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: EndCase GlobalBaseLabel=2
[B] Code block stack updated: Pop --> {Implementation:0:0 Local:0:0}  
[A] CODE: 
[A] CODE:                                     ;:if
[J] Stored jump destination: scopedepth=2 label=000002ifs-cond1 address=000000000000047Ah
[J] Stored jump destination: scopedepth=2 label=000002ifs-exit address=000000000000047Ah
[P] -------------------------------------------------------------------------------------
[L] Read line (src):488:25: "  if(!write(hnd,buffer)):"
[P] Parsed sentence: [If] kw(if) pu(() op(!) id(write) pu(() id(hnd) pu(,) id(buffer) pu()) pu()) pu(:)
[J] Sentence labels: BaseLabel=3 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: FirstCase GlobalBaseLabel=3
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0 If:3:0}  
[A] CODE: 
[A] CODE:                                     ;if(!write(hnd,buffer)):
[E] ExprCompiler input: [If] op(!) id(write) pu(() id(hnd) pu(,) id(buffer) pu())
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: opr! func(standard.write,2) ( var:(int)hnd , {K}ind:(char[])buffer )
[E] RPN ouput: var:(int)hnd {K}ind:(char[])buffer func(standard.write,2) opr!
[E] .......... Processing token var:(int)hnd ..........
[E] Token var:(int)hnd --> Operand stack {var:(int)hnd}
[E] .......... Processing token {K}ind:(char[])buffer ..........
[E] Token {K}ind:(char[])buffer --> Operand stack {var:(int)hnd {K}ind:(char[])buffer}
[E] .......... Processing token func(standard.write,2) ..........
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[E] Source used flag set on variable hnd in scope {Loc:write}
[E] Source used flag set on variable buffer in scope {Loc:write}
[A] CODE: {000002ifs-exit}:                   
[A] CODE: {000002ifs-cond1}:                  REFPU <$Bol000t>                                                ;[000000000000047Ah] 00D6 00 0000000000000034
[A] CODE:                                     PUSHi <hnd>                                                     ;[0000000000000485h] 00D2 00 0000000000000030
[A] CODE:                                     PUSHr <buffer>                                                  ;[0000000000000490h] 00D5 00 0000000000000020
[A] CODE:                                     SCALL (I)24                                                     ;[000000000000049Bh] 00E9 80 00000018
[E] Token func(standard.write,2) --> Operand stack {var:(bool)$Bol000t}
[E] .......... Processing token opr! ..........
[E] Temp variable $Bol000t released
[E] Source used flag set on variable $Bol000t in scope {Loc:write}
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[A] CODE:                                     LNOT <$Bol000t>,<$Bol000t>                                      ;[00000000000004A2h] 0031 00 0000000000000034 0000000000000034
[E] Token opr! --> Operand stack {var:(bool)$Bol000t}
[E] Source used flag set on variable $Bol000t in scope {Loc:write}
[E] Result token: var:(bool)$Bol000t
[J] Stored jump origin: scopedepth=2 label=000003ifs-cond1 codeadr=00000000000004C0h instadr=00000000000004B5h
[A] CODE:                                     JMPFL <$Bol000t>,{000003ifs-cond1}                              ;[00000000000004B5h] 0135 20 0000000000000034 {000003ifs-cond1}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):489:16: "    return false"
[P] Parsed sentence: [Return] kw(return) bo(false)
[J] Sentence labels: BaseLabel=3 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;return false
[E] ExprCompiler input: [Return] bo(false)
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: {K}0B
[E] RPN ouput: {K}0B
[E] Expression is computed, not compiled
[E] Token {K}0B --> Operand stack {{K}0B}
[E] Result token: {K}0B
[A] CODE:                                     MVb *<$result>,(B)false                                         ;[00000000000004C8h] 0076 60 0000000000000000 00
[A] CODE:                                     RET                                                             ;[00000000000004D4h] 00E6
[P] -------------------------------------------------------------------------------------
[L] Read line (src):490:5: "  :if"
[P] Parsed sentence: [EndIf] kw(:if)
[J] Sentence labels: BaseLabel=3 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: EndCase GlobalBaseLabel=3
[B] Code block stack updated: Pop --> {Implementation:0:0 Local:0:0}  
[A] CODE: 
[A] CODE:                                     ;:if
[J] Stored jump destination: scopedepth=2 label=000003ifs-cond1 address=00000000000004D6h
[J] Stored jump destination: scopedepth=2 label=000003ifs-exit address=00000000000004D6h
[P] -------------------------------------------------------------------------------------
[L] Read line (src):491:22: "  if(!closefile(hnd)):"
[P] Parsed sentence: [If] kw(if) pu(() op(!) id(closefile) pu(() id(hnd) pu()) pu()) pu(:)
[J] Sentence labels: BaseLabel=4 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: FirstCase GlobalBaseLabel=4
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0 If:4:0}  
[A] CODE: 
[A] CODE:                                     ;if(!closefile(hnd)):
[E] ExprCompiler input: [If] op(!) id(closefile) pu(() id(hnd) pu())
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: opr! func(standard.closefile,1) ( var:(int)hnd )
[E] RPN ouput: var:(int)hnd func(standard.closefile,1) opr!
[E] .......... Processing token var:(int)hnd ..........
[E] Token var:(int)hnd --> Operand stack {var:(int)hnd}
[E] .......... Processing token func(standard.closefile,1) ..........
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[E] Source used flag set on variable hnd in scope {Loc:write}
[A] CODE: {000003ifs-exit}:                   
[A] CODE: {000003ifs-cond1}:                  REFPU <$Bol000t>                                                ;[00000000000004D6h] 00D6 00 0000000000000034
[A] CODE:                                     PUSHi <hnd>                                                     ;[00000000000004E1h] 00D2 00 0000000000000030
[A] CODE:                                     SCALL (I)30                                                     ;[00000000000004ECh] 00E9 80 0000001E
[E] Token func(standard.closefile,1) --> Operand stack {var:(bool)$Bol000t}
[E] .......... Processing token opr! ..........
[E] Temp variable $Bol000t released
[E] Source used flag set on variable $Bol000t in scope {Loc:write}
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[A] CODE:                                     LNOT <$Bol000t>,<$Bol000t>                                      ;[00000000000004F3h] 0031 00 0000000000000034 0000000000000034
[E] Token opr! --> Operand stack {var:(bool)$Bol000t}
[E] Source used flag set on variable $Bol000t in scope {Loc:write}
[E] Result token: var:(bool)$Bol000t
[J] Stored jump origin: scopedepth=2 label=000004ifs-cond1 codeadr=0000000000000511h instadr=0000000000000506h
[A] CODE:                                     JMPFL <$Bol000t>,{000004ifs-cond1}                              ;[0000000000000506h] 0135 20 0000000000000034 {000004ifs-cond1}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):492:16: "    return false"
[P] Parsed sentence: [Return] kw(return) bo(false)
[J] Sentence labels: BaseLabel=4 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;return false
[E] ExprCompiler input: [Return] bo(false)
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: {K}0B
[E] RPN ouput: {K}0B
[E] Expression is computed, not compiled
[E] Token {K}0B --> Operand stack {{K}0B}
[E] Result token: {K}0B
[A] CODE:                                     MVb *<$result>,(B)false                                         ;[0000000000000519h] 0076 60 0000000000000000 00
[A] CODE:                                     RET                                                             ;[0000000000000525h] 00E6
[P] -------------------------------------------------------------------------------------
[L] Read line (src):493:5: "  :if"
[P] Parsed sentence: [EndIf] kw(:if)
[J] Sentence labels: BaseLabel=4 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: EndCase GlobalBaseLabel=4
[B] Code block stack updated: Pop --> {Implementation:0:0 Local:0:0}  
[A] CODE: 
[A] CODE:                                     ;:if
[J] Stored jump destination: scopedepth=2 label=000004ifs-cond1 address=0000000000000527h
[J] Stored jump destination: scopedepth=2 label=000004ifs-exit address=0000000000000527h
[P] -------------------------------------------------------------------------------------
[L] Read line (src):494:14: "  freehnd(hnd)"
[P] Parsed sentence: [Expression] id(freehnd) pu(() id(hnd) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;freehnd(hnd)
[E] ExprCompiler input: [Expression] id(freehnd) pu(() id(hnd) pu())
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: func(standard.freehnd,1) ( var:(int)hnd )
[E] RPN ouput: var:(int)hnd func(standard.freehnd,1)
[E] .......... Processing token var:(int)hnd ..........
[E] Token var:(int)hnd --> Operand stack {var:(int)hnd}
[E] .......... Processing token func(standard.freehnd,1) ..........
[E] Source used flag set on variable hnd in scope {Loc:write}
[A] CODE: {000004ifs-exit}:                   
[A] CODE: {000004ifs-cond1}:                  PUSHi <hnd>                                                     ;[0000000000000527h] 00D2 00 0000000000000030
[A] CODE:                                     SCALL (I)18                                                     ;[0000000000000532h] 00E9 80 00000012
[E] Token func(standard.freehnd,1) --> Operand stack {}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):495:13: "  return true"
[P] Parsed sentence: [Return] kw(return) bo(true)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;return true
[E] ExprCompiler input: [Return] bo(true)
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: {K}1B
[E] RPN ouput: {K}1B
[E] Expression is computed, not compiled
[E] Token {K}1B --> Operand stack {{K}1B}
[E] Result token: {K}1B
[A] CODE:                                     MVb *<$result>,(B)true                                          ;[0000000000000539h] 0076 60 0000000000000000 01
[A] CODE:                                     RET                                                             ;[0000000000000545h] 00E6
[P] -------------------------------------------------------------------------------------
[L] Read line (src):496:5: ":func"
[P] Parsed sentence: [EndFunction] kw(:func)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[J] Jump event: BlockEnd GlobalBaseLabel=4
[B] Code block stack updated: Pop --> {Implementation:0:0}  
[S] Scope close: {Loc:write}
[J] Solving jump labels for scope depth 2...
[J] Solved jump: scopedepth=2 codeadr=0000000000000401h instadr=00000000000003F6h destadr=0000000000000417h relative=0000000000000021h label=000001ifs-cond1
[J] Solved jump: scopedepth=2 codeadr=0000000000000464h instadr=0000000000000459h destadr=000000000000047Ah relative=0000000000000021h label=000002ifs-cond1
[J] Solved jump: scopedepth=2 codeadr=00000000000004C0h instadr=00000000000004B5h destadr=00000000000004D6h relative=0000000000000021h label=000003ifs-cond1
[J] Solved jump: scopedepth=2 codeadr=0000000000000511h instadr=0000000000000506h destadr=0000000000000527h relative=0000000000000021h label=000004ifs-cond1
[A] FOOT: 
[A] FOOT: ; Jump addresses on scope {Loc:write} (depth=2):
[A] FOOT: ; [0000000000000417h] = {000001ifs-cond1}
[A] FOOT: ; [0000000000000417h] = {000001ifs-exit}
[A] FOOT: ; [000000000000047Ah] = {000002ifs-cond1}
[A] FOOT: ; [000000000000047Ah] = {000002ifs-exit}
[A] FOOT: ; [00000000000004D6h] = {000003ifs-cond1}
[A] FOOT: ; [00000000000004D6h] = {000003ifs-exit}
[A] FOOT: ; [0000000000000527h] = {000004ifs-cond1}
[A] FOOT: ; [0000000000000527h] = {000004ifs-exit}
[F] Solving forward calls for scope depth 2...
[F] Addr: ScopeDepth=0 Function=standard.$initsuper()
[F] Addr: ScopeDepth=0 Function=standard.getarchitecture()
[F] Addr: ScopeDepth=0 Function=standard.gethostsystem()
[F] Addr: ScopeDepth=0 Function=standard.gethostsystemname()
[F] Addr: ScopeDepth=0 Function=standard.panic(string)
[F] Addr: ScopeDepth=0 Function=standard.read(string,char[])
[F] Addr: ScopeDepth=0 Function=standard.write(string,char[])
[F] Addr: ScopeDepth=1 Function=standard.$initstandard()
[F] Call: ScopeDepth=1 Function=standard.$delayedinitstandard()
[S] Current scope: {Pri:main}, StackLength=2
[A] HEAD: (standard_write5)                   FUNCTION
[A] CODE: 
[A] CODE:                                     ;End function
[A] CODE:                                     END
[P] -------------------------------------------------------------------------------------
[L] Read line (src):499:48: "func bool read(string filename,ref string line):"
[P] Parsed sentence: [Function] kw(func) ty(bool) id(read) pu(() ty(string) id(filename) pu(,) kw(ref) ty(string) id(line) pu()) pu(:)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[J] Jump event: BlockBeg GlobalBaseLabel=0
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0}  
[A] HEAD: 
[A] HEAD: ;---------------------------------------------------------------------------------------------------
[A] HEAD: ; func bool read(string filename,ref string line):
[A] HEAD: ;---------------------------------------------------------------------------------------------------
[A] HEAD: 
[F] Stored function address: id=standard_read6 fullname=standard.read(string,string) address=0000000000000547h scopedepth=0
[Y] Update OFUN[176]: Address=1351
[A] CODE:                                     ;Reserve function stack size
[A] CODE:                                     STACK %TEXTARG0%                                                ;[0000000000000547h] 00BB 80 %HEXARG0%
[S] Scope open: {Loc:read}
[A] DECL:                                     ;Parameters
[D] VAR[10]: name=$result type=bool scope={Loc:read} address=0 const=no static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.$result index=10 searchindex=0, scope={Loc:read}
[A] DECL: <$result>                           PARM REFERENCE                                                  ;Address=<0000000000000000h>
[D] VAR[11]: name=filename type=string scope={Loc:read} address=16 const=yes static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.filename index=11 searchindex=1, scope={Loc:read}
[A] DECL: <filename>                          PARM CONST REFERENCE                                            ;Address=<0000000000000010h>
[D] VAR[12]: name=line type=string scope={Loc:read} address=32 const=no static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.line index=12 searchindex=2, scope={Loc:read}
[A] DECL: <line>                              PARM REFERENCE                                                  ;Address=<0000000000000020h>
[A] DECL: 
[S] Current scope: {Loc:read}, StackLength=3
[P] -------------------------------------------------------------------------------------
[L] Read line (src):500:11: "  int hnd=0"
[P] Parsed sentence: [VarDecl] ty(int) id(hnd) op(=) ch(0R)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;int hnd=0
[O] Relocation added: Type=BlkInsideGlo, LocAdr=0000000000000118h
[A] DATA:                                     STORE "hnd"                                                     ;Address=[0000000000000118h]
[D] VAR[13]: name=hnd type=int scope={Loc:read} address=48 const=no static=no parameter=no ref=no temp=no buffstore=yes length=4
[I] VAR: name=standard.hnd index=13 searchindex=2, scope={Loc:read}
[A] CODE: 
[A] CODE:                                     ;int hnd=0
[E] ExprCompiler input: [VarDecl] ch(0R)
[E] Release all temp variables
[E] Tokenizer ouput: {K}0C
[E] RPN ouput: {K}0C
[E] Expression is computed, not compiled
[E] Token {K}0C --> Operand stack {{K}0C}
[E] Result token: {K}0C
[A] CODE:                                     MVi <hnd>,(I)0                                                  ;[0000000000000552h] 0079 20 0000000000000030 00000000
[A] DECL: <hnd>                               VAR INTEGER                                                     ;Address=<0000000000000030h> = (I)0 { int hnd=0 }
[P] -------------------------------------------------------------------------------------
[L] Read line (src):501:19: "  if(!newhnd(hnd)):"
[P] Parsed sentence: [If] kw(if) pu(() op(!) id(newhnd) pu(() id(hnd) pu()) pu()) pu(:)
[J] Sentence labels: BaseLabel=1 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: FirstCase GlobalBaseLabel=1
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0 If:1:0}  
[A] CODE: 
[A] CODE:                                     ;if(!newhnd(hnd)):
[E] ExprCompiler input: [If] op(!) id(newhnd) pu(() id(hnd) pu())
[E] Release all temp variables
[E] Tokenizer ouput: opr! func(standard.newhnd,1) ( var:(int)hnd )
[E] RPN ouput: var:(int)hnd func(standard.newhnd,1) opr!
[E] .......... Processing token var:(int)hnd ..........
[E] Token var:(int)hnd --> Operand stack {var:(int)hnd}
[E] .......... Processing token func(standard.newhnd,1) ..........
[E] Requested new temp variable for type=bool reference=false kind=regular
[D] VAR[14]: name=$Bol000t type=bool scope={Loc:read} address=52 const=no static=no parameter=no ref=no temp=yes buffstore=yes length=1
[I] VAR: name=standard.$Bol000t index=14 searchindex=0, scope={Loc:read}
[E] New temp variable $Bol000t created (type=bool reference=false kind=regular)
[A] TEMP: <$Bol000t>                          VAR BOOLEAN                                                     ;Address=<0000000000000034h>
[E] Source used flag set on variable hnd in scope {Loc:read}
[A] CODE:                                     REFPU <$Bol000t>                                                ;[0000000000000561h] 00D6 00 0000000000000034
[A] CODE:                                     REFPU <hnd>                                                     ;[000000000000056Ch] 00D6 00 0000000000000030
[A] CODE:                                     SCALL (I)17                                                     ;[0000000000000577h] 00E9 80 00000011
[E] Token func(standard.newhnd,1) --> Operand stack {var:(bool)$Bol000t}
[E] .......... Processing token opr! ..........
[E] Temp variable $Bol000t released
[E] Source used flag set on variable $Bol000t in scope {Loc:read}
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[A] CODE:                                     LNOT <$Bol000t>,<$Bol000t>                                      ;[000000000000057Eh] 0031 00 0000000000000034 0000000000000034
[E] Token opr! --> Operand stack {var:(bool)$Bol000t}
[E] Source used flag set on variable $Bol000t in scope {Loc:read}
[E] Result token: var:(bool)$Bol000t
[J] Stored jump origin: scopedepth=2 label=000001ifs-cond1 codeadr=000000000000059Ch instadr=0000000000000591h
[A] CODE:                                     JMPFL <$Bol000t>,{000001ifs-cond1}                              ;[0000000000000591h] 0135 20 0000000000000034 {000001ifs-cond1}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):502:16: "    return false"
[P] Parsed sentence: [Return] kw(return) bo(false)
[J] Sentence labels: BaseLabel=1 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;return false
[E] ExprCompiler input: [Return] bo(false)
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: {K}0B
[E] RPN ouput: {K}0B
[E] Expression is computed, not compiled
[E] Token {K}0B --> Operand stack {{K}0B}
[E] Result token: {K}0B
[A] CODE:                                     MVb *<$result>,(B)false                                         ;[00000000000005A4h] 0076 60 0000000000000000 00
[A] CODE:                                     RET                                                             ;[00000000000005B0h] 00E6
[P] -------------------------------------------------------------------------------------
[L] Read line (src):503:5: "  :if"
[P] Parsed sentence: [EndIf] kw(:if)
[J] Sentence labels: BaseLabel=1 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: EndCase GlobalBaseLabel=1
[B] Code block stack updated: Pop --> {Implementation:0:0 Local:0:0}  
[A] CODE: 
[A] CODE:                                     ;:if
[J] Stored jump destination: scopedepth=2 label=000001ifs-cond1 address=00000000000005B2h
[J] Stored jump destination: scopedepth=2 label=000001ifs-exit address=00000000000005B2h
[P] -------------------------------------------------------------------------------------
[L] Read line (src):504:46: "  if(!openread(hnd,filename,filemode.binary)):"
[P] Parsed sentence: [If] kw(if) pu(() op(!) id(openread) pu(() id(hnd) pu(,) id(filename) pu(,) ty(filemode) op(.) id(binary) pu()) pu()) pu(:)
[J] Sentence labels: BaseLabel=2 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: FirstCase GlobalBaseLabel=2
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0 If:2:0}  
[A] CODE: 
[A] CODE:                                     ;if(!openread(hnd,filename,filemode.binary)):
[E] ExprCompiler input: [If] op(!) id(openread) pu(() id(hnd) pu(,) id(filename) pu(,) ty(filemode) op(.) id(binary) pu())
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: opr! func(standard.openread,3) ( var:(int)hnd , {K}ind:(string)filename , {K}Enu:filemode:1 )
[E] RPN ouput: var:(int)hnd {K}ind:(string)filename {K}Enu:filemode:1 func(standard.openread,3) opr!
[E] .......... Processing token var:(int)hnd ..........
[E] Token var:(int)hnd --> Operand stack {var:(int)hnd}
[E] .......... Processing token {K}ind:(string)filename ..........
[E] Token {K}ind:(string)filename --> Operand stack {var:(int)hnd {K}ind:(string)filename}
[E] .......... Processing token {K}Enu:filemode:1 ..........
[E] Token {K}Enu:filemode:1 --> Operand stack {var:(int)hnd {K}ind:(string)filename {K}Enu:filemode:1}
[E] .......... Processing token func(standard.openread,3) ..........
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[E] Source used flag set on variable hnd in scope {Loc:read}
[E] Source used flag set on variable filename in scope {Loc:read}
[A] CODE: {000001ifs-exit}:                   
[A] CODE: {000001ifs-cond1}:                  REFPU <$Bol000t>                                                ;[00000000000005B2h] 00D6 00 0000000000000034
[A] CODE:                                     PUSHi <hnd>                                                     ;[00000000000005BDh] 00D2 00 0000000000000030
[A] CODE:                                     PUSHr <filename>                                                ;[00000000000005C8h] 00D5 00 0000000000000010
[A] CODE:                                     PUSHi (I)1                                                      ;[00000000000005D3h] 00D2 80 00000001
[A] CODE:                                     SCALL (I)19                                                     ;[00000000000005DAh] 00E9 80 00000013
[E] Token func(standard.openread,3) --> Operand stack {var:(bool)$Bol000t}
[E] .......... Processing token opr! ..........
[E] Temp variable $Bol000t released
[E] Source used flag set on variable $Bol000t in scope {Loc:read}
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[A] CODE:                                     LNOT <$Bol000t>,<$Bol000t>                                      ;[00000000000005E1h] 0031 00 0000000000000034 0000000000000034
[E] Token opr! --> Operand stack {var:(bool)$Bol000t}
[E] Source used flag set on variable $Bol000t in scope {Loc:read}
[E] Result token: var:(bool)$Bol000t
[J] Stored jump origin: scopedepth=2 label=000002ifs-cond1 codeadr=00000000000005FFh instadr=00000000000005F4h
[A] CODE:                                     JMPFL <$Bol000t>,{000002ifs-cond1}                              ;[00000000000005F4h] 0135 20 0000000000000034 {000002ifs-cond1}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):505:16: "    return false"
[P] Parsed sentence: [Return] kw(return) bo(false)
[J] Sentence labels: BaseLabel=2 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;return false
[E] ExprCompiler input: [Return] bo(false)
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: {K}0B
[E] RPN ouput: {K}0B
[E] Expression is computed, not compiled
[E] Token {K}0B --> Operand stack {{K}0B}
[E] Result token: {K}0B
[A] CODE:                                     MVb *<$result>,(B)false                                         ;[0000000000000607h] 0076 60 0000000000000000 00
[A] CODE:                                     RET                                                             ;[0000000000000613h] 00E6
[P] -------------------------------------------------------------------------------------
[L] Read line (src):506:5: "  :if"
[P] Parsed sentence: [EndIf] kw(:if)
[J] Sentence labels: BaseLabel=2 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: EndCase GlobalBaseLabel=2
[B] Code block stack updated: Pop --> {Implementation:0:0 Local:0:0}  
[A] CODE: 
[A] CODE:                                     ;:if
[J] Stored jump destination: scopedepth=2 label=000002ifs-cond1 address=0000000000000615h
[J] Stored jump destination: scopedepth=2 label=000002ifs-exit address=0000000000000615h
[P] -------------------------------------------------------------------------------------
[L] Read line (src):507:22: "  if(!read(hnd,line)):"
[P] Parsed sentence: [If] kw(if) pu(() op(!) id(read) pu(() id(hnd) pu(,) id(line) pu()) pu()) pu(:)
[J] Sentence labels: BaseLabel=3 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: FirstCase GlobalBaseLabel=3
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0 If:3:0}  
[A] CODE: 
[A] CODE:                                     ;if(!read(hnd,line)):
[E] ExprCompiler input: [If] op(!) id(read) pu(() id(hnd) pu(,) id(line) pu())
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: opr! func(standard.read,2) ( var:(int)hnd , ind:(string)line )
[E] RPN ouput: var:(int)hnd ind:(string)line func(standard.read,2) opr!
[E] .......... Processing token var:(int)hnd ..........
[E] Token var:(int)hnd --> Operand stack {var:(int)hnd}
[E] .......... Processing token ind:(string)line ..........
[E] Token ind:(string)line --> Operand stack {var:(int)hnd ind:(string)line}
[E] .......... Processing token func(standard.read,2) ..........
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[E] Source used flag set on variable hnd in scope {Loc:read}
[E] Source used flag set on variable line in scope {Loc:read}
[A] CODE: {000002ifs-exit}:                   
[A] CODE: {000002ifs-cond1}:                  REFPU <$Bol000t>                                                ;[0000000000000615h] 00D6 00 0000000000000034
[A] CODE:                                     PUSHi <hnd>                                                     ;[0000000000000620h] 00D2 00 0000000000000030
[A] CODE:                                     PUSHr <line>                                                    ;[000000000000062Bh] 00D5 00 0000000000000020
[A] CODE:                                     SCALL (I)25                                                     ;[0000000000000636h] 00E9 80 00000019
[E] Token func(standard.read,2) --> Operand stack {var:(bool)$Bol000t}
[E] .......... Processing token opr! ..........
[E] Temp variable $Bol000t released
[E] Source used flag set on variable $Bol000t in scope {Loc:read}
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[A] CODE:                                     LNOT <$Bol000t>,<$Bol000t>                                      ;[000000000000063Dh] 0031 00 0000000000000034 0000000000000034
[E] Token opr! --> Operand stack {var:(bool)$Bol000t}
[E] Source used flag set on variable $Bol000t in scope {Loc:read}
[E] Result token: var:(bool)$Bol000t
[J] Stored jump origin: scopedepth=2 label=000003ifs-cond1 codeadr=000000000000065Bh instadr=0000000000000650h
[A] CODE:                                     JMPFL <$Bol000t>,{000003ifs-cond1}                              ;[0000000000000650h] 0135 20 0000000000000034 {000003ifs-cond1}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):508:16: "    return false"
[P] Parsed sentence: [Return] kw(return) bo(false)
[J] Sentence labels: BaseLabel=3 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;return false
[E] ExprCompiler input: [Return] bo(false)
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: {K}0B
[E] RPN ouput: {K}0B
[E] Expression is computed, not compiled
[E] Token {K}0B --> Operand stack {{K}0B}
[E] Result token: {K}0B
[A] CODE:                                     MVb *<$result>,(B)false                                         ;[0000000000000663h] 0076 60 0000000000000000 00
[A] CODE:                                     RET                                                             ;[000000000000066Fh] 00E6
[P] -------------------------------------------------------------------------------------
[L] Read line (src):509:5: "  :if"
[P] Parsed sentence: [EndIf] kw(:if)
[J] Sentence labels: BaseLabel=3 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: EndCase GlobalBaseLabel=3
[B] Code block stack updated: Pop --> {Implementation:0:0 Local:0:0}  
[A] CODE: 
[A] CODE:                                     ;:if
[J] Stored jump destination: scopedepth=2 label=000003ifs-cond1 address=0000000000000671h
[J] Stored jump destination: scopedepth=2 label=000003ifs-exit address=0000000000000671h
[P] -------------------------------------------------------------------------------------
[L] Read line (src):510:22: "  if(!closefile(hnd)):"
[P] Parsed sentence: [If] kw(if) pu(() op(!) id(closefile) pu(() id(hnd) pu()) pu()) pu(:)
[J] Sentence labels: BaseLabel=4 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: FirstCase GlobalBaseLabel=4
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0 If:4:0}  
[A] CODE: 
[A] CODE:                                     ;if(!closefile(hnd)):
[E] ExprCompiler input: [If] op(!) id(closefile) pu(() id(hnd) pu())
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: opr! func(standard.closefile,1) ( var:(int)hnd )
[E] RPN ouput: var:(int)hnd func(standard.closefile,1) opr!
[E] .......... Processing token var:(int)hnd ..........
[E] Token var:(int)hnd --> Operand stack {var:(int)hnd}
[E] .......... Processing token func(standard.closefile,1) ..........
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[E] Source used flag set on variable hnd in scope {Loc:read}
[A] CODE: {000003ifs-exit}:                   
[A] CODE: {000003ifs-cond1}:                  REFPU <$Bol000t>                                                ;[0000000000000671h] 00D6 00 0000000000000034
[A] CODE:                                     PUSHi <hnd>                                                     ;[000000000000067Ch] 00D2 00 0000000000000030
[A] CODE:                                     SCALL (I)30                                                     ;[0000000000000687h] 00E9 80 0000001E
[E] Token func(standard.closefile,1) --> Operand stack {var:(bool)$Bol000t}
[E] .......... Processing token opr! ..........
[E] Temp variable $Bol000t released
[E] Source used flag set on variable $Bol000t in scope {Loc:read}
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[A] CODE:                                     LNOT <$Bol000t>,<$Bol000t>                                      ;[000000000000068Eh] 0031 00 0000000000000034 0000000000000034
[E] Token opr! --> Operand stack {var:(bool)$Bol000t}
[E] Source used flag set on variable $Bol000t in scope {Loc:read}
[E] Result token: var:(bool)$Bol000t
[J] Stored jump origin: scopedepth=2 label=000004ifs-cond1 codeadr=00000000000006ACh instadr=00000000000006A1h
[A] CODE:                                     JMPFL <$Bol000t>,{000004ifs-cond1}                              ;[00000000000006A1h] 0135 20 0000000000000034 {000004ifs-cond1}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):511:16: "    return false"
[P] Parsed sentence: [Return] kw(return) bo(false)
[J] Sentence labels: BaseLabel=4 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;return false
[E] ExprCompiler input: [Return] bo(false)
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: {K}0B
[E] RPN ouput: {K}0B
[E] Expression is computed, not compiled
[E] Token {K}0B --> Operand stack {{K}0B}
[E] Result token: {K}0B
[A] CODE:                                     MVb *<$result>,(B)false                                         ;[00000000000006B4h] 0076 60 0000000000000000 00
[A] CODE:                                     RET                                                             ;[00000000000006C0h] 00E6
[P] -------------------------------------------------------------------------------------
[L] Read line (src):512:5: "  :if"
[P] Parsed sentence: [EndIf] kw(:if)
[J] Sentence labels: BaseLabel=4 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: EndCase GlobalBaseLabel=4
[B] Code block stack updated: Pop --> {Implementation:0:0 Local:0:0}  
[A] CODE: 
[A] CODE:                                     ;:if
[J] Stored jump destination: scopedepth=2 label=000004ifs-cond1 address=00000000000006C2h
[J] Stored jump destination: scopedepth=2 label=000004ifs-exit address=00000000000006C2h
[P] -------------------------------------------------------------------------------------
[L] Read line (src):513:14: "  freehnd(hnd)"
[P] Parsed sentence: [Expression] id(freehnd) pu(() id(hnd) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;freehnd(hnd)
[E] ExprCompiler input: [Expression] id(freehnd) pu(() id(hnd) pu())
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: func(standard.freehnd,1) ( var:(int)hnd )
[E] RPN ouput: var:(int)hnd func(standard.freehnd,1)
[E] .......... Processing token var:(int)hnd ..........
[E] Token var:(int)hnd --> Operand stack {var:(int)hnd}
[E] .......... Processing token func(standard.freehnd,1) ..........
[E] Source used flag set on variable hnd in scope {Loc:read}
[A] CODE: {000004ifs-exit}:                   
[A] CODE: {000004ifs-cond1}:                  PUSHi <hnd>                                                     ;[00000000000006C2h] 00D2 00 0000000000000030
[A] CODE:                                     SCALL (I)18                                                     ;[00000000000006CDh] 00E9 80 00000012
[E] Token func(standard.freehnd,1) --> Operand stack {}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):514:13: "  return true"
[P] Parsed sentence: [Return] kw(return) bo(true)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;return true
[E] ExprCompiler input: [Return] bo(true)
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: {K}1B
[E] RPN ouput: {K}1B
[E] Expression is computed, not compiled
[E] Token {K}1B --> Operand stack {{K}1B}
[E] Result token: {K}1B
[A] CODE:                                     MVb *<$result>,(B)true                                          ;[00000000000006D4h] 0076 60 0000000000000000 01
[A] CODE:                                     RET                                                             ;[00000000000006E0h] 00E6
[P] -------------------------------------------------------------------------------------
[L] Read line (src):515:5: ":func"
[P] Parsed sentence: [EndFunction] kw(:func)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[J] Jump event: BlockEnd GlobalBaseLabel=4
[B] Code block stack updated: Pop --> {Implementation:0:0}  
[S] Scope close: {Loc:read}
[J] Solving jump labels for scope depth 2...
[J] Solved jump: scopedepth=2 codeadr=000000000000059Ch instadr=0000000000000591h destadr=00000000000005B2h relative=0000000000000021h label=000001ifs-cond1
[J] Solved jump: scopedepth=2 codeadr=00000000000005FFh instadr=00000000000005F4h destadr=0000000000000615h relative=0000000000000021h label=000002ifs-cond1
[J] Solved jump: scopedepth=2 codeadr=000000000000065Bh instadr=0000000000000650h destadr=0000000000000671h relative=0000000000000021h label=000003ifs-cond1
[J] Solved jump: scopedepth=2 codeadr=00000000000006ACh instadr=00000000000006A1h destadr=00000000000006C2h relative=0000000000000021h label=000004ifs-cond1
[A] FOOT: 
[A] FOOT: ; Jump addresses on scope {Loc:read} (depth=2):
[A] FOOT: ; [00000000000005B2h] = {000001ifs-cond1}
[A] FOOT: ; [00000000000005B2h] = {000001ifs-exit}
[A] FOOT: ; [0000000000000615h] = {000002ifs-cond1}
[A] FOOT: ; [0000000000000615h] = {000002ifs-exit}
[A] FOOT: ; [0000000000000671h] = {000003ifs-cond1}
[A] FOOT: ; [0000000000000671h] = {000003ifs-exit}
[A] FOOT: ; [00000000000006C2h] = {000004ifs-cond1}
[A] FOOT: ; [00000000000006C2h] = {000004ifs-exit}
[F] Solving forward calls for scope depth 2...
[F] Addr: ScopeDepth=0 Function=standard.$initsuper()
[F] Addr: ScopeDepth=0 Function=standard.getarchitecture()
[F] Addr: ScopeDepth=0 Function=standard.gethostsystem()
[F] Addr: ScopeDepth=0 Function=standard.gethostsystemname()
[F] Addr: ScopeDepth=0 Function=standard.panic(string)
[F] Addr: ScopeDepth=0 Function=standard.read(string,char[])
[F] Addr: ScopeDepth=0 Function=standard.read(string,string)
[F] Addr: ScopeDepth=0 Function=standard.write(string,char[])
[F] Addr: ScopeDepth=1 Function=standard.$initstandard()
[F] Call: ScopeDepth=1 Function=standard.$delayedinitstandard()
[S] Current scope: {Pri:main}, StackLength=2
[A] HEAD: (standard_read6)                    FUNCTION
[A] CODE: 
[A] CODE:                                     ;End function
[A] CODE:                                     END
[P] -------------------------------------------------------------------------------------
[L] Read line (src):518:45: "func bool write(string filename,string line):"
[P] Parsed sentence: [Function] kw(func) ty(bool) id(write) pu(() ty(string) id(filename) pu(,) ty(string) id(line) pu()) pu(:)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[J] Jump event: BlockBeg GlobalBaseLabel=0
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0}  
[A] HEAD: 
[A] HEAD: ;---------------------------------------------------------------------------------------------------
[A] HEAD: ; func bool write(string filename,string line):
[A] HEAD: ;---------------------------------------------------------------------------------------------------
[A] HEAD: 
[F] Stored function address: id=standard_write6 fullname=standard.write(string,string) address=00000000000006E2h scopedepth=0
[Y] Update OFUN[177]: Address=1762
[A] CODE:                                     ;Reserve function stack size
[A] CODE:                                     STACK %TEXTARG0%                                                ;[00000000000006E2h] 00BB 80 %HEXARG0%
[S] Scope open: {Loc:write}
[A] DECL:                                     ;Parameters
[D] VAR[10]: name=$result type=bool scope={Loc:write} address=0 const=no static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.$result index=10 searchindex=0, scope={Loc:write}
[A] DECL: <$result>                           PARM REFERENCE                                                  ;Address=<0000000000000000h>
[D] VAR[11]: name=filename type=string scope={Loc:write} address=16 const=yes static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.filename index=11 searchindex=1, scope={Loc:write}
[A] DECL: <filename>                          PARM CONST REFERENCE                                            ;Address=<0000000000000010h>
[D] VAR[12]: name=line type=string scope={Loc:write} address=32 const=yes static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.line index=12 searchindex=2, scope={Loc:write}
[A] DECL: <line>                              PARM CONST REFERENCE                                            ;Address=<0000000000000020h>
[A] DECL: 
[S] Current scope: {Loc:write}, StackLength=3
[P] -------------------------------------------------------------------------------------
[L] Read line (src):519:11: "  int hnd=0"
[P] Parsed sentence: [VarDecl] ty(int) id(hnd) op(=) ch(0R)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;int hnd=0
[O] Relocation added: Type=BlkInsideGlo, LocAdr=000000000000011Ch
[A] DATA:                                     STORE "hnd"                                                     ;Address=[000000000000011Ch]
[D] VAR[13]: name=hnd type=int scope={Loc:write} address=48 const=no static=no parameter=no ref=no temp=no buffstore=yes length=4
[I] VAR: name=standard.hnd index=13 searchindex=2, scope={Loc:write}
[A] CODE: 
[A] CODE:                                     ;int hnd=0
[E] ExprCompiler input: [VarDecl] ch(0R)
[E] Release all temp variables
[E] Tokenizer ouput: {K}0C
[E] RPN ouput: {K}0C
[E] Expression is computed, not compiled
[E] Token {K}0C --> Operand stack {{K}0C}
[E] Result token: {K}0C
[A] CODE:                                     MVi <hnd>,(I)0                                                  ;[00000000000006EDh] 0079 20 0000000000000030 00000000
[A] DECL: <hnd>                               VAR INTEGER                                                     ;Address=<0000000000000030h> = (I)0 { int hnd=0 }
[P] -------------------------------------------------------------------------------------
[L] Read line (src):520:19: "  if(!newhnd(hnd)):"
[P] Parsed sentence: [If] kw(if) pu(() op(!) id(newhnd) pu(() id(hnd) pu()) pu()) pu(:)
[J] Sentence labels: BaseLabel=1 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: FirstCase GlobalBaseLabel=1
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0 If:1:0}  
[A] CODE: 
[A] CODE:                                     ;if(!newhnd(hnd)):
[E] ExprCompiler input: [If] op(!) id(newhnd) pu(() id(hnd) pu())
[E] Release all temp variables
[E] Tokenizer ouput: opr! func(standard.newhnd,1) ( var:(int)hnd )
[E] RPN ouput: var:(int)hnd func(standard.newhnd,1) opr!
[E] .......... Processing token var:(int)hnd ..........
[E] Token var:(int)hnd --> Operand stack {var:(int)hnd}
[E] .......... Processing token func(standard.newhnd,1) ..........
[E] Requested new temp variable for type=bool reference=false kind=regular
[D] VAR[14]: name=$Bol000t type=bool scope={Loc:write} address=52 const=no static=no parameter=no ref=no temp=yes buffstore=yes length=1
[I] VAR: name=standard.$Bol000t index=14 searchindex=0, scope={Loc:write}
[E] New temp variable $Bol000t created (type=bool reference=false kind=regular)
[A] TEMP: <$Bol000t>                          VAR BOOLEAN                                                     ;Address=<0000000000000034h>
[E] Source used flag set on variable hnd in scope {Loc:write}
[A] CODE:                                     REFPU <$Bol000t>                                                ;[00000000000006FCh] 00D6 00 0000000000000034
[A] CODE:                                     REFPU <hnd>                                                     ;[0000000000000707h] 00D6 00 0000000000000030
[A] CODE:                                     SCALL (I)17                                                     ;[0000000000000712h] 00E9 80 00000011
[E] Token func(standard.newhnd,1) --> Operand stack {var:(bool)$Bol000t}
[E] .......... Processing token opr! ..........
[E] Temp variable $Bol000t released
[E] Source used flag set on variable $Bol000t in scope {Loc:write}
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[A] CODE:                                     LNOT <$Bol000t>,<$Bol000t>                                      ;[0000000000000719h] 0031 00 0000000000000034 0000000000000034
[E] Token opr! --> Operand stack {var:(bool)$Bol000t}
[E] Source used flag set on variable $Bol000t in scope {Loc:write}
[E] Result token: var:(bool)$Bol000t
[J] Stored jump origin: scopedepth=2 label=000001ifs-cond1 codeadr=0000000000000737h instadr=000000000000072Ch
[A] CODE:                                     JMPFL <$Bol000t>,{000001ifs-cond1}                              ;[000000000000072Ch] 0135 20 0000000000000034 {000001ifs-cond1}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):521:16: "    return false"
[P] Parsed sentence: [Return] kw(return) bo(false)
[J] Sentence labels: BaseLabel=1 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;return false
[E] ExprCompiler input: [Return] bo(false)
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: {K}0B
[E] RPN ouput: {K}0B
[E] Expression is computed, not compiled
[E] Token {K}0B --> Operand stack {{K}0B}
[E] Result token: {K}0B
[A] CODE:                                     MVb *<$result>,(B)false                                         ;[000000000000073Fh] 0076 60 0000000000000000 00
[A] CODE:                                     RET                                                             ;[000000000000074Bh] 00E6
[P] -------------------------------------------------------------------------------------
[L] Read line (src):522:5: "  :if"
[P] Parsed sentence: [EndIf] kw(:if)
[J] Sentence labels: BaseLabel=1 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: EndCase GlobalBaseLabel=1
[B] Code block stack updated: Pop --> {Implementation:0:0 Local:0:0}  
[A] CODE: 
[A] CODE:                                     ;:if
[J] Stored jump destination: scopedepth=2 label=000001ifs-cond1 address=000000000000074Dh
[J] Stored jump destination: scopedepth=2 label=000001ifs-exit address=000000000000074Dh
[P] -------------------------------------------------------------------------------------
[L] Read line (src):523:47: "  if(!openwrite(hnd,filename,filemode.binary)):"
[P] Parsed sentence: [If] kw(if) pu(() op(!) id(openwrite) pu(() id(hnd) pu(,) id(filename) pu(,) ty(filemode) op(.) id(binary) pu()) pu()) pu(:)
[J] Sentence labels: BaseLabel=2 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: FirstCase GlobalBaseLabel=2
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0 If:2:0}  
[A] CODE: 
[A] CODE:                                     ;if(!openwrite(hnd,filename,filemode.binary)):
[E] ExprCompiler input: [If] op(!) id(openwrite) pu(() id(hnd) pu(,) id(filename) pu(,) ty(filemode) op(.) id(binary) pu())
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: opr! func(standard.openwrite,3) ( var:(int)hnd , {K}ind:(string)filename , {K}Enu:filemode:1 )
[E] RPN ouput: var:(int)hnd {K}ind:(string)filename {K}Enu:filemode:1 func(standard.openwrite,3) opr!
[E] .......... Processing token var:(int)hnd ..........
[E] Token var:(int)hnd --> Operand stack {var:(int)hnd}
[E] .......... Processing token {K}ind:(string)filename ..........
[E] Token {K}ind:(string)filename --> Operand stack {var:(int)hnd {K}ind:(string)filename}
[E] .......... Processing token {K}Enu:filemode:1 ..........
[E] Token {K}Enu:filemode:1 --> Operand stack {var:(int)hnd {K}ind:(string)filename {K}Enu:filemode:1}
[E] .......... Processing token func(standard.openwrite,3) ..........
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[E] Source used flag set on variable hnd in scope {Loc:write}
[E] Source used flag set on variable filename in scope {Loc:write}
[A] CODE: {000001ifs-exit}:                   
[A] CODE: {000001ifs-cond1}:                  REFPU <$Bol000t>                                                ;[000000000000074Dh] 00D6 00 0000000000000034
[A] CODE:                                     PUSHi <hnd>                                                     ;[0000000000000758h] 00D2 00 0000000000000030
[A] CODE:                                     PUSHr <filename>                                                ;[0000000000000763h] 00D5 00 0000000000000010
[A] CODE:                                     PUSHi (I)1                                                      ;[000000000000076Eh] 00D2 80 00000001
[A] CODE:                                     SCALL (I)20                                                     ;[0000000000000775h] 00E9 80 00000014
[E] Token func(standard.openwrite,3) --> Operand stack {var:(bool)$Bol000t}
[E] .......... Processing token opr! ..........
[E] Temp variable $Bol000t released
[E] Source used flag set on variable $Bol000t in scope {Loc:write}
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[A] CODE:                                     LNOT <$Bol000t>,<$Bol000t>                                      ;[000000000000077Ch] 0031 00 0000000000000034 0000000000000034
[E] Token opr! --> Operand stack {var:(bool)$Bol000t}
[E] Source used flag set on variable $Bol000t in scope {Loc:write}
[E] Result token: var:(bool)$Bol000t
[J] Stored jump origin: scopedepth=2 label=000002ifs-cond1 codeadr=000000000000079Ah instadr=000000000000078Fh
[A] CODE:                                     JMPFL <$Bol000t>,{000002ifs-cond1}                              ;[000000000000078Fh] 0135 20 0000000000000034 {000002ifs-cond1}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):524:16: "    return false"
[P] Parsed sentence: [Return] kw(return) bo(false)
[J] Sentence labels: BaseLabel=2 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;return false
[E] ExprCompiler input: [Return] bo(false)
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: {K}0B
[E] RPN ouput: {K}0B
[E] Expression is computed, not compiled
[E] Token {K}0B --> Operand stack {{K}0B}
[E] Result token: {K}0B
[A] CODE:                                     MVb *<$result>,(B)false                                         ;[00000000000007A2h] 0076 60 0000000000000000 00
[A] CODE:                                     RET                                                             ;[00000000000007AEh] 00E6
[P] -------------------------------------------------------------------------------------
[L] Read line (src):525:5: "  :if"
[P] Parsed sentence: [EndIf] kw(:if)
[J] Sentence labels: BaseLabel=2 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: EndCase GlobalBaseLabel=2
[B] Code block stack updated: Pop --> {Implementation:0:0 Local:0:0}  
[A] CODE: 
[A] CODE:                                     ;:if
[J] Stored jump destination: scopedepth=2 label=000002ifs-cond1 address=00000000000007B0h
[J] Stored jump destination: scopedepth=2 label=000002ifs-exit address=00000000000007B0h
[P] -------------------------------------------------------------------------------------
[L] Read line (src):526:23: "  if(!write(hnd,line)):"
[P] Parsed sentence: [If] kw(if) pu(() op(!) id(write) pu(() id(hnd) pu(,) id(line) pu()) pu()) pu(:)
[J] Sentence labels: BaseLabel=3 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: FirstCase GlobalBaseLabel=3
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0 If:3:0}  
[A] CODE: 
[A] CODE:                                     ;if(!write(hnd,line)):
[E] ExprCompiler input: [If] op(!) id(write) pu(() id(hnd) pu(,) id(line) pu())
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: opr! func(standard.write,2) ( var:(int)hnd , {K}ind:(string)line )
[E] RPN ouput: var:(int)hnd {K}ind:(string)line func(standard.write,2) opr!
[E] .......... Processing token var:(int)hnd ..........
[E] Token var:(int)hnd --> Operand stack {var:(int)hnd}
[E] .......... Processing token {K}ind:(string)line ..........
[E] Token {K}ind:(string)line --> Operand stack {var:(int)hnd {K}ind:(string)line}
[E] .......... Processing token func(standard.write,2) ..........
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[E] Source used flag set on variable hnd in scope {Loc:write}
[E] Source used flag set on variable line in scope {Loc:write}
[A] CODE: {000002ifs-exit}:                   
[A] CODE: {000002ifs-cond1}:                  REFPU <$Bol000t>                                                ;[00000000000007B0h] 00D6 00 0000000000000034
[A] CODE:                                     PUSHi <hnd>                                                     ;[00000000000007BBh] 00D2 00 0000000000000030
[A] CODE:                                     PUSHr <line>                                                    ;[00000000000007C6h] 00D5 00 0000000000000020
[A] CODE:                                     SCALL (I)26                                                     ;[00000000000007D1h] 00E9 80 0000001A
[E] Token func(standard.write,2) --> Operand stack {var:(bool)$Bol000t}
[E] .......... Processing token opr! ..........
[E] Temp variable $Bol000t released
[E] Source used flag set on variable $Bol000t in scope {Loc:write}
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[A] CODE:                                     LNOT <$Bol000t>,<$Bol000t>                                      ;[00000000000007D8h] 0031 00 0000000000000034 0000000000000034
[E] Token opr! --> Operand stack {var:(bool)$Bol000t}
[E] Source used flag set on variable $Bol000t in scope {Loc:write}
[E] Result token: var:(bool)$Bol000t
[J] Stored jump origin: scopedepth=2 label=000003ifs-cond1 codeadr=00000000000007F6h instadr=00000000000007EBh
[A] CODE:                                     JMPFL <$Bol000t>,{000003ifs-cond1}                              ;[00000000000007EBh] 0135 20 0000000000000034 {000003ifs-cond1}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):527:16: "    return false"
[P] Parsed sentence: [Return] kw(return) bo(false)
[J] Sentence labels: BaseLabel=3 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;return false
[E] ExprCompiler input: [Return] bo(false)
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: {K}0B
[E] RPN ouput: {K}0B
[E] Expression is computed, not compiled
[E] Token {K}0B --> Operand stack {{K}0B}
[E] Result token: {K}0B
[A] CODE:                                     MVb *<$result>,(B)false                                         ;[00000000000007FEh] 0076 60 0000000000000000 00
[A] CODE:                                     RET                                                             ;[000000000000080Ah] 00E6
[P] -------------------------------------------------------------------------------------
[L] Read line (src):528:5: "  :if"
[P] Parsed sentence: [EndIf] kw(:if)
[J] Sentence labels: BaseLabel=3 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: EndCase GlobalBaseLabel=3
[B] Code block stack updated: Pop --> {Implementation:0:0 Local:0:0}  
[A] CODE: 
[A] CODE:                                     ;:if
[J] Stored jump destination: scopedepth=2 label=000003ifs-cond1 address=000000000000080Ch
[J] Stored jump destination: scopedepth=2 label=000003ifs-exit address=000000000000080Ch
[P] -------------------------------------------------------------------------------------
[L] Read line (src):529:22: "  if(!closefile(hnd)):"
[P] Parsed sentence: [If] kw(if) pu(() op(!) id(closefile) pu(() id(hnd) pu()) pu()) pu(:)
[J] Sentence labels: BaseLabel=4 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: FirstCase GlobalBaseLabel=4
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0 If:4:0}  
[A] CODE: 
[A] CODE:                                     ;if(!closefile(hnd)):
[E] ExprCompiler input: [If] op(!) id(closefile) pu(() id(hnd) pu())
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: opr! func(standard.closefile,1) ( var:(int)hnd )
[E] RPN ouput: var:(int)hnd func(standard.closefile,1) opr!
[E] .......... Processing token var:(int)hnd ..........
[E] Token var:(int)hnd --> Operand stack {var:(int)hnd}
[E] .......... Processing token func(standard.closefile,1) ..........
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[E] Source used flag set on variable hnd in scope {Loc:write}
[A] CODE: {000003ifs-exit}:                   
[A] CODE: {000003ifs-cond1}:                  REFPU <$Bol000t>                                                ;[000000000000080Ch] 00D6 00 0000000000000034
[A] CODE:                                     PUSHi <hnd>                                                     ;[0000000000000817h] 00D2 00 0000000000000030
[A] CODE:                                     SCALL (I)30                                                     ;[0000000000000822h] 00E9 80 0000001E
[E] Token func(standard.closefile,1) --> Operand stack {var:(bool)$Bol000t}
[E] .......... Processing token opr! ..........
[E] Temp variable $Bol000t released
[E] Source used flag set on variable $Bol000t in scope {Loc:write}
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[A] CODE:                                     LNOT <$Bol000t>,<$Bol000t>                                      ;[0000000000000829h] 0031 00 0000000000000034 0000000000000034
[E] Token opr! --> Operand stack {var:(bool)$Bol000t}
[E] Source used flag set on variable $Bol000t in scope {Loc:write}
[E] Result token: var:(bool)$Bol000t
[J] Stored jump origin: scopedepth=2 label=000004ifs-cond1 codeadr=0000000000000847h instadr=000000000000083Ch
[A] CODE:                                     JMPFL <$Bol000t>,{000004ifs-cond1}                              ;[000000000000083Ch] 0135 20 0000000000000034 {000004ifs-cond1}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):530:16: "    return false"
[P] Parsed sentence: [Return] kw(return) bo(false)
[J] Sentence labels: BaseLabel=4 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;return false
[E] ExprCompiler input: [Return] bo(false)
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: {K}0B
[E] RPN ouput: {K}0B
[E] Expression is computed, not compiled
[E] Token {K}0B --> Operand stack {{K}0B}
[E] Result token: {K}0B
[A] CODE:                                     MVb *<$result>,(B)false                                         ;[000000000000084Fh] 0076 60 0000000000000000 00
[A] CODE:                                     RET                                                             ;[000000000000085Bh] 00E6
[P] -------------------------------------------------------------------------------------
[L] Read line (src):531:5: "  :if"
[P] Parsed sentence: [EndIf] kw(:if)
[J] Sentence labels: BaseLabel=4 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: EndCase GlobalBaseLabel=4
[B] Code block stack updated: Pop --> {Implementation:0:0 Local:0:0}  
[A] CODE: 
[A] CODE:                                     ;:if
[J] Stored jump destination: scopedepth=2 label=000004ifs-cond1 address=000000000000085Dh
[J] Stored jump destination: scopedepth=2 label=000004ifs-exit address=000000000000085Dh
[P] -------------------------------------------------------------------------------------
[L] Read line (src):532:14: "  freehnd(hnd)"
[P] Parsed sentence: [Expression] id(freehnd) pu(() id(hnd) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;freehnd(hnd)
[E] ExprCompiler input: [Expression] id(freehnd) pu(() id(hnd) pu())
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: func(standard.freehnd,1) ( var:(int)hnd )
[E] RPN ouput: var:(int)hnd func(standard.freehnd,1)
[E] .......... Processing token var:(int)hnd ..........
[E] Token var:(int)hnd --> Operand stack {var:(int)hnd}
[E] .......... Processing token func(standard.freehnd,1) ..........
[E] Source used flag set on variable hnd in scope {Loc:write}
[A] CODE: {000004ifs-exit}:                   
[A] CODE: {000004ifs-cond1}:                  PUSHi <hnd>                                                     ;[000000000000085Dh] 00D2 00 0000000000000030
[A] CODE:                                     SCALL (I)18                                                     ;[0000000000000868h] 00E9 80 00000012
[E] Token func(standard.freehnd,1) --> Operand stack {}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):533:13: "  return true"
[P] Parsed sentence: [Return] kw(return) bo(true)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;return true
[E] ExprCompiler input: [Return] bo(true)
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: {K}1B
[E] RPN ouput: {K}1B
[E] Expression is computed, not compiled
[E] Token {K}1B --> Operand stack {{K}1B}
[E] Result token: {K}1B
[A] CODE:                                     MVb *<$result>,(B)true                                          ;[000000000000086Fh] 0076 60 0000000000000000 01
[A] CODE:                                     RET                                                             ;[000000000000087Bh] 00E6
[P] -------------------------------------------------------------------------------------
[L] Read line (src):534:5: ":func"
[P] Parsed sentence: [EndFunction] kw(:func)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[J] Jump event: BlockEnd GlobalBaseLabel=4
[B] Code block stack updated: Pop --> {Implementation:0:0}  
[S] Scope close: {Loc:write}
[J] Solving jump labels for scope depth 2...
[J] Solved jump: scopedepth=2 codeadr=0000000000000737h instadr=000000000000072Ch destadr=000000000000074Dh relative=0000000000000021h label=000001ifs-cond1
[J] Solved jump: scopedepth=2 codeadr=000000000000079Ah instadr=000000000000078Fh destadr=00000000000007B0h relative=0000000000000021h label=000002ifs-cond1
[J] Solved jump: scopedepth=2 codeadr=00000000000007F6h instadr=00000000000007EBh destadr=000000000000080Ch relative=0000000000000021h label=000003ifs-cond1
[J] Solved jump: scopedepth=2 codeadr=0000000000000847h instadr=000000000000083Ch destadr=000000000000085Dh relative=0000000000000021h label=000004ifs-cond1
[A] FOOT: 
[A] FOOT: ; Jump addresses on scope {Loc:write} (depth=2):
[A] FOOT: ; [000000000000074Dh] = {000001ifs-cond1}
[A] FOOT: ; [000000000000074Dh] = {000001ifs-exit}
[A] FOOT: ; [00000000000007B0h] = {000002ifs-cond1}
[A] FOOT: ; [00000000000007B0h] = {000002ifs-exit}
[A] FOOT: ; [000000000000080Ch] = {000003ifs-cond1}
[A] FOOT: ; [000000000000080Ch] = {000003ifs-exit}
[A] FOOT: ; [000000000000085Dh] = {000004ifs-cond1}
[A] FOOT: ; [000000000000085Dh] = {000004ifs-exit}
[F] Solving forward calls for scope depth 2...
[F] Addr: ScopeDepth=0 Function=standard.$initsuper()
[F] Addr: ScopeDepth=0 Function=standard.getarchitecture()
[F] Addr: ScopeDepth=0 Function=standard.gethostsystem()
[F] Addr: ScopeDepth=0 Function=standard.gethostsystemname()
[F] Addr: ScopeDepth=0 Function=standard.panic(string)
[F] Addr: ScopeDepth=0 Function=standard.read(string,char[])
[F] Addr: ScopeDepth=0 Function=standard.read(string,string)
[F] Addr: ScopeDepth=0 Function=standard.write(string,char[])
[F] Addr: ScopeDepth=0 Function=standard.write(string,string)
[F] Addr: ScopeDepth=1 Function=standard.$initstandard()
[F] Call: ScopeDepth=1 Function=standard.$delayedinitstandard()
[S] Current scope: {Pri:main}, StackLength=2
[A] HEAD: (standard_write6)                   FUNCTION
[A] CODE: 
[A] CODE:                                     ;End function
[A] CODE:                                     END
[P] -------------------------------------------------------------------------------------
[L] Read line (src):537:50: "func bool read(string filename,ref string[] line):"
[P] Parsed sentence: [Function] kw(func) ty(bool) id(read) pu(() ty(string) id(filename) pu(,) kw(ref) ty(string) pu([) pu(]) id(line) pu()) pu(:)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[J] Jump event: BlockBeg GlobalBaseLabel=0
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0}  
[A] HEAD: 
[A] HEAD: ;---------------------------------------------------------------------------------------------------
[A] HEAD: ; func bool read(string filename,ref string[] line):
[A] HEAD: ;---------------------------------------------------------------------------------------------------
[A] HEAD: 
[F] Stored function address: id=standard_read7 fullname=standard.read(string,string[]) address=000000000000087Dh scopedepth=0
[Y] Update OFUN[178]: Address=2173
[A] CODE:                                     ;Reserve function stack size
[A] CODE:                                     STACK %TEXTARG0%                                                ;[000000000000087Dh] 00BB 80 %HEXARG0%
[S] Scope open: {Loc:read}
[A] DECL:                                     ;Parameters
[D] VAR[10]: name=$result type=bool scope={Loc:read} address=0 const=no static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.$result index=10 searchindex=0, scope={Loc:read}
[A] DECL: <$result>                           PARM REFERENCE                                                  ;Address=<0000000000000000h>
[D] VAR[11]: name=filename type=string scope={Loc:read} address=16 const=yes static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.filename index=11 searchindex=1, scope={Loc:read}
[A] DECL: <filename>                          PARM CONST REFERENCE                                            ;Address=<0000000000000010h>
[D] VAR[12]: name=line type=string[] scope={Loc:read} address=32 const=no static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.line index=12 searchindex=2, scope={Loc:read}
[A] DECL: <line>                              PARM REFERENCE                                                  ;Address=<0000000000000020h>
[A] DECL: 
[S] Current scope: {Loc:read}, StackLength=3
[P] -------------------------------------------------------------------------------------
[L] Read line (src):538:11: "  int hnd=0"
[P] Parsed sentence: [VarDecl] ty(int) id(hnd) op(=) ch(0R)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;int hnd=0
[O] Relocation added: Type=BlkInsideGlo, LocAdr=0000000000000120h
[A] DATA:                                     STORE "hnd"                                                     ;Address=[0000000000000120h]
[D] VAR[13]: name=hnd type=int scope={Loc:read} address=48 const=no static=no parameter=no ref=no temp=no buffstore=yes length=4
[I] VAR: name=standard.hnd index=13 searchindex=2, scope={Loc:read}
[A] CODE: 
[A] CODE:                                     ;int hnd=0
[E] ExprCompiler input: [VarDecl] ch(0R)
[E] Release all temp variables
[E] Tokenizer ouput: {K}0C
[E] RPN ouput: {K}0C
[E] Expression is computed, not compiled
[E] Token {K}0C --> Operand stack {{K}0C}
[E] Result token: {K}0C
[A] CODE:                                     MVi <hnd>,(I)0                                                  ;[0000000000000888h] 0079 20 0000000000000030 00000000
[A] DECL: <hnd>                               VAR INTEGER                                                     ;Address=<0000000000000030h> = (I)0 { int hnd=0 }
[P] -------------------------------------------------------------------------------------
[L] Read line (src):539:19: "  if(!newhnd(hnd)):"
[P] Parsed sentence: [If] kw(if) pu(() op(!) id(newhnd) pu(() id(hnd) pu()) pu()) pu(:)
[J] Sentence labels: BaseLabel=1 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: FirstCase GlobalBaseLabel=1
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0 If:1:0}  
[A] CODE: 
[A] CODE:                                     ;if(!newhnd(hnd)):
[E] ExprCompiler input: [If] op(!) id(newhnd) pu(() id(hnd) pu())
[E] Release all temp variables
[E] Tokenizer ouput: opr! func(standard.newhnd,1) ( var:(int)hnd )
[E] RPN ouput: var:(int)hnd func(standard.newhnd,1) opr!
[E] .......... Processing token var:(int)hnd ..........
[E] Token var:(int)hnd --> Operand stack {var:(int)hnd}
[E] .......... Processing token func(standard.newhnd,1) ..........
[E] Requested new temp variable for type=bool reference=false kind=regular
[D] VAR[14]: name=$Bol000t type=bool scope={Loc:read} address=52 const=no static=no parameter=no ref=no temp=yes buffstore=yes length=1
[I] VAR: name=standard.$Bol000t index=14 searchindex=0, scope={Loc:read}
[E] New temp variable $Bol000t created (type=bool reference=false kind=regular)
[A] TEMP: <$Bol000t>                          VAR BOOLEAN                                                     ;Address=<0000000000000034h>
[E] Source used flag set on variable hnd in scope {Loc:read}
[A] CODE:                                     REFPU <$Bol000t>                                                ;[0000000000000897h] 00D6 00 0000000000000034
[A] CODE:                                     REFPU <hnd>                                                     ;[00000000000008A2h] 00D6 00 0000000000000030
[A] CODE:                                     SCALL (I)17                                                     ;[00000000000008ADh] 00E9 80 00000011
[E] Token func(standard.newhnd,1) --> Operand stack {var:(bool)$Bol000t}
[E] .......... Processing token opr! ..........
[E] Temp variable $Bol000t released
[E] Source used flag set on variable $Bol000t in scope {Loc:read}
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[A] CODE:                                     LNOT <$Bol000t>,<$Bol000t>                                      ;[00000000000008B4h] 0031 00 0000000000000034 0000000000000034
[E] Token opr! --> Operand stack {var:(bool)$Bol000t}
[E] Source used flag set on variable $Bol000t in scope {Loc:read}
[E] Result token: var:(bool)$Bol000t
[J] Stored jump origin: scopedepth=2 label=000001ifs-cond1 codeadr=00000000000008D2h instadr=00000000000008C7h
[A] CODE:                                     JMPFL <$Bol000t>,{000001ifs-cond1}                              ;[00000000000008C7h] 0135 20 0000000000000034 {000001ifs-cond1}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):540:16: "    return false"
[P] Parsed sentence: [Return] kw(return) bo(false)
[J] Sentence labels: BaseLabel=1 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;return false
[E] ExprCompiler input: [Return] bo(false)
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: {K}0B
[E] RPN ouput: {K}0B
[E] Expression is computed, not compiled
[E] Token {K}0B --> Operand stack {{K}0B}
[E] Result token: {K}0B
[A] CODE:                                     MVb *<$result>,(B)false                                         ;[00000000000008DAh] 0076 60 0000000000000000 00
[A] CODE:                                     RET                                                             ;[00000000000008E6h] 00E6
[P] -------------------------------------------------------------------------------------
[L] Read line (src):541:5: "  :if"
[P] Parsed sentence: [EndIf] kw(:if)
[J] Sentence labels: BaseLabel=1 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: EndCase GlobalBaseLabel=1
[B] Code block stack updated: Pop --> {Implementation:0:0 Local:0:0}  
[A] CODE: 
[A] CODE:                                     ;:if
[J] Stored jump destination: scopedepth=2 label=000001ifs-cond1 address=00000000000008E8h
[J] Stored jump destination: scopedepth=2 label=000001ifs-exit address=00000000000008E8h
[P] -------------------------------------------------------------------------------------
[L] Read line (src):542:46: "  if(!openread(hnd,filename,filemode.binary)):"
[P] Parsed sentence: [If] kw(if) pu(() op(!) id(openread) pu(() id(hnd) pu(,) id(filename) pu(,) ty(filemode) op(.) id(binary) pu()) pu()) pu(:)
[J] Sentence labels: BaseLabel=2 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: FirstCase GlobalBaseLabel=2
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0 If:2:0}  
[A] CODE: 
[A] CODE:                                     ;if(!openread(hnd,filename,filemode.binary)):
[E] ExprCompiler input: [If] op(!) id(openread) pu(() id(hnd) pu(,) id(filename) pu(,) ty(filemode) op(.) id(binary) pu())
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: opr! func(standard.openread,3) ( var:(int)hnd , {K}ind:(string)filename , {K}Enu:filemode:1 )
[E] RPN ouput: var:(int)hnd {K}ind:(string)filename {K}Enu:filemode:1 func(standard.openread,3) opr!
[E] .......... Processing token var:(int)hnd ..........
[E] Token var:(int)hnd --> Operand stack {var:(int)hnd}
[E] .......... Processing token {K}ind:(string)filename ..........
[E] Token {K}ind:(string)filename --> Operand stack {var:(int)hnd {K}ind:(string)filename}
[E] .......... Processing token {K}Enu:filemode:1 ..........
[E] Token {K}Enu:filemode:1 --> Operand stack {var:(int)hnd {K}ind:(string)filename {K}Enu:filemode:1}
[E] .......... Processing token func(standard.openread,3) ..........
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[E] Source used flag set on variable hnd in scope {Loc:read}
[E] Source used flag set on variable filename in scope {Loc:read}
[A] CODE: {000001ifs-exit}:                   
[A] CODE: {000001ifs-cond1}:                  REFPU <$Bol000t>                                                ;[00000000000008E8h] 00D6 00 0000000000000034
[A] CODE:                                     PUSHi <hnd>                                                     ;[00000000000008F3h] 00D2 00 0000000000000030
[A] CODE:                                     PUSHr <filename>                                                ;[00000000000008FEh] 00D5 00 0000000000000010
[A] CODE:                                     PUSHi (I)1                                                      ;[0000000000000909h] 00D2 80 00000001
[A] CODE:                                     SCALL (I)19                                                     ;[0000000000000910h] 00E9 80 00000013
[E] Token func(standard.openread,3) --> Operand stack {var:(bool)$Bol000t}
[E] .......... Processing token opr! ..........
[E] Temp variable $Bol000t released
[E] Source used flag set on variable $Bol000t in scope {Loc:read}
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[A] CODE:                                     LNOT <$Bol000t>,<$Bol000t>                                      ;[0000000000000917h] 0031 00 0000000000000034 0000000000000034
[E] Token opr! --> Operand stack {var:(bool)$Bol000t}
[E] Source used flag set on variable $Bol000t in scope {Loc:read}
[E] Result token: var:(bool)$Bol000t
[J] Stored jump origin: scopedepth=2 label=000002ifs-cond1 codeadr=0000000000000935h instadr=000000000000092Ah
[A] CODE:                                     JMPFL <$Bol000t>,{000002ifs-cond1}                              ;[000000000000092Ah] 0135 20 0000000000000034 {000002ifs-cond1}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):543:16: "    return false"
[P] Parsed sentence: [Return] kw(return) bo(false)
[J] Sentence labels: BaseLabel=2 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;return false
[E] ExprCompiler input: [Return] bo(false)
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: {K}0B
[E] RPN ouput: {K}0B
[E] Expression is computed, not compiled
[E] Token {K}0B --> Operand stack {{K}0B}
[E] Result token: {K}0B
[A] CODE:                                     MVb *<$result>,(B)false                                         ;[000000000000093Dh] 0076 60 0000000000000000 00
[A] CODE:                                     RET                                                             ;[0000000000000949h] 00E6
[P] -------------------------------------------------------------------------------------
[L] Read line (src):544:5: "  :if"
[P] Parsed sentence: [EndIf] kw(:if)
[J] Sentence labels: BaseLabel=2 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: EndCase GlobalBaseLabel=2
[B] Code block stack updated: Pop --> {Implementation:0:0 Local:0:0}  
[A] CODE: 
[A] CODE:                                     ;:if
[J] Stored jump destination: scopedepth=2 label=000002ifs-cond1 address=000000000000094Bh
[J] Stored jump destination: scopedepth=2 label=000002ifs-exit address=000000000000094Bh
[P] -------------------------------------------------------------------------------------
[L] Read line (src):545:22: "  if(!read(hnd,line)):"
[P] Parsed sentence: [If] kw(if) pu(() op(!) id(read) pu(() id(hnd) pu(,) id(line) pu()) pu()) pu(:)
[J] Sentence labels: BaseLabel=3 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: FirstCase GlobalBaseLabel=3
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0 If:3:0}  
[A] CODE: 
[A] CODE:                                     ;if(!read(hnd,line)):
[E] ExprCompiler input: [If] op(!) id(read) pu(() id(hnd) pu(,) id(line) pu())
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: opr! func(standard.read,2) ( var:(int)hnd , ind:(string[])line )
[E] RPN ouput: var:(int)hnd ind:(string[])line func(standard.read,2) opr!
[E] .......... Processing token var:(int)hnd ..........
[E] Token var:(int)hnd --> Operand stack {var:(int)hnd}
[E] .......... Processing token ind:(string[])line ..........
[E] Token ind:(string[])line --> Operand stack {var:(int)hnd ind:(string[])line}
[E] .......... Processing token func(standard.read,2) ..........
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[E] Source used flag set on variable hnd in scope {Loc:read}
[E] Source used flag set on variable line in scope {Loc:read}
[A] CODE: {000002ifs-exit}:                   
[A] CODE: {000002ifs-cond1}:                  REFPU <$Bol000t>                                                ;[000000000000094Bh] 00D6 00 0000000000000034
[A] CODE:                                     PUSHi <hnd>                                                     ;[0000000000000956h] 00D2 00 0000000000000030
[A] CODE:                                     PUSHr <line>                                                    ;[0000000000000961h] 00D5 00 0000000000000020
[A] CODE:                                     SCALL (I)27                                                     ;[000000000000096Ch] 00E9 80 0000001B
[E] Token func(standard.read,2) --> Operand stack {var:(bool)$Bol000t}
[E] .......... Processing token opr! ..........
[E] Temp variable $Bol000t released
[E] Source used flag set on variable $Bol000t in scope {Loc:read}
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[A] CODE:                                     LNOT <$Bol000t>,<$Bol000t>                                      ;[0000000000000973h] 0031 00 0000000000000034 0000000000000034
[E] Token opr! --> Operand stack {var:(bool)$Bol000t}
[E] Source used flag set on variable $Bol000t in scope {Loc:read}
[E] Result token: var:(bool)$Bol000t
[J] Stored jump origin: scopedepth=2 label=000003ifs-cond1 codeadr=0000000000000991h instadr=0000000000000986h
[A] CODE:                                     JMPFL <$Bol000t>,{000003ifs-cond1}                              ;[0000000000000986h] 0135 20 0000000000000034 {000003ifs-cond1}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):546:16: "    return false"
[P] Parsed sentence: [Return] kw(return) bo(false)
[J] Sentence labels: BaseLabel=3 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;return false
[E] ExprCompiler input: [Return] bo(false)
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: {K}0B
[E] RPN ouput: {K}0B
[E] Expression is computed, not compiled
[E] Token {K}0B --> Operand stack {{K}0B}
[E] Result token: {K}0B
[A] CODE:                                     MVb *<$result>,(B)false                                         ;[0000000000000999h] 0076 60 0000000000000000 00
[A] CODE:                                     RET                                                             ;[00000000000009A5h] 00E6
[P] -------------------------------------------------------------------------------------
[L] Read line (src):547:5: "  :if"
[P] Parsed sentence: [EndIf] kw(:if)
[J] Sentence labels: BaseLabel=3 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: EndCase GlobalBaseLabel=3
[B] Code block stack updated: Pop --> {Implementation:0:0 Local:0:0}  
[A] CODE: 
[A] CODE:                                     ;:if
[J] Stored jump destination: scopedepth=2 label=000003ifs-cond1 address=00000000000009A7h
[J] Stored jump destination: scopedepth=2 label=000003ifs-exit address=00000000000009A7h
[P] -------------------------------------------------------------------------------------
[L] Read line (src):548:22: "  if(!closefile(hnd)):"
[P] Parsed sentence: [If] kw(if) pu(() op(!) id(closefile) pu(() id(hnd) pu()) pu()) pu(:)
[J] Sentence labels: BaseLabel=4 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: FirstCase GlobalBaseLabel=4
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0 If:4:0}  
[A] CODE: 
[A] CODE:                                     ;if(!closefile(hnd)):
[E] ExprCompiler input: [If] op(!) id(closefile) pu(() id(hnd) pu())
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: opr! func(standard.closefile,1) ( var:(int)hnd )
[E] RPN ouput: var:(int)hnd func(standard.closefile,1) opr!
[E] .......... Processing token var:(int)hnd ..........
[E] Token var:(int)hnd --> Operand stack {var:(int)hnd}
[E] .......... Processing token func(standard.closefile,1) ..........
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[E] Source used flag set on variable hnd in scope {Loc:read}
[A] CODE: {000003ifs-exit}:                   
[A] CODE: {000003ifs-cond1}:                  REFPU <$Bol000t>                                                ;[00000000000009A7h] 00D6 00 0000000000000034
[A] CODE:                                     PUSHi <hnd>                                                     ;[00000000000009B2h] 00D2 00 0000000000000030
[A] CODE:                                     SCALL (I)30                                                     ;[00000000000009BDh] 00E9 80 0000001E
[E] Token func(standard.closefile,1) --> Operand stack {var:(bool)$Bol000t}
[E] .......... Processing token opr! ..........
[E] Temp variable $Bol000t released
[E] Source used flag set on variable $Bol000t in scope {Loc:read}
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[A] CODE:                                     LNOT <$Bol000t>,<$Bol000t>                                      ;[00000000000009C4h] 0031 00 0000000000000034 0000000000000034
[E] Token opr! --> Operand stack {var:(bool)$Bol000t}
[E] Source used flag set on variable $Bol000t in scope {Loc:read}
[E] Result token: var:(bool)$Bol000t
[J] Stored jump origin: scopedepth=2 label=000004ifs-cond1 codeadr=00000000000009E2h instadr=00000000000009D7h
[A] CODE:                                     JMPFL <$Bol000t>,{000004ifs-cond1}                              ;[00000000000009D7h] 0135 20 0000000000000034 {000004ifs-cond1}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):549:16: "    return false"
[P] Parsed sentence: [Return] kw(return) bo(false)
[J] Sentence labels: BaseLabel=4 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;return false
[E] ExprCompiler input: [Return] bo(false)
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: {K}0B
[E] RPN ouput: {K}0B
[E] Expression is computed, not compiled
[E] Token {K}0B --> Operand stack {{K}0B}
[E] Result token: {K}0B
[A] CODE:                                     MVb *<$result>,(B)false                                         ;[00000000000009EAh] 0076 60 0000000000000000 00
[A] CODE:                                     RET                                                             ;[00000000000009F6h] 00E6
[P] -------------------------------------------------------------------------------------
[L] Read line (src):550:5: "  :if"
[P] Parsed sentence: [EndIf] kw(:if)
[J] Sentence labels: BaseLabel=4 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: EndCase GlobalBaseLabel=4
[B] Code block stack updated: Pop --> {Implementation:0:0 Local:0:0}  
[A] CODE: 
[A] CODE:                                     ;:if
[J] Stored jump destination: scopedepth=2 label=000004ifs-cond1 address=00000000000009F8h
[J] Stored jump destination: scopedepth=2 label=000004ifs-exit address=00000000000009F8h
[P] -------------------------------------------------------------------------------------
[L] Read line (src):551:14: "  freehnd(hnd)"
[P] Parsed sentence: [Expression] id(freehnd) pu(() id(hnd) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;freehnd(hnd)
[E] ExprCompiler input: [Expression] id(freehnd) pu(() id(hnd) pu())
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: func(standard.freehnd,1) ( var:(int)hnd )
[E] RPN ouput: var:(int)hnd func(standard.freehnd,1)
[E] .......... Processing token var:(int)hnd ..........
[E] Token var:(int)hnd --> Operand stack {var:(int)hnd}
[E] .......... Processing token func(standard.freehnd,1) ..........
[E] Source used flag set on variable hnd in scope {Loc:read}
[A] CODE: {000004ifs-exit}:                   
[A] CODE: {000004ifs-cond1}:                  PUSHi <hnd>                                                     ;[00000000000009F8h] 00D2 00 0000000000000030
[A] CODE:                                     SCALL (I)18                                                     ;[0000000000000A03h] 00E9 80 00000012
[E] Token func(standard.freehnd,1) --> Operand stack {}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):552:13: "  return true"
[P] Parsed sentence: [Return] kw(return) bo(true)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;return true
[E] ExprCompiler input: [Return] bo(true)
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: {K}1B
[E] RPN ouput: {K}1B
[E] Expression is computed, not compiled
[E] Token {K}1B --> Operand stack {{K}1B}
[E] Result token: {K}1B
[A] CODE:                                     MVb *<$result>,(B)true                                          ;[0000000000000A0Ah] 0076 60 0000000000000000 01
[A] CODE:                                     RET                                                             ;[0000000000000A16h] 00E6
[P] -------------------------------------------------------------------------------------
[L] Read line (src):553:5: ":func"
[P] Parsed sentence: [EndFunction] kw(:func)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[J] Jump event: BlockEnd GlobalBaseLabel=4
[B] Code block stack updated: Pop --> {Implementation:0:0}  
[S] Scope close: {Loc:read}
[J] Solving jump labels for scope depth 2...
[J] Solved jump: scopedepth=2 codeadr=00000000000008D2h instadr=00000000000008C7h destadr=00000000000008E8h relative=0000000000000021h label=000001ifs-cond1
[J] Solved jump: scopedepth=2 codeadr=0000000000000935h instadr=000000000000092Ah destadr=000000000000094Bh relative=0000000000000021h label=000002ifs-cond1
[J] Solved jump: scopedepth=2 codeadr=0000000000000991h instadr=0000000000000986h destadr=00000000000009A7h relative=0000000000000021h label=000003ifs-cond1
[J] Solved jump: scopedepth=2 codeadr=00000000000009E2h instadr=00000000000009D7h destadr=00000000000009F8h relative=0000000000000021h label=000004ifs-cond1
[A] FOOT: 
[A] FOOT: ; Jump addresses on scope {Loc:read} (depth=2):
[A] FOOT: ; [00000000000008E8h] = {000001ifs-cond1}
[A] FOOT: ; [00000000000008E8h] = {000001ifs-exit}
[A] FOOT: ; [000000000000094Bh] = {000002ifs-cond1}
[A] FOOT: ; [000000000000094Bh] = {000002ifs-exit}
[A] FOOT: ; [00000000000009A7h] = {000003ifs-cond1}
[A] FOOT: ; [00000000000009A7h] = {000003ifs-exit}
[A] FOOT: ; [00000000000009F8h] = {000004ifs-cond1}
[A] FOOT: ; [00000000000009F8h] = {000004ifs-exit}
[F] Solving forward calls for scope depth 2...
[F] Addr: ScopeDepth=0 Function=standard.$initsuper()
[F] Addr: ScopeDepth=0 Function=standard.getarchitecture()
[F] Addr: ScopeDepth=0 Function=standard.gethostsystem()
[F] Addr: ScopeDepth=0 Function=standard.gethostsystemname()
[F] Addr: ScopeDepth=0 Function=standard.panic(string)
[F] Addr: ScopeDepth=0 Function=standard.read(string,char[])
[F] Addr: ScopeDepth=0 Function=standard.read(string,string)
[F] Addr: ScopeDepth=0 Function=standard.read(string,string[])
[F] Addr: ScopeDepth=0 Function=standard.write(string,char[])
[F] Addr: ScopeDepth=0 Function=standard.write(string,string)
[F] Addr: ScopeDepth=1 Function=standard.$initstandard()
[F] Call: ScopeDepth=1 Function=standard.$delayedinitstandard()
[S] Current scope: {Pri:main}, StackLength=2
[A] HEAD: (standard_read7)                    FUNCTION
[A] CODE: 
[A] CODE:                                     ;End function
[A] CODE:                                     END
[P] -------------------------------------------------------------------------------------
[L] Read line (src):556:47: "func bool write(string filename,string[] line):"
[P] Parsed sentence: [Function] kw(func) ty(bool) id(write) pu(() ty(string) id(filename) pu(,) ty(string) pu([) pu(]) id(line) pu()) pu(:)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[J] Jump event: BlockBeg GlobalBaseLabel=0
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0}  
[A] HEAD: 
[A] HEAD: ;---------------------------------------------------------------------------------------------------
[A] HEAD: ; func bool write(string filename,string[] line):
[A] HEAD: ;---------------------------------------------------------------------------------------------------
[A] HEAD: 
[F] Stored function address: id=standard_write7 fullname=standard.write(string,string[]) address=0000000000000A18h scopedepth=0
[Y] Update OFUN[179]: Address=2584
[A] CODE:                                     ;Reserve function stack size
[A] CODE:                                     STACK %TEXTARG0%                                                ;[0000000000000A18h] 00BB 80 %HEXARG0%
[S] Scope open: {Loc:write}
[A] DECL:                                     ;Parameters
[D] VAR[10]: name=$result type=bool scope={Loc:write} address=0 const=no static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.$result index=10 searchindex=0, scope={Loc:write}
[A] DECL: <$result>                           PARM REFERENCE                                                  ;Address=<0000000000000000h>
[D] VAR[11]: name=filename type=string scope={Loc:write} address=16 const=yes static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.filename index=11 searchindex=1, scope={Loc:write}
[A] DECL: <filename>                          PARM CONST REFERENCE                                            ;Address=<0000000000000010h>
[D] VAR[12]: name=line type=string[] scope={Loc:write} address=32 const=yes static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.line index=12 searchindex=2, scope={Loc:write}
[A] DECL: <line>                              PARM CONST REFERENCE                                            ;Address=<0000000000000020h>
[A] DECL: 
[S] Current scope: {Loc:write}, StackLength=3
[P] -------------------------------------------------------------------------------------
[L] Read line (src):557:11: "  int hnd=0"
[P] Parsed sentence: [VarDecl] ty(int) id(hnd) op(=) ch(0R)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;int hnd=0
[O] Relocation added: Type=BlkInsideGlo, LocAdr=0000000000000124h
[A] DATA:                                     STORE "hnd"                                                     ;Address=[0000000000000124h]
[D] VAR[13]: name=hnd type=int scope={Loc:write} address=48 const=no static=no parameter=no ref=no temp=no buffstore=yes length=4
[I] VAR: name=standard.hnd index=13 searchindex=2, scope={Loc:write}
[A] CODE: 
[A] CODE:                                     ;int hnd=0
[E] ExprCompiler input: [VarDecl] ch(0R)
[E] Release all temp variables
[E] Tokenizer ouput: {K}0C
[E] RPN ouput: {K}0C
[E] Expression is computed, not compiled
[E] Token {K}0C --> Operand stack {{K}0C}
[E] Result token: {K}0C
[A] CODE:                                     MVi <hnd>,(I)0                                                  ;[0000000000000A23h] 0079 20 0000000000000030 00000000
[A] DECL: <hnd>                               VAR INTEGER                                                     ;Address=<0000000000000030h> = (I)0 { int hnd=0 }
[P] -------------------------------------------------------------------------------------
[L] Read line (src):558:19: "  if(!newhnd(hnd)):"
[P] Parsed sentence: [If] kw(if) pu(() op(!) id(newhnd) pu(() id(hnd) pu()) pu()) pu(:)
[J] Sentence labels: BaseLabel=1 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: FirstCase GlobalBaseLabel=1
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0 If:1:0}  
[A] CODE: 
[A] CODE:                                     ;if(!newhnd(hnd)):
[E] ExprCompiler input: [If] op(!) id(newhnd) pu(() id(hnd) pu())
[E] Release all temp variables
[E] Tokenizer ouput: opr! func(standard.newhnd,1) ( var:(int)hnd )
[E] RPN ouput: var:(int)hnd func(standard.newhnd,1) opr!
[E] .......... Processing token var:(int)hnd ..........
[E] Token var:(int)hnd --> Operand stack {var:(int)hnd}
[E] .......... Processing token func(standard.newhnd,1) ..........
[E] Requested new temp variable for type=bool reference=false kind=regular
[D] VAR[14]: name=$Bol000t type=bool scope={Loc:write} address=52 const=no static=no parameter=no ref=no temp=yes buffstore=yes length=1
[I] VAR: name=standard.$Bol000t index=14 searchindex=0, scope={Loc:write}
[E] New temp variable $Bol000t created (type=bool reference=false kind=regular)
[A] TEMP: <$Bol000t>                          VAR BOOLEAN                                                     ;Address=<0000000000000034h>
[E] Source used flag set on variable hnd in scope {Loc:write}
[A] CODE:                                     REFPU <$Bol000t>                                                ;[0000000000000A32h] 00D6 00 0000000000000034
[A] CODE:                                     REFPU <hnd>                                                     ;[0000000000000A3Dh] 00D6 00 0000000000000030
[A] CODE:                                     SCALL (I)17                                                     ;[0000000000000A48h] 00E9 80 00000011
[E] Token func(standard.newhnd,1) --> Operand stack {var:(bool)$Bol000t}
[E] .......... Processing token opr! ..........
[E] Temp variable $Bol000t released
[E] Source used flag set on variable $Bol000t in scope {Loc:write}
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[A] CODE:                                     LNOT <$Bol000t>,<$Bol000t>                                      ;[0000000000000A4Fh] 0031 00 0000000000000034 0000000000000034
[E] Token opr! --> Operand stack {var:(bool)$Bol000t}
[E] Source used flag set on variable $Bol000t in scope {Loc:write}
[E] Result token: var:(bool)$Bol000t
[J] Stored jump origin: scopedepth=2 label=000001ifs-cond1 codeadr=0000000000000A6Dh instadr=0000000000000A62h
[A] CODE:                                     JMPFL <$Bol000t>,{000001ifs-cond1}                              ;[0000000000000A62h] 0135 20 0000000000000034 {000001ifs-cond1}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):559:16: "    return false"
[P] Parsed sentence: [Return] kw(return) bo(false)
[J] Sentence labels: BaseLabel=1 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;return false
[E] ExprCompiler input: [Return] bo(false)
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: {K}0B
[E] RPN ouput: {K}0B
[E] Expression is computed, not compiled
[E] Token {K}0B --> Operand stack {{K}0B}
[E] Result token: {K}0B
[A] CODE:                                     MVb *<$result>,(B)false                                         ;[0000000000000A75h] 0076 60 0000000000000000 00
[A] CODE:                                     RET                                                             ;[0000000000000A81h] 00E6
[P] -------------------------------------------------------------------------------------
[L] Read line (src):560:5: "  :if"
[P] Parsed sentence: [EndIf] kw(:if)
[J] Sentence labels: BaseLabel=1 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: EndCase GlobalBaseLabel=1
[B] Code block stack updated: Pop --> {Implementation:0:0 Local:0:0}  
[A] CODE: 
[A] CODE:                                     ;:if
[J] Stored jump destination: scopedepth=2 label=000001ifs-cond1 address=0000000000000A83h
[J] Stored jump destination: scopedepth=2 label=000001ifs-exit address=0000000000000A83h
[P] -------------------------------------------------------------------------------------
[L] Read line (src):561:47: "  if(!openwrite(hnd,filename,filemode.binary)):"
[P] Parsed sentence: [If] kw(if) pu(() op(!) id(openwrite) pu(() id(hnd) pu(,) id(filename) pu(,) ty(filemode) op(.) id(binary) pu()) pu()) pu(:)
[J] Sentence labels: BaseLabel=2 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: FirstCase GlobalBaseLabel=2
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0 If:2:0}  
[A] CODE: 
[A] CODE:                                     ;if(!openwrite(hnd,filename,filemode.binary)):
[E] ExprCompiler input: [If] op(!) id(openwrite) pu(() id(hnd) pu(,) id(filename) pu(,) ty(filemode) op(.) id(binary) pu())
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: opr! func(standard.openwrite,3) ( var:(int)hnd , {K}ind:(string)filename , {K}Enu:filemode:1 )
[E] RPN ouput: var:(int)hnd {K}ind:(string)filename {K}Enu:filemode:1 func(standard.openwrite,3) opr!
[E] .......... Processing token var:(int)hnd ..........
[E] Token var:(int)hnd --> Operand stack {var:(int)hnd}
[E] .......... Processing token {K}ind:(string)filename ..........
[E] Token {K}ind:(string)filename --> Operand stack {var:(int)hnd {K}ind:(string)filename}
[E] .......... Processing token {K}Enu:filemode:1 ..........
[E] Token {K}Enu:filemode:1 --> Operand stack {var:(int)hnd {K}ind:(string)filename {K}Enu:filemode:1}
[E] .......... Processing token func(standard.openwrite,3) ..........
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[E] Source used flag set on variable hnd in scope {Loc:write}
[E] Source used flag set on variable filename in scope {Loc:write}
[A] CODE: {000001ifs-exit}:                   
[A] CODE: {000001ifs-cond1}:                  REFPU <$Bol000t>                                                ;[0000000000000A83h] 00D6 00 0000000000000034
[A] CODE:                                     PUSHi <hnd>                                                     ;[0000000000000A8Eh] 00D2 00 0000000000000030
[A] CODE:                                     PUSHr <filename>                                                ;[0000000000000A99h] 00D5 00 0000000000000010
[A] CODE:                                     PUSHi (I)1                                                      ;[0000000000000AA4h] 00D2 80 00000001
[A] CODE:                                     SCALL (I)20                                                     ;[0000000000000AABh] 00E9 80 00000014
[E] Token func(standard.openwrite,3) --> Operand stack {var:(bool)$Bol000t}
[E] .......... Processing token opr! ..........
[E] Temp variable $Bol000t released
[E] Source used flag set on variable $Bol000t in scope {Loc:write}
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[A] CODE:                                     LNOT <$Bol000t>,<$Bol000t>                                      ;[0000000000000AB2h] 0031 00 0000000000000034 0000000000000034
[E] Token opr! --> Operand stack {var:(bool)$Bol000t}
[E] Source used flag set on variable $Bol000t in scope {Loc:write}
[E] Result token: var:(bool)$Bol000t
[J] Stored jump origin: scopedepth=2 label=000002ifs-cond1 codeadr=0000000000000AD0h instadr=0000000000000AC5h
[A] CODE:                                     JMPFL <$Bol000t>,{000002ifs-cond1}                              ;[0000000000000AC5h] 0135 20 0000000000000034 {000002ifs-cond1}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):562:16: "    return false"
[P] Parsed sentence: [Return] kw(return) bo(false)
[J] Sentence labels: BaseLabel=2 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;return false
[E] ExprCompiler input: [Return] bo(false)
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: {K}0B
[E] RPN ouput: {K}0B
[E] Expression is computed, not compiled
[E] Token {K}0B --> Operand stack {{K}0B}
[E] Result token: {K}0B
[A] CODE:                                     MVb *<$result>,(B)false                                         ;[0000000000000AD8h] 0076 60 0000000000000000 00
[A] CODE:                                     RET                                                             ;[0000000000000AE4h] 00E6
[P] -------------------------------------------------------------------------------------
[L] Read line (src):563:5: "  :if"
[P] Parsed sentence: [EndIf] kw(:if)
[J] Sentence labels: BaseLabel=2 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: EndCase GlobalBaseLabel=2
[B] Code block stack updated: Pop --> {Implementation:0:0 Local:0:0}  
[A] CODE: 
[A] CODE:                                     ;:if
[J] Stored jump destination: scopedepth=2 label=000002ifs-cond1 address=0000000000000AE6h
[J] Stored jump destination: scopedepth=2 label=000002ifs-exit address=0000000000000AE6h
[P] -------------------------------------------------------------------------------------
[L] Read line (src):564:23: "  if(!write(hnd,line)):"
[P] Parsed sentence: [If] kw(if) pu(() op(!) id(write) pu(() id(hnd) pu(,) id(line) pu()) pu()) pu(:)
[J] Sentence labels: BaseLabel=3 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: FirstCase GlobalBaseLabel=3
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0 If:3:0}  
[A] CODE: 
[A] CODE:                                     ;if(!write(hnd,line)):
[E] ExprCompiler input: [If] op(!) id(write) pu(() id(hnd) pu(,) id(line) pu())
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: opr! func(standard.write,2) ( var:(int)hnd , {K}ind:(string[])line )
[E] RPN ouput: var:(int)hnd {K}ind:(string[])line func(standard.write,2) opr!
[E] .......... Processing token var:(int)hnd ..........
[E] Token var:(int)hnd --> Operand stack {var:(int)hnd}
[E] .......... Processing token {K}ind:(string[])line ..........
[E] Token {K}ind:(string[])line --> Operand stack {var:(int)hnd {K}ind:(string[])line}
[E] .......... Processing token func(standard.write,2) ..........
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[E] Source used flag set on variable hnd in scope {Loc:write}
[E] Source used flag set on variable line in scope {Loc:write}
[A] CODE: {000002ifs-exit}:                   
[A] CODE: {000002ifs-cond1}:                  REFPU <$Bol000t>                                                ;[0000000000000AE6h] 00D6 00 0000000000000034
[A] CODE:                                     PUSHi <hnd>                                                     ;[0000000000000AF1h] 00D2 00 0000000000000030
[A] CODE:                                     PUSHr <line>                                                    ;[0000000000000AFCh] 00D5 00 0000000000000020
[A] CODE:                                     SCALL (I)28                                                     ;[0000000000000B07h] 00E9 80 0000001C
[E] Token func(standard.write,2) --> Operand stack {var:(bool)$Bol000t}
[E] .......... Processing token opr! ..........
[E] Temp variable $Bol000t released
[E] Source used flag set on variable $Bol000t in scope {Loc:write}
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[A] CODE:                                     LNOT <$Bol000t>,<$Bol000t>                                      ;[0000000000000B0Eh] 0031 00 0000000000000034 0000000000000034
[E] Token opr! --> Operand stack {var:(bool)$Bol000t}
[E] Source used flag set on variable $Bol000t in scope {Loc:write}
[E] Result token: var:(bool)$Bol000t
[J] Stored jump origin: scopedepth=2 label=000003ifs-cond1 codeadr=0000000000000B2Ch instadr=0000000000000B21h
[A] CODE:                                     JMPFL <$Bol000t>,{000003ifs-cond1}                              ;[0000000000000B21h] 0135 20 0000000000000034 {000003ifs-cond1}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):565:16: "    return false"
[P] Parsed sentence: [Return] kw(return) bo(false)
[J] Sentence labels: BaseLabel=3 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;return false
[E] ExprCompiler input: [Return] bo(false)
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: {K}0B
[E] RPN ouput: {K}0B
[E] Expression is computed, not compiled
[E] Token {K}0B --> Operand stack {{K}0B}
[E] Result token: {K}0B
[A] CODE:                                     MVb *<$result>,(B)false                                         ;[0000000000000B34h] 0076 60 0000000000000000 00
[A] CODE:                                     RET                                                             ;[0000000000000B40h] 00E6
[P] -------------------------------------------------------------------------------------
[L] Read line (src):566:5: "  :if"
[P] Parsed sentence: [EndIf] kw(:if)
[J] Sentence labels: BaseLabel=3 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: EndCase GlobalBaseLabel=3
[B] Code block stack updated: Pop --> {Implementation:0:0 Local:0:0}  
[A] CODE: 
[A] CODE:                                     ;:if
[J] Stored jump destination: scopedepth=2 label=000003ifs-cond1 address=0000000000000B42h
[J] Stored jump destination: scopedepth=2 label=000003ifs-exit address=0000000000000B42h
[P] -------------------------------------------------------------------------------------
[L] Read line (src):567:22: "  if(!closefile(hnd)):"
[P] Parsed sentence: [If] kw(if) pu(() op(!) id(closefile) pu(() id(hnd) pu()) pu()) pu(:)
[J] Sentence labels: BaseLabel=4 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: FirstCase GlobalBaseLabel=4
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0 If:4:0}  
[A] CODE: 
[A] CODE:                                     ;if(!closefile(hnd)):
[E] ExprCompiler input: [If] op(!) id(closefile) pu(() id(hnd) pu())
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: opr! func(standard.closefile,1) ( var:(int)hnd )
[E] RPN ouput: var:(int)hnd func(standard.closefile,1) opr!
[E] .......... Processing token var:(int)hnd ..........
[E] Token var:(int)hnd --> Operand stack {var:(int)hnd}
[E] .......... Processing token func(standard.closefile,1) ..........
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[E] Source used flag set on variable hnd in scope {Loc:write}
[A] CODE: {000003ifs-exit}:                   
[A] CODE: {000003ifs-cond1}:                  REFPU <$Bol000t>                                                ;[0000000000000B42h] 00D6 00 0000000000000034
[A] CODE:                                     PUSHi <hnd>                                                     ;[0000000000000B4Dh] 00D2 00 0000000000000030
[A] CODE:                                     SCALL (I)30                                                     ;[0000000000000B58h] 00E9 80 0000001E
[E] Token func(standard.closefile,1) --> Operand stack {var:(bool)$Bol000t}
[E] .......... Processing token opr! ..........
[E] Temp variable $Bol000t released
[E] Source used flag set on variable $Bol000t in scope {Loc:write}
[E] Requested new temp variable for type=bool reference=false kind=regular
[E] Temp variable $Bol000t reused (type=bool reference=false kind=regular)
[A] CODE:                                     LNOT <$Bol000t>,<$Bol000t>                                      ;[0000000000000B5Fh] 0031 00 0000000000000034 0000000000000034
[E] Token opr! --> Operand stack {var:(bool)$Bol000t}
[E] Source used flag set on variable $Bol000t in scope {Loc:write}
[E] Result token: var:(bool)$Bol000t
[J] Stored jump origin: scopedepth=2 label=000004ifs-cond1 codeadr=0000000000000B7Dh instadr=0000000000000B72h
[A] CODE:                                     JMPFL <$Bol000t>,{000004ifs-cond1}                              ;[0000000000000B72h] 0135 20 0000000000000034 {000004ifs-cond1}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):568:16: "    return false"
[P] Parsed sentence: [Return] kw(return) bo(false)
[J] Sentence labels: BaseLabel=4 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;return false
[E] ExprCompiler input: [Return] bo(false)
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: {K}0B
[E] RPN ouput: {K}0B
[E] Expression is computed, not compiled
[E] Token {K}0B --> Operand stack {{K}0B}
[E] Result token: {K}0B
[A] CODE:                                     MVb *<$result>,(B)false                                         ;[0000000000000B85h] 0076 60 0000000000000000 00
[A] CODE:                                     RET                                                             ;[0000000000000B91h] 00E6
[P] -------------------------------------------------------------------------------------
[L] Read line (src):569:5: "  :if"
[P] Parsed sentence: [EndIf] kw(:if)
[J] Sentence labels: BaseLabel=4 SubLabel=0 BlockId={ifs} LoopLabel=-1 LoopId={}
[J] Jump event: EndCase GlobalBaseLabel=4
[B] Code block stack updated: Pop --> {Implementation:0:0 Local:0:0}  
[A] CODE: 
[A] CODE:                                     ;:if
[J] Stored jump destination: scopedepth=2 label=000004ifs-cond1 address=0000000000000B93h
[J] Stored jump destination: scopedepth=2 label=000004ifs-exit address=0000000000000B93h
[P] -------------------------------------------------------------------------------------
[L] Read line (src):570:14: "  freehnd(hnd)"
[P] Parsed sentence: [Expression] id(freehnd) pu(() id(hnd) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;freehnd(hnd)
[E] ExprCompiler input: [Expression] id(freehnd) pu(() id(hnd) pu())
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: func(standard.freehnd,1) ( var:(int)hnd )
[E] RPN ouput: var:(int)hnd func(standard.freehnd,1)
[E] .......... Processing token var:(int)hnd ..........
[E] Token var:(int)hnd --> Operand stack {var:(int)hnd}
[E] .......... Processing token func(standard.freehnd,1) ..........
[E] Source used flag set on variable hnd in scope {Loc:write}
[A] CODE: {000004ifs-exit}:                   
[A] CODE: {000004ifs-cond1}:                  PUSHi <hnd>                                                     ;[0000000000000B93h] 00D2 00 0000000000000030
[A] CODE:                                     SCALL (I)18                                                     ;[0000000000000B9Eh] 00E9 80 00000012
[E] Token func(standard.freehnd,1) --> Operand stack {}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):571:13: "  return true"
[P] Parsed sentence: [Return] kw(return) bo(true)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;return true
[E] ExprCompiler input: [Return] bo(true)
[E] Release all temp variables
[E] Temp variable $Bol000t released
[E] Tokenizer ouput: {K}1B
[E] RPN ouput: {K}1B
[E] Expression is computed, not compiled
[E] Token {K}1B --> Operand stack {{K}1B}
[E] Result token: {K}1B
[A] CODE:                                     MVb *<$result>,(B)true                                          ;[0000000000000BA5h] 0076 60 0000000000000000 01
[A] CODE:                                     RET                                                             ;[0000000000000BB1h] 00E6
[P] -------------------------------------------------------------------------------------
[L] Read line (src):572:5: ":func"
[P] Parsed sentence: [EndFunction] kw(:func)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[J] Jump event: BlockEnd GlobalBaseLabel=4
[B] Code block stack updated: Pop --> {Implementation:0:0}  
[S] Scope close: {Loc:write}
[J] Solving jump labels for scope depth 2...
[J] Solved jump: scopedepth=2 codeadr=0000000000000A6Dh instadr=0000000000000A62h destadr=0000000000000A83h relative=0000000000000021h label=000001ifs-cond1
[J] Solved jump: scopedepth=2 codeadr=0000000000000AD0h instadr=0000000000000AC5h destadr=0000000000000AE6h relative=0000000000000021h label=000002ifs-cond1
[J] Solved jump: scopedepth=2 codeadr=0000000000000B2Ch instadr=0000000000000B21h destadr=0000000000000B42h relative=0000000000000021h label=000003ifs-cond1
[J] Solved jump: scopedepth=2 codeadr=0000000000000B7Dh instadr=0000000000000B72h destadr=0000000000000B93h relative=0000000000000021h label=000004ifs-cond1
[A] FOOT: 
[A] FOOT: ; Jump addresses on scope {Loc:write} (depth=2):
[A] FOOT: ; [0000000000000A83h] = {000001ifs-cond1}
[A] FOOT: ; [0000000000000A83h] = {000001ifs-exit}
[A] FOOT: ; [0000000000000AE6h] = {000002ifs-cond1}
[A] FOOT: ; [0000000000000AE6h] = {000002ifs-exit}
[A] FOOT: ; [0000000000000B42h] = {000003ifs-cond1}
[A] FOOT: ; [0000000000000B42h] = {000003ifs-exit}
[A] FOOT: ; [0000000000000B93h] = {000004ifs-cond1}
[A] FOOT: ; [0000000000000B93h] = {000004ifs-exit}
[F] Solving forward calls for scope depth 2...
[F] Addr: ScopeDepth=0 Function=standard.$initsuper()
[F] Addr: ScopeDepth=0 Function=standard.getarchitecture()
[F] Addr: ScopeDepth=0 Function=standard.gethostsystem()
[F] Addr: ScopeDepth=0 Function=standard.gethostsystemname()
[F] Addr: ScopeDepth=0 Function=standard.panic(string)
[F] Addr: ScopeDepth=0 Function=standard.read(string,char[])
[F] Addr: ScopeDepth=0 Function=standard.read(string,string)
[F] Addr: ScopeDepth=0 Function=standard.read(string,string[])
[F] Addr: ScopeDepth=0 Function=standard.write(string,char[])
[F] Addr: ScopeDepth=0 Function=standard.write(string,string)
[F] Addr: ScopeDepth=0 Function=standard.write(string,string[])
[F] Addr: ScopeDepth=1 Function=standard.$initstandard()
[F] Call: ScopeDepth=1 Function=standard.$delayedinitstandard()
[S] Current scope: {Pri:main}, StackLength=2
[A] HEAD: (standard_write7)                   FUNCTION
[A] CODE: 
[A] CODE:                                     ;End function
[A] CODE:                                     END
[P] -------------------------------------------------------------------------------------
[L] Read line (src):575:86: "func bool execute(string execfile,string arg,ref string[] stdout,ref string[] stderr):"
[P] Parsed sentence: [Function] kw(func) ty(bool) id(execute) pu(() ty(string) id(execfile) pu(,) ty(string) id(arg) pu(,) kw(ref) ty(string) pu([) pu(]) id(stdout) pu(,) kw(ref) ty(string) pu([) pu(]) id(stderr) pu()) pu(:)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[J] Jump event: BlockBeg GlobalBaseLabel=0
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0}  
[A] HEAD: 
[A] HEAD: ;---------------------------------------------------------------------------------------------------
[A] HEAD: ; func bool execute(string execfile,string arg,ref string[] stdout,ref string[] stderr):
[A] HEAD: ;---------------------------------------------------------------------------------------------------
[A] HEAD: 
[F] Stored function address: id=standard_execute2 fullname=standard.execute(string,string,string[],string[]) address=0000000000000BB3h scopedepth=0
[Y] Update OFUN[224]: Address=2995
[A] CODE:                                     ;Reserve function stack size
[A] CODE:                                     STACK %TEXTARG0%                                                ;[0000000000000BB3h] 00BB 80 %HEXARG0%
[S] Scope open: {Loc:execute}
[A] DECL:                                     ;Parameters
[D] VAR[10]: name=$result type=bool scope={Loc:execute} address=0 const=no static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.$result index=10 searchindex=0, scope={Loc:execute}
[A] DECL: <$result>                           PARM REFERENCE                                                  ;Address=<0000000000000000h>
[D] VAR[11]: name=execfile type=string scope={Loc:execute} address=16 const=yes static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.execfile index=11 searchindex=1, scope={Loc:execute}
[A] DECL: <execfile>                          PARM CONST REFERENCE                                            ;Address=<0000000000000010h>
[D] VAR[12]: name=arg type=string scope={Loc:execute} address=32 const=yes static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.arg index=12 searchindex=1, scope={Loc:execute}
[A] DECL: <arg>                               PARM CONST REFERENCE                                            ;Address=<0000000000000020h>
[D] VAR[13]: name=stdout type=string[] scope={Loc:execute} address=48 const=no static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.stdout index=13 searchindex=3, scope={Loc:execute}
[A] DECL: <stdout>                            PARM REFERENCE                                                  ;Address=<0000000000000030h>
[D] VAR[14]: name=stderr type=string[] scope={Loc:execute} address=64 const=no static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.stderr index=14 searchindex=3, scope={Loc:execute}
[A] DECL: <stderr>                            PARM REFERENCE                                                  ;Address=<0000000000000040h>
[A] DECL: 
[S] Current scope: {Loc:execute}, StackLength=3
[P] -------------------------------------------------------------------------------------
[L] Read line (src):576:50: "  return execute(execfile,arg,stdout,stderr,false)"
[P] Parsed sentence: [Return] kw(return) id(execute) pu(() id(execfile) pu(,) id(arg) pu(,) id(stdout) pu(,) id(stderr) pu(,) bo(false) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;return execute(execfile,arg,stdout,stderr,false)
[E] ExprCompiler input: [Return] id(execute) pu(() id(execfile) pu(,) id(arg) pu(,) id(stdout) pu(,) id(stderr) pu(,) bo(false) pu())
[E] Release all temp variables
[E] Tokenizer ouput: func(standard.execute,5) ( {K}ind:(string)execfile , {K}ind:(string)arg , ind:(string[])stdout , ind:(string[])stderr , {K}0B )
[E] RPN ouput: {K}ind:(string)execfile {K}ind:(string)arg ind:(string[])stdout ind:(string[])stderr {K}0B func(standard.execute,5)
[E] .......... Processing token {K}ind:(string)execfile ..........
[E] Token {K}ind:(string)execfile --> Operand stack {{K}ind:(string)execfile}
[E] .......... Processing token {K}ind:(string)arg ..........
[E] Token {K}ind:(string)arg --> Operand stack {{K}ind:(string)execfile {K}ind:(string)arg}
[E] .......... Processing token ind:(string[])stdout ..........
[E] Token ind:(string[])stdout --> Operand stack {{K}ind:(string)execfile {K}ind:(string)arg ind:(string[])stdout}
[E] .......... Processing token ind:(string[])stderr ..........
[E] Token ind:(string[])stderr --> Operand stack {{K}ind:(string)execfile {K}ind:(string)arg ind:(string[])stdout ind:(string[])stderr}
[E] .......... Processing token {K}0B ..........
[E] Token {K}0B --> Operand stack {{K}ind:(string)execfile {K}ind:(string)arg ind:(string[])stdout ind:(string[])stderr {K}0B}
[E] .......... Processing token func(standard.execute,5) ..........
[E] Requested new temp variable for type=bool reference=false kind=regular
[D] VAR[15]: name=$Bol000t type=bool scope={Loc:execute} address=80 const=no static=no parameter=no ref=no temp=yes buffstore=yes length=1
[I] VAR: name=standard.$Bol000t index=15 searchindex=0, scope={Loc:execute}
[E] New temp variable $Bol000t created (type=bool reference=false kind=regular)
[A] TEMP: <$Bol000t>                          VAR BOOLEAN                                                     ;Address=<0000000000000050h>
[E] Source used flag set on variable execfile in scope {Loc:execute}
[E] Source used flag set on variable arg in scope {Loc:execute}
[E] Source used flag set on variable stdout in scope {Loc:execute}
[E] Source used flag set on variable stderr in scope {Loc:execute}
[A] CODE:                                     REFPU <$Bol000t>                                                ;[0000000000000BBEh] 00D6 00 0000000000000050
[A] CODE:                                     PUSHr <execfile>                                                ;[0000000000000BC9h] 00D5 00 0000000000000010
[A] CODE:                                     PUSHr <arg>                                                     ;[0000000000000BD4h] 00D5 00 0000000000000020
[A] CODE:                                     PUSHr <stdout>                                                  ;[0000000000000BDFh] 00D5 00 0000000000000030
[A] CODE:                                     PUSHr <stderr>                                                  ;[0000000000000BEAh] 00D5 00 0000000000000040
[A] CODE:                                     PUSHb (B)false                                                  ;[0000000000000BF5h] 00CF 80 00
[A] CODE:                                     SCALL (I)2                                                      ;[0000000000000BF9h] 00E9 80 00000002
[E] Token func(standard.execute,5) --> Operand stack {var:(bool)$Bol000t}
[E] Source used flag set on variable $Bol000t in scope {Loc:execute}
[E] Result token: var:(bool)$Bol000t
[A] CODE:                                     MVb *<$result>,<$Bol000t>                                       ;[0000000000000C00h] 0076 40 0000000000000000 0000000000000050
[A] CODE:                                     RET                                                             ;[0000000000000C13h] 00E6
[P] -------------------------------------------------------------------------------------
[L] Read line (src):577:5: ":func"
[P] Parsed sentence: [EndFunction] kw(:func)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[J] Jump event: BlockEnd GlobalBaseLabel=0
[B] Code block stack updated: Pop --> {Implementation:0:0}  
[S] Scope close: {Loc:execute}
[J] Solving jump labels for scope depth 2...
[F] Solving forward calls for scope depth 2...
[F] Addr: ScopeDepth=0 Function=standard.$initsuper()
[F] Addr: ScopeDepth=0 Function=standard.execute(string,string,string[],string[])
[F] Addr: ScopeDepth=0 Function=standard.getarchitecture()
[F] Addr: ScopeDepth=0 Function=standard.gethostsystem()
[F] Addr: ScopeDepth=0 Function=standard.gethostsystemname()
[F] Addr: ScopeDepth=0 Function=standard.panic(string)
[F] Addr: ScopeDepth=0 Function=standard.read(string,char[])
[F] Addr: ScopeDepth=0 Function=standard.read(string,string)
[F] Addr: ScopeDepth=0 Function=standard.read(string,string[])
[F] Addr: ScopeDepth=0 Function=standard.write(string,char[])
[F] Addr: ScopeDepth=0 Function=standard.write(string,string)
[F] Addr: ScopeDepth=0 Function=standard.write(string,string[])
[F] Addr: ScopeDepth=1 Function=standard.$initstandard()
[F] Call: ScopeDepth=1 Function=standard.$delayedinitstandard()
[S] Current scope: {Pri:main}, StackLength=2
[A] HEAD: (standard_execute2)                 FUNCTION
[A] CODE: 
[A] CODE:                                     ;End function
[A] CODE:                                     END
[P] -------------------------------------------------------------------------------------
[L] Read line (src):580:66: "func bool execute(string execfile,string arg,ref string[] output):"
[P] Parsed sentence: [Function] kw(func) ty(bool) id(execute) pu(() ty(string) id(execfile) pu(,) ty(string) id(arg) pu(,) kw(ref) ty(string) pu([) pu(]) id(output) pu()) pu(:)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[J] Jump event: BlockBeg GlobalBaseLabel=0
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0}  
[A] HEAD: 
[A] HEAD: ;---------------------------------------------------------------------------------------------------
[A] HEAD: ; func bool execute(string execfile,string arg,ref string[] output):
[A] HEAD: ;---------------------------------------------------------------------------------------------------
[A] HEAD: 
[F] Stored function address: id=standard_execute3 fullname=standard.execute(string,string,string[]) address=0000000000000C15h scopedepth=0
[Y] Update OFUN[225]: Address=3093
[A] CODE:                                     ;Reserve function stack size
[A] CODE:                                     STACK %TEXTARG0%                                                ;[0000000000000C15h] 00BB 80 %HEXARG0%
[S] Scope open: {Loc:execute}
[A] DECL:                                     ;Parameters
[D] VAR[10]: name=$result type=bool scope={Loc:execute} address=0 const=no static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.$result index=10 searchindex=0, scope={Loc:execute}
[A] DECL: <$result>                           PARM REFERENCE                                                  ;Address=<0000000000000000h>
[D] VAR[11]: name=execfile type=string scope={Loc:execute} address=16 const=yes static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.execfile index=11 searchindex=1, scope={Loc:execute}
[A] DECL: <execfile>                          PARM CONST REFERENCE                                            ;Address=<0000000000000010h>
[D] VAR[12]: name=arg type=string scope={Loc:execute} address=32 const=yes static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.arg index=12 searchindex=1, scope={Loc:execute}
[A] DECL: <arg>                               PARM CONST REFERENCE                                            ;Address=<0000000000000020h>
[D] VAR[13]: name=output type=string[] scope={Loc:execute} address=48 const=no static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.output index=13 searchindex=3, scope={Loc:execute}
[A] DECL: <output>                            PARM REFERENCE                                                  ;Address=<0000000000000030h>
[A] DECL: 
[S] Current scope: {Loc:execute}, StackLength=3
[P] -------------------------------------------------------------------------------------
[L] Read line (src):581:30: "  string[] stderr=(string[]){}"
[P] Parsed sentence: [VarDecl] ty(string) pu([) pu(]) id(stderr) op(=) pu(() ty(string) pu([) pu(]) pu()) pu({) pu(})
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;string[] stderr=(string[]){}
[O] Relocation added: Type=BlkInsideGlo, LocAdr=0000000000000128h
[A] DATA:                                     STORE "stderr"                                                  ;Address=[0000000000000128h]
[D] VAR[14]: name=stderr type=string[] scope={Loc:execute} address=64 const=no static=no parameter=no ref=no temp=no buffstore=yes length=4
[I] VAR: name=standard.stderr index=14 searchindex=4, scope={Loc:execute}
[A] CODE: 
[A] CODE:                                     ;string[] stderr=(string[]){}
[E] ExprCompiler input: [VarDecl] pu(() ty(string) pu([) pu(]) pu()) pu({) pu(})
[E] Release all temp variables
[E] Tokenizer ouput: Cpx:string[]:[0] { }
[E] RPN ouput: Cpx:string[]:[0]
[E] .......... Processing token Cpx:string[]:[0] ..........
[E] Requested new temp variable for type=string[] reference=false kind=regular
[D] VAR[15]: name=$Ard000t type=string[] scope={Loc:execute} address=68 const=no static=no parameter=no ref=no temp=yes buffstore=yes length=4
[I] VAR: name=standard.$Ard000t index=15 searchindex=0, scope={Loc:execute}
[E] New temp variable $Ard000t created (type=string[] reference=false kind=regular)
[A] TEMP: <$Ard000t>                          VAR ARRAYBLOCK                                                  ;Address=<0000000000000044h>
[E] Requested new temp variable for type=string[] reference=true kind=regular
[D] VAR[16]: name=$Ref000t type=string[] scope={Loc:execute} address=72 const=no static=no parameter=no ref=yes temp=yes buffstore=yes length=16
[I] VAR: name=standard.$Ref000t index=16 searchindex=1, scope={Loc:execute}
[E] New temp variable $Ref000t created (type=string[] reference=true kind=regular)
[A] TEMP: <$Ref000t>                          VAR REFERENCE                                                   ;Address=<0000000000000048h>
[A] CODE:                                     REFOF <$Ref000t>,<$Ard000t>,(L)0                                ;[0000000000000C20h] 00AE 08 0000000000000048 0000000000000044 0000000000000000
[E] Temp variable $Ref000t released
[E] Token Cpx:string[]:[0] --> Operand stack {var:(string[])$Ard000t}
[E] Source used flag set on variable $Ard000t in scope {Loc:execute}
[E] Result token: var:(string[])$Ard000t
[A] CODE:                                     ACOPY <stderr>,<$Ard000t>                                       ;[0000000000000C3Bh] 00B3 00 0000000000000040 0000000000000044
[0] Started inner block replication (src=var:(string[])$Ard000t dst=var:(string[])stderr)
[A] CODE:                                     RPINI <stderr>,<$Ard000t>                                       ;[0000000000000C4Eh] 00A8 00 0000000000000040 0000000000000044
[0] Entered recursion (phase=1 level=0 cumuloffset=0 type=string[])
[A] CODE:                                     RPARR (L)0                                                      ;[0000000000000C61h] 00AA 80 0000000000000000
[0] Exited recursion (phase=1 level=0)
[0] Entered recursion (phase=2 level=0 cumuloffset=0 type=string[])
[A] CODE:                                     RPLOD (L)0                                                      ;[0000000000000C6Ch] 00AC 80 0000000000000000
[0] Entered recursion (phase=1 level=1 cumuloffset=0 type=string)
[A] CODE:                                       RPSTR (L)0                                                    ;[0000000000000C77h] 00A9 80 0000000000000000
[0] Exited recursion (phase=1 level=1)
[0] Entered recursion (phase=2 level=1 cumuloffset=0 type=string)
[0] Exited recursion (phase=2 level=1)
[A] CODE:                                     RPEND                                                           ;[0000000000000C82h] 00AD
[0] Exited recursion (phase=2 level=0)
[0] Finished inner block replication
[A] DECL: <stderr>                            VAR ARRAYBLOCK                                                  ;Address=<0000000000000040h> = <$Ard000t> { string[] stderr=(string[]){} }
[P] -------------------------------------------------------------------------------------
[L] Read line (src):582:49: "  return execute(execfile,arg,output,stderr,true)"
[P] Parsed sentence: [Return] kw(return) id(execute) pu(() id(execfile) pu(,) id(arg) pu(,) id(output) pu(,) id(stderr) pu(,) bo(true) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;return execute(execfile,arg,output,stderr,true)
[E] ExprCompiler input: [Return] id(execute) pu(() id(execfile) pu(,) id(arg) pu(,) id(output) pu(,) id(stderr) pu(,) bo(true) pu())
[E] Release all temp variables
[E] Temp variable $Ard000t released
[E] Temp variable $Ref000t released
[E] Tokenizer ouput: func(standard.execute,5) ( {K}ind:(string)execfile , {K}ind:(string)arg , ind:(string[])output , var:(string[])stderr , {K}1B )
[E] RPN ouput: {K}ind:(string)execfile {K}ind:(string)arg ind:(string[])output var:(string[])stderr {K}1B func(standard.execute,5)
[E] .......... Processing token {K}ind:(string)execfile ..........
[E] Token {K}ind:(string)execfile --> Operand stack {{K}ind:(string)execfile}
[E] .......... Processing token {K}ind:(string)arg ..........
[E] Token {K}ind:(string)arg --> Operand stack {{K}ind:(string)execfile {K}ind:(string)arg}
[E] .......... Processing token ind:(string[])output ..........
[E] Token ind:(string[])output --> Operand stack {{K}ind:(string)execfile {K}ind:(string)arg ind:(string[])output}
[E] .......... Processing token var:(string[])stderr ..........
[E] Token var:(string[])stderr --> Operand stack {{K}ind:(string)execfile {K}ind:(string)arg ind:(string[])output var:(string[])stderr}
[E] .......... Processing token {K}1B ..........
[E] Token {K}1B --> Operand stack {{K}ind:(string)execfile {K}ind:(string)arg ind:(string[])output var:(string[])stderr {K}1B}
[E] .......... Processing token func(standard.execute,5) ..........
[E] Requested new temp variable for type=bool reference=false kind=regular
[D] VAR[17]: name=$Bol000t type=bool scope={Loc:execute} address=88 const=no static=no parameter=no ref=no temp=yes buffstore=yes length=1
[I] VAR: name=standard.$Bol000t index=17 searchindex=1, scope={Loc:execute}
[E] New temp variable $Bol000t created (type=bool reference=false kind=regular)
[A] TEMP: <$Bol000t>                          VAR BOOLEAN                                                     ;Address=<0000000000000058h>
[E] Source used flag set on variable execfile in scope {Loc:execute}
[E] Source used flag set on variable arg in scope {Loc:execute}
[E] Source used flag set on variable output in scope {Loc:execute}
[E] Source used flag set on variable stderr in scope {Loc:execute}
[A] CODE:                                     REFPU <$Bol000t>                                                ;[0000000000000C84h] 00D6 00 0000000000000058
[A] CODE:                                     PUSHr <execfile>                                                ;[0000000000000C8Fh] 00D5 00 0000000000000010
[A] CODE:                                     PUSHr <arg>                                                     ;[0000000000000C9Ah] 00D5 00 0000000000000020
[A] CODE:                                     PUSHr <output>                                                  ;[0000000000000CA5h] 00D5 00 0000000000000030
[A] CODE:                                     REFPU <stderr>                                                  ;[0000000000000CB0h] 00D6 00 0000000000000040
[A] CODE:                                     PUSHb (B)true                                                   ;[0000000000000CBBh] 00CF 80 01
[A] CODE:                                     SCALL (I)2                                                      ;[0000000000000CBFh] 00E9 80 00000002
[E] Token func(standard.execute,5) --> Operand stack {var:(bool)$Bol000t}
[E] Source used flag set on variable $Bol000t in scope {Loc:execute}
[E] Result token: var:(bool)$Bol000t
[A] CODE:                                     MVb *<$result>,<$Bol000t>                                       ;[0000000000000CC6h] 0076 40 0000000000000000 0000000000000058
[A] CODE:                                     RET                                                             ;[0000000000000CD9h] 00E6
[P] -------------------------------------------------------------------------------------
[L] Read line (src):583:5: ":func"
[P] Parsed sentence: [EndFunction] kw(:func)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[J] Jump event: BlockEnd GlobalBaseLabel=0
[B] Code block stack updated: Pop --> {Implementation:0:0}  
[S] Scope close: {Loc:execute}
[J] Solving jump labels for scope depth 2...
[F] Solving forward calls for scope depth 2...
[F] Addr: ScopeDepth=0 Function=standard.$initsuper()
[F] Addr: ScopeDepth=0 Function=standard.execute(string,string,string[],string[])
[F] Addr: ScopeDepth=0 Function=standard.execute(string,string,string[])
[F] Addr: ScopeDepth=0 Function=standard.getarchitecture()
[F] Addr: ScopeDepth=0 Function=standard.gethostsystem()
[F] Addr: ScopeDepth=0 Function=standard.gethostsystemname()
[F] Addr: ScopeDepth=0 Function=standard.panic(string)
[F] Addr: ScopeDepth=0 Function=standard.read(string,char[])
[F] Addr: ScopeDepth=0 Function=standard.read(string,string)
[F] Addr: ScopeDepth=0 Function=standard.read(string,string[])
[F] Addr: ScopeDepth=0 Function=standard.write(string,char[])
[F] Addr: ScopeDepth=0 Function=standard.write(string,string)
[F] Addr: ScopeDepth=0 Function=standard.write(string,string[])
[F] Addr: ScopeDepth=1 Function=standard.$initstandard()
[F] Call: ScopeDepth=1 Function=standard.$delayedinitstandard()
[S] Current scope: {Pri:main}, StackLength=2
[A] HEAD: (standard_execute3)                 FUNCTION
[A] CODE: 
[A] CODE:                                     ;End function
[A] CODE:                                     END
[P] -------------------------------------------------------------------------------------
[L] Read line (src):586:88: "func bool execute(string execfile,string[] arg,ref string[] stdout,ref string[] stderr):"
[P] Parsed sentence: [Function] kw(func) ty(bool) id(execute) pu(() ty(string) id(execfile) pu(,) ty(string) pu([) pu(]) id(arg) pu(,) kw(ref) ty(string) pu([) pu(]) id(stdout) pu(,) kw(ref) ty(string) pu([) pu(]) id(stderr) pu()) pu(:)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[J] Jump event: BlockBeg GlobalBaseLabel=0
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0}  
[A] HEAD: 
[A] HEAD: ;---------------------------------------------------------------------------------------------------
[A] HEAD: ; func bool execute(string execfile,string[] arg,ref string[] stdout,ref string[] stderr):
[A] HEAD: ;---------------------------------------------------------------------------------------------------
[A] HEAD: 
[F] Stored function address: id=standard_execute5 fullname=standard.execute(string,string[],string[],string[]) address=0000000000000CDBh scopedepth=0
[Y] Update OFUN[227]: Address=3291
[A] CODE:                                     ;Reserve function stack size
[A] CODE:                                     STACK %TEXTARG0%                                                ;[0000000000000CDBh] 00BB 80 %HEXARG0%
[S] Scope open: {Loc:execute}
[A] DECL:                                     ;Parameters
[D] VAR[10]: name=$result type=bool scope={Loc:execute} address=0 const=no static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.$result index=10 searchindex=0, scope={Loc:execute}
[A] DECL: <$result>                           PARM REFERENCE                                                  ;Address=<0000000000000000h>
[D] VAR[11]: name=execfile type=string scope={Loc:execute} address=16 const=yes static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.execfile index=11 searchindex=1, scope={Loc:execute}
[A] DECL: <execfile>                          PARM CONST REFERENCE                                            ;Address=<0000000000000010h>
[D] VAR[12]: name=arg type=string[] scope={Loc:execute} address=32 const=yes static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.arg index=12 searchindex=1, scope={Loc:execute}
[A] DECL: <arg>                               PARM CONST REFERENCE                                            ;Address=<0000000000000020h>
[D] VAR[13]: name=stdout type=string[] scope={Loc:execute} address=48 const=no static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.stdout index=13 searchindex=3, scope={Loc:execute}
[A] DECL: <stdout>                            PARM REFERENCE                                                  ;Address=<0000000000000030h>
[D] VAR[14]: name=stderr type=string[] scope={Loc:execute} address=64 const=no static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.stderr index=14 searchindex=3, scope={Loc:execute}
[A] DECL: <stderr>                            PARM REFERENCE                                                  ;Address=<0000000000000040h>
[A] DECL: 
[S] Current scope: {Loc:execute}, StackLength=3
[P] -------------------------------------------------------------------------------------
[L] Read line (src):587:50: "  return execute(execfile,arg,stdout,stderr,false)"
[P] Parsed sentence: [Return] kw(return) id(execute) pu(() id(execfile) pu(,) id(arg) pu(,) id(stdout) pu(,) id(stderr) pu(,) bo(false) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;return execute(execfile,arg,stdout,stderr,false)
[E] ExprCompiler input: [Return] id(execute) pu(() id(execfile) pu(,) id(arg) pu(,) id(stdout) pu(,) id(stderr) pu(,) bo(false) pu())
[E] Release all temp variables
[E] Tokenizer ouput: func(standard.execute,5) ( {K}ind:(string)execfile , {K}ind:(string[])arg , ind:(string[])stdout , ind:(string[])stderr , {K}0B )
[E] RPN ouput: {K}ind:(string)execfile {K}ind:(string[])arg ind:(string[])stdout ind:(string[])stderr {K}0B func(standard.execute,5)
[E] .......... Processing token {K}ind:(string)execfile ..........
[E] Token {K}ind:(string)execfile --> Operand stack {{K}ind:(string)execfile}
[E] .......... Processing token {K}ind:(string[])arg ..........
[E] Token {K}ind:(string[])arg --> Operand stack {{K}ind:(string)execfile {K}ind:(string[])arg}
[E] .......... Processing token ind:(string[])stdout ..........
[E] Token ind:(string[])stdout --> Operand stack {{K}ind:(string)execfile {K}ind:(string[])arg ind:(string[])stdout}
[E] .......... Processing token ind:(string[])stderr ..........
[E] Token ind:(string[])stderr --> Operand stack {{K}ind:(string)execfile {K}ind:(string[])arg ind:(string[])stdout ind:(string[])stderr}
[E] .......... Processing token {K}0B ..........
[E] Token {K}0B --> Operand stack {{K}ind:(string)execfile {K}ind:(string[])arg ind:(string[])stdout ind:(string[])stderr {K}0B}
[E] .......... Processing token func(standard.execute,5) ..........
[E] Requested new temp variable for type=bool reference=false kind=regular
[D] VAR[15]: name=$Bol000t type=bool scope={Loc:execute} address=80 const=no static=no parameter=no ref=no temp=yes buffstore=yes length=1
[I] VAR: name=standard.$Bol000t index=15 searchindex=0, scope={Loc:execute}
[E] New temp variable $Bol000t created (type=bool reference=false kind=regular)
[A] TEMP: <$Bol000t>                          VAR BOOLEAN                                                     ;Address=<0000000000000050h>
[E] Source used flag set on variable execfile in scope {Loc:execute}
[E] Source used flag set on variable arg in scope {Loc:execute}
[E] Source used flag set on variable stdout in scope {Loc:execute}
[E] Source used flag set on variable stderr in scope {Loc:execute}
[A] CODE:                                     REFPU <$Bol000t>                                                ;[0000000000000CE6h] 00D6 00 0000000000000050
[A] CODE:                                     PUSHr <execfile>                                                ;[0000000000000CF1h] 00D5 00 0000000000000010
[A] CODE:                                     PUSHr <arg>                                                     ;[0000000000000CFCh] 00D5 00 0000000000000020
[A] CODE:                                     PUSHr <stdout>                                                  ;[0000000000000D07h] 00D5 00 0000000000000030
[A] CODE:                                     PUSHr <stderr>                                                  ;[0000000000000D12h] 00D5 00 0000000000000040
[A] CODE:                                     PUSHb (B)false                                                  ;[0000000000000D1Dh] 00CF 80 00
[A] CODE:                                     SCALL (I)3                                                      ;[0000000000000D21h] 00E9 80 00000003
[E] Token func(standard.execute,5) --> Operand stack {var:(bool)$Bol000t}
[E] Source used flag set on variable $Bol000t in scope {Loc:execute}
[E] Result token: var:(bool)$Bol000t
[A] CODE:                                     MVb *<$result>,<$Bol000t>                                       ;[0000000000000D28h] 0076 40 0000000000000000 0000000000000050
[A] CODE:                                     RET                                                             ;[0000000000000D3Bh] 00E6
[P] -------------------------------------------------------------------------------------
[L] Read line (src):588:5: ":func"
[P] Parsed sentence: [EndFunction] kw(:func)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[J] Jump event: BlockEnd GlobalBaseLabel=0
[B] Code block stack updated: Pop --> {Implementation:0:0}  
[S] Scope close: {Loc:execute}
[J] Solving jump labels for scope depth 2...
[F] Solving forward calls for scope depth 2...
[F] Addr: ScopeDepth=0 Function=standard.$initsuper()
[F] Addr: ScopeDepth=0 Function=standard.execute(string,string,string[],string[])
[F] Addr: ScopeDepth=0 Function=standard.execute(string,string,string[])
[F] Addr: ScopeDepth=0 Function=standard.execute(string,string[],string[],string[])
[F] Addr: ScopeDepth=0 Function=standard.getarchitecture()
[F] Addr: ScopeDepth=0 Function=standard.gethostsystem()
[F] Addr: ScopeDepth=0 Function=standard.gethostsystemname()
[F] Addr: ScopeDepth=0 Function=standard.panic(string)
[F] Addr: ScopeDepth=0 Function=standard.read(string,char[])
[F] Addr: ScopeDepth=0 Function=standard.read(string,string)
[F] Addr: ScopeDepth=0 Function=standard.read(string,string[])
[F] Addr: ScopeDepth=0 Function=standard.write(string,char[])
[F] Addr: ScopeDepth=0 Function=standard.write(string,string)
[F] Addr: ScopeDepth=0 Function=standard.write(string,string[])
[F] Addr: ScopeDepth=1 Function=standard.$initstandard()
[F] Call: ScopeDepth=1 Function=standard.$delayedinitstandard()
[S] Current scope: {Pri:main}, StackLength=2
[A] HEAD: (standard_execute5)                 FUNCTION
[A] CODE: 
[A] CODE:                                     ;End function
[A] CODE:                                     END
[P] -------------------------------------------------------------------------------------
[L] Read line (src):591:68: "func bool execute(string execfile,string[] arg,ref string[] output):"
[P] Parsed sentence: [Function] kw(func) ty(bool) id(execute) pu(() ty(string) id(execfile) pu(,) ty(string) pu([) pu(]) id(arg) pu(,) kw(ref) ty(string) pu([) pu(]) id(output) pu()) pu(:)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[J] Jump event: BlockBeg GlobalBaseLabel=0
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0}  
[A] HEAD: 
[A] HEAD: ;---------------------------------------------------------------------------------------------------
[A] HEAD: ; func bool execute(string execfile,string[] arg,ref string[] output):
[A] HEAD: ;---------------------------------------------------------------------------------------------------
[A] HEAD: 
[F] Stored function address: id=standard_execute6 fullname=standard.execute(string,string[],string[]) address=0000000000000D3Dh scopedepth=0
[Y] Update OFUN[228]: Address=3389
[A] CODE:                                     ;Reserve function stack size
[A] CODE:                                     STACK %TEXTARG0%                                                ;[0000000000000D3Dh] 00BB 80 %HEXARG0%
[S] Scope open: {Loc:execute}
[A] DECL:                                     ;Parameters
[D] VAR[10]: name=$result type=bool scope={Loc:execute} address=0 const=no static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.$result index=10 searchindex=0, scope={Loc:execute}
[A] DECL: <$result>                           PARM REFERENCE                                                  ;Address=<0000000000000000h>
[D] VAR[11]: name=execfile type=string scope={Loc:execute} address=16 const=yes static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.execfile index=11 searchindex=1, scope={Loc:execute}
[A] DECL: <execfile>                          PARM CONST REFERENCE                                            ;Address=<0000000000000010h>
[D] VAR[12]: name=arg type=string[] scope={Loc:execute} address=32 const=yes static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.arg index=12 searchindex=1, scope={Loc:execute}
[A] DECL: <arg>                               PARM CONST REFERENCE                                            ;Address=<0000000000000020h>
[D] VAR[13]: name=output type=string[] scope={Loc:execute} address=48 const=no static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.output index=13 searchindex=3, scope={Loc:execute}
[A] DECL: <output>                            PARM REFERENCE                                                  ;Address=<0000000000000030h>
[A] DECL: 
[S] Current scope: {Loc:execute}, StackLength=3
[P] -------------------------------------------------------------------------------------
[L] Read line (src):592:30: "  string[] stderr=(string[]){}"
[P] Parsed sentence: [VarDecl] ty(string) pu([) pu(]) id(stderr) op(=) pu(() ty(string) pu([) pu(]) pu()) pu({) pu(})
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] DECL: 
[A] DECL:                                     ;string[] stderr=(string[]){}
[O] Relocation added: Type=BlkInsideGlo, LocAdr=000000000000012Ch
[A] DATA:                                     STORE "stderr"                                                  ;Address=[000000000000012Ch]
[D] VAR[14]: name=stderr type=string[] scope={Loc:execute} address=64 const=no static=no parameter=no ref=no temp=no buffstore=yes length=4
[I] VAR: name=standard.stderr index=14 searchindex=4, scope={Loc:execute}
[A] CODE: 
[A] CODE:                                     ;string[] stderr=(string[]){}
[E] ExprCompiler input: [VarDecl] pu(() ty(string) pu([) pu(]) pu()) pu({) pu(})
[E] Release all temp variables
[E] Tokenizer ouput: Cpx:string[]:[0] { }
[E] RPN ouput: Cpx:string[]:[0]
[E] .......... Processing token Cpx:string[]:[0] ..........
[E] Requested new temp variable for type=string[] reference=false kind=regular
[D] VAR[15]: name=$Ard000t type=string[] scope={Loc:execute} address=68 const=no static=no parameter=no ref=no temp=yes buffstore=yes length=4
[I] VAR: name=standard.$Ard000t index=15 searchindex=0, scope={Loc:execute}
[E] New temp variable $Ard000t created (type=string[] reference=false kind=regular)
[A] TEMP: <$Ard000t>                          VAR ARRAYBLOCK                                                  ;Address=<0000000000000044h>
[E] Requested new temp variable for type=string[] reference=true kind=regular
[D] VAR[16]: name=$Ref000t type=string[] scope={Loc:execute} address=72 const=no static=no parameter=no ref=yes temp=yes buffstore=yes length=16
[I] VAR: name=standard.$Ref000t index=16 searchindex=1, scope={Loc:execute}
[E] New temp variable $Ref000t created (type=string[] reference=true kind=regular)
[A] TEMP: <$Ref000t>                          VAR REFERENCE                                                   ;Address=<0000000000000048h>
[A] CODE:                                     REFOF <$Ref000t>,<$Ard000t>,(L)0                                ;[0000000000000D48h] 00AE 08 0000000000000048 0000000000000044 0000000000000000
[E] Temp variable $Ref000t released
[E] Token Cpx:string[]:[0] --> Operand stack {var:(string[])$Ard000t}
[E] Source used flag set on variable $Ard000t in scope {Loc:execute}
[E] Result token: var:(string[])$Ard000t
[A] CODE:                                     ACOPY <stderr>,<$Ard000t>                                       ;[0000000000000D63h] 00B3 00 0000000000000040 0000000000000044
[0] Started inner block replication (src=var:(string[])$Ard000t dst=var:(string[])stderr)
[A] CODE:                                     RPINI <stderr>,<$Ard000t>                                       ;[0000000000000D76h] 00A8 00 0000000000000040 0000000000000044
[0] Entered recursion (phase=1 level=0 cumuloffset=0 type=string[])
[A] CODE:                                     RPARR (L)0                                                      ;[0000000000000D89h] 00AA 80 0000000000000000
[0] Exited recursion (phase=1 level=0)
[0] Entered recursion (phase=2 level=0 cumuloffset=0 type=string[])
[A] CODE:                                     RPLOD (L)0                                                      ;[0000000000000D94h] 00AC 80 0000000000000000
[0] Entered recursion (phase=1 level=1 cumuloffset=0 type=string)
[A] CODE:                                       RPSTR (L)0                                                    ;[0000000000000D9Fh] 00A9 80 0000000000000000
[0] Exited recursion (phase=1 level=1)
[0] Entered recursion (phase=2 level=1 cumuloffset=0 type=string)
[0] Exited recursion (phase=2 level=1)
[A] CODE:                                     RPEND                                                           ;[0000000000000DAAh] 00AD
[0] Exited recursion (phase=2 level=0)
[0] Finished inner block replication
[A] DECL: <stderr>                            VAR ARRAYBLOCK                                                  ;Address=<0000000000000040h> = <$Ard000t> { string[] stderr=(string[]){} }
[P] -------------------------------------------------------------------------------------
[L] Read line (src):593:49: "  return execute(execfile,arg,output,stderr,true)"
[P] Parsed sentence: [Return] kw(return) id(execute) pu(() id(execfile) pu(,) id(arg) pu(,) id(output) pu(,) id(stderr) pu(,) bo(true) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;return execute(execfile,arg,output,stderr,true)
[E] ExprCompiler input: [Return] id(execute) pu(() id(execfile) pu(,) id(arg) pu(,) id(output) pu(,) id(stderr) pu(,) bo(true) pu())
[E] Release all temp variables
[E] Temp variable $Ard000t released
[E] Temp variable $Ref000t released
[E] Tokenizer ouput: func(standard.execute,5) ( {K}ind:(string)execfile , {K}ind:(string[])arg , ind:(string[])output , var:(string[])stderr , {K}1B )
[E] RPN ouput: {K}ind:(string)execfile {K}ind:(string[])arg ind:(string[])output var:(string[])stderr {K}1B func(standard.execute,5)
[E] .......... Processing token {K}ind:(string)execfile ..........
[E] Token {K}ind:(string)execfile --> Operand stack {{K}ind:(string)execfile}
[E] .......... Processing token {K}ind:(string[])arg ..........
[E] Token {K}ind:(string[])arg --> Operand stack {{K}ind:(string)execfile {K}ind:(string[])arg}
[E] .......... Processing token ind:(string[])output ..........
[E] Token ind:(string[])output --> Operand stack {{K}ind:(string)execfile {K}ind:(string[])arg ind:(string[])output}
[E] .......... Processing token var:(string[])stderr ..........
[E] Token var:(string[])stderr --> Operand stack {{K}ind:(string)execfile {K}ind:(string[])arg ind:(string[])output var:(string[])stderr}
[E] .......... Processing token {K}1B ..........
[E] Token {K}1B --> Operand stack {{K}ind:(string)execfile {K}ind:(string[])arg ind:(string[])output var:(string[])stderr {K}1B}
[E] .......... Processing token func(standard.execute,5) ..........
[E] Requested new temp variable for type=bool reference=false kind=regular
[D] VAR[17]: name=$Bol000t type=bool scope={Loc:execute} address=88 const=no static=no parameter=no ref=no temp=yes buffstore=yes length=1
[I] VAR: name=standard.$Bol000t index=17 searchindex=1, scope={Loc:execute}
[E] New temp variable $Bol000t created (type=bool reference=false kind=regular)
[A] TEMP: <$Bol000t>                          VAR BOOLEAN                                                     ;Address=<0000000000000058h>
[E] Source used flag set on variable execfile in scope {Loc:execute}
[E] Source used flag set on variable arg in scope {Loc:execute}
[E] Source used flag set on variable output in scope {Loc:execute}
[E] Source used flag set on variable stderr in scope {Loc:execute}
[A] CODE:                                     REFPU <$Bol000t>                                                ;[0000000000000DACh] 00D6 00 0000000000000058
[A] CODE:                                     PUSHr <execfile>                                                ;[0000000000000DB7h] 00D5 00 0000000000000010
[A] CODE:                                     PUSHr <arg>                                                     ;[0000000000000DC2h] 00D5 00 0000000000000020
[A] CODE:                                     PUSHr <output>                                                  ;[0000000000000DCDh] 00D5 00 0000000000000030
[A] CODE:                                     REFPU <stderr>                                                  ;[0000000000000DD8h] 00D6 00 0000000000000040
[A] CODE:                                     PUSHb (B)true                                                   ;[0000000000000DE3h] 00CF 80 01
[A] CODE:                                     SCALL (I)3                                                      ;[0000000000000DE7h] 00E9 80 00000003
[E] Token func(standard.execute,5) --> Operand stack {var:(bool)$Bol000t}
[E] Source used flag set on variable $Bol000t in scope {Loc:execute}
[E] Result token: var:(bool)$Bol000t
[A] CODE:                                     MVb *<$result>,<$Bol000t>                                       ;[0000000000000DEEh] 0076 40 0000000000000000 0000000000000058
[A] CODE:                                     RET                                                             ;[0000000000000E01h] 00E6
[P] -------------------------------------------------------------------------------------
[L] Read line (src):594:5: ":func"
[P] Parsed sentence: [EndFunction] kw(:func)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[J] Jump event: BlockEnd GlobalBaseLabel=0
[B] Code block stack updated: Pop --> {Implementation:0:0}  
[S] Scope close: {Loc:execute}
[J] Solving jump labels for scope depth 2...
[F] Solving forward calls for scope depth 2...
[F] Addr: ScopeDepth=0 Function=standard.$initsuper()
[F] Addr: ScopeDepth=0 Function=standard.execute(string,string,string[],string[])
[F] Addr: ScopeDepth=0 Function=standard.execute(string,string,string[])
[F] Addr: ScopeDepth=0 Function=standard.execute(string,string[],string[],string[])
[F] Addr: ScopeDepth=0 Function=standard.execute(string,string[],string[])
[F] Addr: ScopeDepth=0 Function=standard.getarchitecture()
[F] Addr: ScopeDepth=0 Function=standard.gethostsystem()
[F] Addr: ScopeDepth=0 Function=standard.gethostsystemname()
[F] Addr: ScopeDepth=0 Function=standard.panic(string)
[F] Addr: ScopeDepth=0 Function=standard.read(string,char[])
[F] Addr: ScopeDepth=0 Function=standard.read(string,string)
[F] Addr: ScopeDepth=0 Function=standard.read(string,string[])
[F] Addr: ScopeDepth=0 Function=standard.write(string,char[])
[F] Addr: ScopeDepth=0 Function=standard.write(string,string)
[F] Addr: ScopeDepth=0 Function=standard.write(string,string[])
[F] Addr: ScopeDepth=1 Function=standard.$initstandard()
[F] Call: ScopeDepth=1 Function=standard.$delayedinitstandard()
[S] Current scope: {Pri:main}, StackLength=2
[A] HEAD: (standard_execute6)                 FUNCTION
[A] CODE: 
[A] CODE:                                     ;End function
[A] CODE:                                     END
[P] -------------------------------------------------------------------------------------
[L] Read line (src):597:38: "fmem date(int year,int month,int day):"
[P] Parsed sentence: [Member] kw(fmem) ty(date) pu(() ty(int) id(year) pu(,) ty(int) id(month) pu(,) ty(int) id(day) pu()) pu(:)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[J] Jump event: BlockBeg GlobalBaseLabel=0
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0}  
[A] HEAD: 
[A] HEAD: ;---------------------------------------------------------------------------------------------------
[A] HEAD: ; fmem date(int year,int month,int day):
[A] HEAD: ;---------------------------------------------------------------------------------------------------
[A] HEAD: 
[F] Stored function address: id=standard_date_date fullname=standard.date.date(int,int,int) address=0000000000000E03h scopedepth=0
[Y] Update OFUN[0]: Address=3587
[A] CODE:                                     ;Reserve function stack size
[A] CODE:                                     STACK %TEXTARG0%                                                ;[0000000000000E03h] 00BB 80 %HEXARG0%
[S] Scope open: {Loc:date}
[A] DECL:                                     ;Parameters
[D] VAR[10]: name=$result type=date scope={Loc:date} address=0 const=no static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.$result index=10 searchindex=0, scope={Loc:date}
[A] DECL: <$result>                           PARM REFERENCE                                                  ;Address=<0000000000000000h>
[D] VAR[11]: name=self type=date scope={Loc:date} address=16 const=no static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.self index=11 searchindex=1, scope={Loc:date}
[A] DECL: <self>                              PARM REFERENCE                                                  ;Address=<0000000000000010h>
[D] VAR[12]: name=year type=int scope={Loc:date} address=32 const=no static=no parameter=yes ref=no temp=no buffstore=yes length=4
[I] VAR: name=standard.year index=12 searchindex=2, scope={Loc:date}
[A] DECL: <year>                              PARM INTEGER                                                    ;Address=<0000000000000020h>
[D] VAR[13]: name=month type=int scope={Loc:date} address=36 const=no static=no parameter=yes ref=no temp=no buffstore=yes length=4
[I] VAR: name=standard.month index=13 searchindex=1, scope={Loc:date}
[A] DECL: <month>                             PARM INTEGER                                                    ;Address=<0000000000000024h>
[D] VAR[14]: name=day type=int scope={Loc:date} address=40 const=no static=no parameter=yes ref=no temp=no buffstore=yes length=4
[I] VAR: name=standard.day index=14 searchindex=1, scope={Loc:date}
[A] DECL: <day>                               PARM INTEGER                                                    ;Address=<0000000000000028h>
[A] DECL: 
[S] Current scope: {Loc:date}, StackLength=3
[P] -------------------------------------------------------------------------------------
[L] Read line (src):598:37: "  self._dt=_datevalue(year,month,day)"
[P] Parsed sentence: [Expression] id(self) op(.) id(_dt) op(=) id(_datevalue) pu(() id(year) pu(,) id(month) pu(,) id(day) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;self._dt=_datevalue(year,month,day)
[E] ExprCompiler input: [Expression] id(self) op(.) id(_dt) op(=) id(_datevalue) pu(() id(year) pu(,) id(month) pu(,) id(day) pu())
[E] Release all temp variables
[E] Tokenizer ouput: ind:(date)self ._dt opr= func(standard._datevalue,3) ( var:(int)year , var:(int)month , var:(int)day )
[E] RPN ouput: ind:(date)self ._dt var:(int)year var:(int)month var:(int)day func(standard._datevalue,3) opr=
[E] .......... Processing token ind:(date)self ..........
[E] Token ind:(date)self --> Operand stack {ind:(date)self}
[E] .......... Processing token ._dt ..........
[E] Requested new temp variable for type=int reference=true kind=regular
[D] VAR[15]: name=$Ref000t type=int scope={Loc:date} address=44 const=no static=no parameter=no ref=yes temp=yes buffstore=yes length=16
[I] VAR: name=standard.$Ref000t index=15 searchindex=0, scope={Loc:date}
[E] New temp variable $Ref000t created (type=int reference=true kind=regular)
[A] TEMP: <$Ref000t>                          VAR REFERENCE                                                   ;Address=<000000000000002Ch>
[A] CODE:                                     REFOF <$Ref000t>,*<self>,(L)0                                   ;[0000000000000E0Eh] 00AE 18 000000000000002C 0000000000000010 0000000000000000
[E] Token ._dt --> Operand stack {ind:(int)$Ref000t{src=self}}
[E] .......... Processing token var:(int)year ..........
[E] Token var:(int)year --> Operand stack {ind:(int)$Ref000t{src=self} var:(int)year}
[E] .......... Processing token var:(int)month ..........
[E] Token var:(int)month --> Operand stack {ind:(int)$Ref000t{src=self} var:(int)year var:(int)month}
[E] .......... Processing token var:(int)day ..........
[E] Token var:(int)day --> Operand stack {ind:(int)$Ref000t{src=self} var:(int)year var:(int)month var:(int)day}
[E] .......... Processing token func(standard._datevalue,3) ..........
[E] Requested new temp variable for type=int reference=false kind=regular
[D] VAR[16]: name=$Int000t type=int scope={Loc:date} address=60 const=no static=no parameter=no ref=no temp=yes buffstore=yes length=4
[I] VAR: name=standard.$Int000t index=16 searchindex=0, scope={Loc:date}
[E] New temp variable $Int000t created (type=int reference=false kind=regular)
[A] TEMP: <$Int000t>                          VAR INTEGER                                                     ;Address=<000000000000003Ch>
[E] Source used flag set on variable year in scope {Loc:date}
[E] Source used flag set on variable month in scope {Loc:date}
[E] Source used flag set on variable day in scope {Loc:date}
[A] CODE:                                     REFPU <$Int000t>                                                ;[0000000000000E29h] 00D6 00 000000000000003C
[A] CODE:                                     PUSHi <year>                                                    ;[0000000000000E34h] 00D2 00 0000000000000020
[A] CODE:                                     PUSHi <month>                                                   ;[0000000000000E3Fh] 00D2 00 0000000000000024
[A] CODE:                                     PUSHi <day>                                                     ;[0000000000000E4Ah] 00D2 00 0000000000000028
[A] CODE:                                     SCALL (I)72                                                     ;[0000000000000E55h] 00E9 80 00000048
[E] Token func(standard._datevalue,3) --> Operand stack {ind:(int)$Ref000t{src=self} var:(int)$Int000t}
[E] .......... Processing token opr= ..........
[E] Temp variable $Int000t released
[E] Temp variable $Ref000t released
[E] Source used flag set on variable $Int000t in scope {Loc:date}
[A] CODE:                                     MVi *<$Ref000t>,<$Int000t>                                      ;[0000000000000E5Ch] 0079 40 000000000000002C 000000000000003C
[E] Temp variable $Ref000t locked
[E] Token opr= --> Operand stack {ind:(int)$Ref000t{src=self}}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):599:13: "  return self"
[P] Parsed sentence: [Return] kw(return) id(self)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;return self
[E] ExprCompiler input: [Return] id(self)
[E] Release all temp variables
[E] Temp variable $Ref000t released
[E] Temp variable $Int000t released
[E] Tokenizer ouput: ind:(date)self
[E] RPN ouput: ind:(date)self
[E] .......... Processing token ind:(date)self ..........
[E] Token ind:(date)self --> Operand stack {ind:(date)self}
[E] Source used flag set on variable self in scope {Loc:date}
[E] Result token: ind:(date)self
[A] CODE:                                     COPY *<$result>,*<self>,(L)4                                    ;[0000000000000E6Fh] 00B0 58 0000000000000000 0000000000000010 0000000000000004
[A] CODE:                                     RET                                                             ;[0000000000000E8Ah] 00E6
[P] -------------------------------------------------------------------------------------
[L] Read line (src):600:5: ":fmem"
[P] Parsed sentence: [EndMember] kw(:fmem)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[J] Jump event: BlockEnd GlobalBaseLabel=0
[B] Code block stack updated: Pop --> {Implementation:0:0}  
[S] Scope close: {Loc:date}
[J] Solving jump labels for scope depth 2...
[F] Solving forward calls for scope depth 2...
[F] Addr: ScopeDepth=0 Function=standard.$initsuper()
[F] Addr: ScopeDepth=0 Function=standard.date.date(int,int,int)
[F] Addr: ScopeDepth=0 Function=standard.execute(string,string,string[],string[])
[F] Addr: ScopeDepth=0 Function=standard.execute(string,string,string[])
[F] Addr: ScopeDepth=0 Function=standard.execute(string,string[],string[],string[])
[F] Addr: ScopeDepth=0 Function=standard.execute(string,string[],string[])
[F] Addr: ScopeDepth=0 Function=standard.getarchitecture()
[F] Addr: ScopeDepth=0 Function=standard.gethostsystem()
[F] Addr: ScopeDepth=0 Function=standard.gethostsystemname()
[F] Addr: ScopeDepth=0 Function=standard.panic(string)
[F] Addr: ScopeDepth=0 Function=standard.read(string,char[])
[F] Addr: ScopeDepth=0 Function=standard.read(string,string)
[F] Addr: ScopeDepth=0 Function=standard.read(string,string[])
[F] Addr: ScopeDepth=0 Function=standard.write(string,char[])
[F] Addr: ScopeDepth=0 Function=standard.write(string,string)
[F] Addr: ScopeDepth=0 Function=standard.write(string,string[])
[F] Addr: ScopeDepth=1 Function=standard.$initstandard()
[F] Call: ScopeDepth=1 Function=standard.$delayedinitstandard()
[S] Current scope: {Pri:main}, StackLength=2
[A] HEAD: (standard_date_date)                FUNCTION
[A] CODE: 
[A] CODE:                                     ;End function
[A] CODE:                                     END
[P] -------------------------------------------------------------------------------------
[L] Read line (src):603:49: "fmem void date.value(int year,int month,int day):"
[P] Parsed sentence: [Member] kw(fmem) kw(void) ty(date) op(.) id(value) pu(() ty(int) id(year) pu(,) ty(int) id(month) pu(,) ty(int) id(day) pu()) pu(:)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[J] Jump event: BlockBeg GlobalBaseLabel=0
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0}  
[A] HEAD: 
[A] HEAD: ;---------------------------------------------------------------------------------------------------
[A] HEAD: ; fmem void date.value(int year,int month,int day):
[A] HEAD: ;---------------------------------------------------------------------------------------------------
[A] HEAD: 
[F] Stored function address: id=standard_date_value fullname=standard.date.value(int,int,int) address=0000000000000E8Ch scopedepth=0
[Y] Update OFUN[1]: Address=3724
[A] CODE:                                     ;Reserve function stack size
[A] CODE:                                     STACK %TEXTARG0%                                                ;[0000000000000E8Ch] 00BB 80 %HEXARG0%
[S] Scope open: {Loc:value}
[A] DECL:                                     ;Parameters
[D] VAR[10]: name=self type=date scope={Loc:value} address=0 const=no static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.self index=10 searchindex=0, scope={Loc:value}
[A] DECL: <self>                              PARM REFERENCE                                                  ;Address=<0000000000000000h>
[D] VAR[11]: name=year type=int scope={Loc:value} address=16 const=no static=no parameter=yes ref=no temp=no buffstore=yes length=4
[I] VAR: name=standard.year index=11 searchindex=1, scope={Loc:value}
[A] DECL: <year>                              PARM INTEGER                                                    ;Address=<0000000000000010h>
[D] VAR[12]: name=month type=int scope={Loc:value} address=20 const=no static=no parameter=yes ref=no temp=no buffstore=yes length=4
[I] VAR: name=standard.month index=12 searchindex=0, scope={Loc:value}
[A] DECL: <month>                             PARM INTEGER                                                    ;Address=<0000000000000014h>
[D] VAR[13]: name=day type=int scope={Loc:value} address=24 const=no static=no parameter=yes ref=no temp=no buffstore=yes length=4
[I] VAR: name=standard.day index=13 searchindex=0, scope={Loc:value}
[A] DECL: <day>                               PARM INTEGER                                                    ;Address=<0000000000000018h>
[A] DECL: 
[S] Current scope: {Loc:value}, StackLength=3
[P] -------------------------------------------------------------------------------------
[L] Read line (src):604:37: "  self._dt=_datevalue(year,month,day)"
[P] Parsed sentence: [Expression] id(self) op(.) id(_dt) op(=) id(_datevalue) pu(() id(year) pu(,) id(month) pu(,) id(day) pu())
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;self._dt=_datevalue(year,month,day)
[E] ExprCompiler input: [Expression] id(self) op(.) id(_dt) op(=) id(_datevalue) pu(() id(year) pu(,) id(month) pu(,) id(day) pu())
[E] Release all temp variables
[E] Tokenizer ouput: ind:(date)self ._dt opr= func(standard._datevalue,3) ( var:(int)year , var:(int)month , var:(int)day )
[E] RPN ouput: ind:(date)self ._dt var:(int)year var:(int)month var:(int)day func(standard._datevalue,3) opr=
[E] .......... Processing token ind:(date)self ..........
[E] Token ind:(date)self --> Operand stack {ind:(date)self}
[E] .......... Processing token ._dt ..........
[E] Requested new temp variable for type=int reference=true kind=regular
[D] VAR[14]: name=$Ref000t type=int scope={Loc:value} address=28 const=no static=no parameter=no ref=yes temp=yes buffstore=yes length=16
[I] VAR: name=standard.$Ref000t index=14 searchindex=0, scope={Loc:value}
[E] New temp variable $Ref000t created (type=int reference=true kind=regular)
[A] TEMP: <$Ref000t>                          VAR REFERENCE                                                   ;Address=<000000000000001Ch>
[A] CODE:                                     REFOF <$Ref000t>,*<self>,(L)0                                   ;[0000000000000E97h] 00AE 18 000000000000001C 0000000000000000 0000000000000000
[E] Token ._dt --> Operand stack {ind:(int)$Ref000t{src=self}}
[E] .......... Processing token var:(int)year ..........
[E] Token var:(int)year --> Operand stack {ind:(int)$Ref000t{src=self} var:(int)year}
[E] .......... Processing token var:(int)month ..........
[E] Token var:(int)month --> Operand stack {ind:(int)$Ref000t{src=self} var:(int)year var:(int)month}
[E] .......... Processing token var:(int)day ..........
[E] Token var:(int)day --> Operand stack {ind:(int)$Ref000t{src=self} var:(int)year var:(int)month var:(int)day}
[E] .......... Processing token func(standard._datevalue,3) ..........
[E] Requested new temp variable for type=int reference=false kind=regular
[D] VAR[15]: name=$Int000t type=int scope={Loc:value} address=44 const=no static=no parameter=no ref=no temp=yes buffstore=yes length=4
[I] VAR: name=standard.$Int000t index=15 searchindex=0, scope={Loc:value}
[E] New temp variable $Int000t created (type=int reference=false kind=regular)
[A] TEMP: <$Int000t>                          VAR INTEGER                                                     ;Address=<000000000000002Ch>
[E] Source used flag set on variable year in scope {Loc:value}
[E] Source used flag set on variable month in scope {Loc:value}
[E] Source used flag set on variable day in scope {Loc:value}
[A] CODE:                                     REFPU <$Int000t>                                                ;[0000000000000EB2h] 00D6 00 000000000000002C
[A] CODE:                                     PUSHi <year>                                                    ;[0000000000000EBDh] 00D2 00 0000000000000010
[A] CODE:                                     PUSHi <month>                                                   ;[0000000000000EC8h] 00D2 00 0000000000000014
[A] CODE:                                     PUSHi <day>                                                     ;[0000000000000ED3h] 00D2 00 0000000000000018
[A] CODE:                                     SCALL (I)72                                                     ;[0000000000000EDEh] 00E9 80 00000048
[E] Token func(standard._datevalue,3) --> Operand stack {ind:(int)$Ref000t{src=self} var:(int)$Int000t}
[E] .......... Processing token opr= ..........
[E] Temp variable $Int000t released
[E] Temp variable $Ref000t released
[E] Source used flag set on variable $Int000t in scope {Loc:value}
[A] CODE:                                     MVi *<$Ref000t>,<$Int000t>                                      ;[0000000000000EE5h] 0079 40 000000000000001C 000000000000002C
[E] Temp variable $Ref000t locked
[E] Token opr= --> Operand stack {ind:(int)$Ref000t{src=self}}
[P] -------------------------------------------------------------------------------------
[L] Read line (src):605:5: ":fmem"
[P] Parsed sentence: [EndMember] kw(:fmem)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[J] Jump event: BlockEnd GlobalBaseLabel=0
[B] Code block stack updated: Pop --> {Implementation:0:0}  
[A] CODE:                                     RET                                                             ;[0000000000000EF8h] 00E6
[S] Scope close: {Loc:value}
[J] Solving jump labels for scope depth 2...
[F] Solving forward calls for scope depth 2...
[F] Addr: ScopeDepth=0 Function=standard.$initsuper()
[F] Addr: ScopeDepth=0 Function=standard.date.date(int,int,int)
[F] Addr: ScopeDepth=0 Function=standard.date.value(int,int,int)
[F] Addr: ScopeDepth=0 Function=standard.execute(string,string,string[],string[])
[F] Addr: ScopeDepth=0 Function=standard.execute(string,string,string[])
[F] Addr: ScopeDepth=0 Function=standard.execute(string,string[],string[],string[])
[F] Addr: ScopeDepth=0 Function=standard.execute(string,string[],string[])
[F] Addr: ScopeDepth=0 Function=standard.getarchitecture()
[F] Addr: ScopeDepth=0 Function=standard.gethostsystem()
[F] Addr: ScopeDepth=0 Function=standard.gethostsystemname()
[F] Addr: ScopeDepth=0 Function=standard.panic(string)
[F] Addr: ScopeDepth=0 Function=standard.read(string,char[])
[F] Addr: ScopeDepth=0 Function=standard.read(string,string)
[F] Addr: ScopeDepth=0 Function=standard.read(string,string[])
[F] Addr: ScopeDepth=0 Function=standard.write(string,char[])
[F] Addr: ScopeDepth=0 Function=standard.write(string,string)
[F] Addr: ScopeDepth=0 Function=standard.write(string,string[])
[F] Addr: ScopeDepth=1 Function=standard.$initstandard()
[F] Call: ScopeDepth=1 Function=standard.$delayedinitstandard()
[S] Current scope: {Pri:main}, StackLength=2
[A] HEAD: (standard_date_value)               FUNCTION
[A] CODE: 
[A] CODE:                                     ;End function
[A] CODE:                                     END
[P] -------------------------------------------------------------------------------------
[L] Read line (src):608:28: "fmem date date.begofmonth():"
[P] Parsed sentence: [Member] kw(fmem) ty(date) ty(date) op(.) id(begofmonth) pu(() pu()) pu(:)
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[J] Jump event: BlockBeg GlobalBaseLabel=0
[B] Code block stack updated: Push --> {Implementation:0:0 Local:0:0}  
[A] HEAD: 
[A] HEAD: ;---------------------------------------------------------------------------------------------------
[A] HEAD: ; fmem date date.begofmonth():
[A] HEAD: ;---------------------------------------------------------------------------------------------------
[A] HEAD: 
[F] Stored function address: id=standard_date_begofmonth fullname=standard.date.begofmonth() address=0000000000000EFAh scopedepth=0
[Y] Update OFUN[2]: Address=3834
[A] CODE:                                     ;Reserve function stack size
[A] CODE:                                     STACK %TEXTARG0%                                                ;[0000000000000EFAh] 00BB 80 %HEXARG0%
[S] Scope open: {Loc:begofmonth}
[A] DECL:                                     ;Parameters
[D] VAR[10]: name=$result type=date scope={Loc:begofmonth} address=0 const=no static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.$result index=10 searchindex=0, scope={Loc:begofmonth}
[A] DECL: <$result>                           PARM REFERENCE                                                  ;Address=<0000000000000000h>
[D] VAR[11]: name=self type=date scope={Loc:begofmonth} address=16 const=no static=no parameter=yes ref=yes temp=no buffstore=yes length=16
[I] VAR: name=standard.self index=11 searchindex=1, scope={Loc:begofmonth}
[A] DECL: <self>                              PARM REFERENCE                                                  ;Address=<0000000000000010h>
[A] DECL: 
[S] Current scope: {Loc:begofmonth}, StackLength=3
[P] -------------------------------------------------------------------------------------
[L] Read line (src):609:38: "  return (date){_begofmonth(self._dt)}"
[P] Parsed sentence: [Return] kw(return) pu(() ty(date) pu()) pu({) id(_begofmonth) pu(() id(self) op(.) id(_dt) pu()) pu(})
[J] Sentence labels: BaseLabel=0 SubLabel=0 BlockId={} LoopLabel=-1 LoopId={}
[A] CODE: 
[A] CODE:                                     ;return (date){_begofmonth(self._dt)}
[E] ExprCompiler input: [Return] pu(() ty(date) pu()) pu({) id(_begofmonth) pu(() id(self) op(.) id(_dt) pu()) pu(})
[E] Release all temp variables
